// Knowledge Generation Tools - Tools for generating and managing project knowledge

use adk_core::{Tool, ToolContext};
use async_trait::async_trait;
use serde_json::{json, Value};
use std::sync::Arc;
use std::fs;

use crate::persistence::{IterationStore, MemoryStore};
use crate::storage::get_iteration_id;
use crate::domain::IterationKnowledge;

// ============================================================================
// LoadDocumentSummaryTool - Load pre-summarized iteration documents
// ============================================================================

pub struct LoadDocumentSummaryTool {
    iteration_id: String,
}

impl LoadDocumentSummaryTool {
    pub fn new(iteration_id: String) -> Self {
        Self { iteration_id }
    }
}

#[async_trait]
impl Tool for LoadDocumentSummaryTool {
    fn name(&self) -> &str {
        "load_document_summary"
    }

    fn description(&self) -> &str {
        "Load a pre-summarized iteration document (idea, prd, design, or plan). Use this to access the concise summaries generated by the Summary Agent."
    }

    fn parameters_schema(&self) -> Option<Value> {
        Some(json!({
            "type": "object",
            "properties": {
                "doc_type": {
                    "type": "string",
                    "description": "Type of document to load",
                    "enum": ["idea", "prd", "design", "plan"],
                    "required": true
                }
            },
            "required": ["doc_type"]
        }))
    }

    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {
        let doc_type = args.get("doc_type")
            .and_then(|v| v.as_str())
            .ok_or_else(|| adk_core::AdkError::Tool("doc_type is required".to_string()))?;

        let iteration_store = IterationStore::new();
        let iteration_dir = iteration_store.iteration_path(&self.iteration_id)
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to get iteration path: {}", e)))?;

        let summary_dir = iteration_dir.join("summaries");
        let file_path = summary_dir.join(format!("{}.md", doc_type));

        if !file_path.exists() {
            return Ok(json!({
                "exists": false,
                "doc_type": doc_type,
                "message": format!("Summary file not found: {}", file_path.display())
            }));
        }

        let content = fs::read_to_string(&file_path)
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to read summary: {}", e)))?;

        Ok(json!({
            "exists": true,
            "doc_type": doc_type,
            "content": content,
            "path": file_path.to_string_lossy().to_string()
        }))
    }
}

// ============================================================================
// LoadBaseKnowledgeTool - Load base iteration knowledge for evolution iterations
// ============================================================================

pub struct LoadBaseKnowledgeTool {
    base_iteration_id: String,
}

impl LoadBaseKnowledgeTool {
    pub fn new(base_iteration_id: String) -> Self {
        Self { base_iteration_id }
    }
}

#[async_trait]
impl Tool for LoadBaseKnowledgeTool {
    fn name(&self) -> &str {
        "load_base_knowledge"
    }

    fn description(&self) -> &str {
        "Load the knowledge snapshot from the base iteration. Use this to understand what was already implemented before the current evolution iteration."
    }

    fn parameters_schema(&self) -> Option<Value> {
        Some(json!({
            "type": "object",
            "properties": {},
            "required": []
        }))
    }

    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {
        let memory_store = MemoryStore::new();
        let project_memory = memory_store.load_project_memory()
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to load project memory: {}", e)))?;

        let base_knowledge = project_memory.get_iteration_knowledge(&self.base_iteration_id);

        match base_knowledge {
            Some(knowledge) => {
                Ok(json!({
                    "exists": true,
                    "base_iteration_id": self.base_iteration_id,
                    "iteration_number": knowledge.iteration_number,
                    "idea_summary": knowledge.idea_summary,
                    "prd_summary": knowledge.prd_summary,
                    "design_summary": knowledge.design_summary,
                    "plan_summary": knowledge.plan_summary,
                    "tech_stack": knowledge.tech_stack,
                    "key_decisions": knowledge.key_decisions,
                    "key_patterns": knowledge.key_patterns,
                    "code_structure": knowledge.code_structure,
                    "known_issues": knowledge.known_issues
                }))
            }
            None => {
                Ok(json!({
                    "exists": false,
                    "base_iteration_id": self.base_iteration_id,
                    "message": "No knowledge found for base iteration"
                }))
            }
        }
    }
}

// ============================================================================
// SaveKnowledgeSnapshotTool - Save the generated knowledge snapshot
// ============================================================================

pub struct SaveKnowledgeSnapshotTool {
    iteration_id: String,
    iteration_number: u32,
}

impl SaveKnowledgeSnapshotTool {
    pub fn new(iteration_id: String, iteration_number: u32) -> Self {
        Self { iteration_id, iteration_number }
    }
}

#[async_trait]
impl Tool for SaveKnowledgeSnapshotTool {
    fn name(&self) -> &str {
        "save_knowledge_snapshot"
    }

    fn description(&self) -> &str {
        "Save the generated knowledge snapshot for this iteration. This will be stored in project memory and used as context for future iterations."
    }

    fn parameters_schema(&self) -> Option<Value> {
        Some(json!({
            "type": "object",
            "properties": {
                "knowledge_json": {
                    "type": "string",
                    "description": "The complete knowledge snapshot as a JSON string",
                    "required": true
                }
            },
            "required": ["knowledge_json"]
        }))
    }

    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {
        let knowledge_json = args.get("knowledge_json")
            .and_then(|v| v.as_str())
            .ok_or_else(|| adk_core::AdkError::Tool("knowledge_json is required".to_string()))?;

        // Parse the JSON
        let mut knowledge: IterationKnowledge = serde_json::from_str(knowledge_json)
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to parse knowledge JSON: {}", e)))?;

        // Ensure iteration_id and iteration_number are set correctly
        knowledge.iteration_id = self.iteration_id.clone();
        knowledge.iteration_number = self.iteration_number;

        // Save to project memory
        let memory_store = MemoryStore::new();
        let mut project_memory = memory_store.load_project_memory()
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to load project memory: {}", e)))?;

        project_memory.save_iteration_knowledge(knowledge);
        memory_store.save_project_memory(&project_memory)
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to save project memory: {}", e)))?;

        Ok(json!({
            "success": true,
            "message": "Knowledge snapshot saved successfully",
            "iteration_id": self.iteration_id,
            "iteration_number": self.iteration_number
        }))
    }
}

// ============================================================================
// ListFilesTool (Extended) - List files with workspace path support
// ============================================================================

pub struct ListFilesWorkspaceTool;

#[async_trait]
impl Tool for ListFilesWorkspaceTool {
    fn name(&self) -> &str {
        "list_files"
    }

    fn description(&self) -> &str {
        "List files in the iteration workspace directory. Use this to understand the project structure and identify important files to read."
    }

    fn parameters_schema(&self) -> Option<Value> {
        Some(json!({
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Relative path within workspace (default: current directory)",
                    "default": "."
                },
                "recursive": {
                    "type": "boolean",
                    "description": "List files recursively (default: true)",
                    "default": true
                }
            },
            "required": []
        }))
    }

    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {
        let path = args.get("path")
            .and_then(|v| v.as_str())
            .unwrap_or(".");
        let recursive = args.get("recursive")
            .and_then(|v| v.as_bool())
            .unwrap_or(true);

        let iteration_id = get_iteration_id()
            .ok_or_else(|| adk_core::AdkError::Tool("Iteration ID not set".to_string()))?;

        let iteration_store = IterationStore::new();
        let workspace_dir = iteration_store.workspace_path(&iteration_id)
            .map_err(|e| adk_core::AdkError::Tool(format!("Failed to get workspace: {}", e)))?;

        let target_path = workspace_dir.join(path);

        if !target_path.exists() {
            return Ok(json!({
                "exists": false,
                "path": path,
                "message": "Path does not exist"
            }));
        }

        let mut files = Vec::new();

        if recursive {
            let mut walker = walkdir::WalkDir::new(&target_path);
            walker = walker.min_depth(1).max_depth(10);
            for entry in walker.into_iter().filter_map(|e| e.ok()) {
                // Strip UNC prefixes for reliable comparison
                let entry_path_stripped = crate::tools::file_tools::strip_unc_prefix(entry.path());
                let workspace_dir_stripped = crate::tools::file_tools::strip_unc_prefix(&workspace_dir);

                let rel_path = entry_path_stripped
                    .strip_prefix(&workspace_dir_stripped)
                    .unwrap_or(&entry_path_stripped)
                    .to_string_lossy()
                    .to_string();

                if entry.path().is_file() {
                    let metadata = entry.metadata().ok();
                    let size = metadata.as_ref().map(|m: &std::fs::Metadata| m.len()).unwrap_or(0);

                    files.push(json!({
                        "path": rel_path,
                        "size": size,
                        "is_file": true
                    }));
                }
            }
        } else {
            if let Ok(entries) = fs::read_dir(&target_path) {
                for entry in entries.filter_map(|e| e.ok()) {
                    let file_name = entry.file_name().to_string_lossy().to_string();
                    let file_type = if entry.path().is_file() { "file" } else { "directory" };

                    files.push(json!({
                        "name": file_name,
                        "type": file_type
                    }));
                }
            }
        }

        // Sort files by path
        files.sort_by(|a, b| {
            let path_a = a.get("path").and_then(|v| v.as_str()).unwrap_or("");
            let path_b = b.get("path").and_then(|v| v.as_str()).unwrap_or("");
            path_a.cmp(path_b)
        });

        Ok(json!({
            "workspace": workspace_dir.to_string_lossy().to_string(),
            "path": path,
            "recursive": recursive,
            "total_files": files.len(),
            "files": files
        }))
    }
}
