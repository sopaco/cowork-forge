# Core Workflows

## 1. Workflow Overview

Cowork Forge implements a sophisticated multi-agent workflow system that automates the complete software development lifecycle from ideation to delivery. The system orchestrates specialized AI agents through a sequential pipeline with strategic human-in-the-loop (HITL) integration points for quality control and decision-making.

### System Main Workflows

The system supports three primary workflow patterns:

1. **New Project Initiation**: Complete end-to-end development from idea to delivery
2. **Project Resumption**: Intelligent continuation of interrupted sessions 
3. **Incremental Updates**: Targeted modifications based on requirement changes

### Core Execution Paths

```mermaid
flowchart TD
    A[User CLI Command] --> B{Workflow Type}
    B -->|New Project| C[Idea Intake]
    B -->|Resume| D[Detect Last Stage]
    B -->|Modify| E[Load Current PRD]
    
    C --> F[PRD Generation]
    D --> F
    E --> G[Delta Analysis]
    
    F --> H[Design Generation]
    G --> H
    
    H --> I[Implementation Planning]
    I --> J[Coding Execution]
    J --> K[Quality Verification]
    K --> L{Failed?}
    L -->|Yes| M[Feedback Analysis]
    L -->|No| N[Delivery Report]
    M --> J
    N --> O[Project Complete]
```

### Key Process Nodes

- **CLI Command Parsing**: Entry point for user interaction
- **Agent Orchestration**: Sequential execution of specialized agents
- **HITL Integration**: Human review at critical decision points
- **Artifact Persistence**: Structured data management via JSON/Markdown
- **Quality Gates**: Automated validation and verification checks

## 2. Main Workflows

### 2.1 Core Development Workflow

The primary workflow transforms user ideas into implemented software through seven sequential stages:

```mermaid
sequenceDiagram
    participant U as User
    participant CLI as CLI Entry Point
    participant ORCH as Orchestrator
    participant AGENTS as Agent Pipeline
    participant STORE as Artifact Store
    participant HITL as HITL Controller
    
    U->>CLI: cowork init "project idea"
    CLI->>ORCH: create_cowork_pipeline()
    ORCH->>STORE: initialize .cowork/ directory
    
    loop For each stage: Idea→PRD→Design→Plan→Coding→Check→Delivery
        ORCH->>AGENTS: execute_stage_agent()
        AGENTS->>STORE: load_previous_artifacts()
        AGENTS->>AGENTS: generate_content()
        AGENTS->>HITL: review_and_edit_file()
        HITL->>U: display preview, await input
        U->>HITL: approve/edit/feedback
        HITL->>AGENTS: return user_action
        AGENTS->>STORE: save_artifact()
        ORCH->>ORCH: update_session_metadata()
    end
    
    ORCH->>CLI: workflow_complete()
    CLI->>U: delivery report generated
```

#### Stage 1: Idea Intake Process
**Input**: Natural language project description
**Output**: Structured IdeaSpec artifact
**Key Operations**:
- LLM-powered parsing of user input into structured fields
- Generation of `idea.md` with predefined sections
- HITL review for refinement
- Persistence to `.cowork/data/idea_spec.json`

#### Stage 2: PRD Generation Process  
**Input**: IdeaSpec artifact
**Output**: Product Requirements Document
**Key Operations**:
- Transform idea into formal requirements and features
- Create `prd.md` with scope, constraints, success criteria
- HITL review with feedback incorporation
- Generate structured `requirements.json` and `feature_list.json`

#### Stage 3: Design Generation Process
**Input**: PRD artifact  
**Output**: Technical Design Document
**Key Operations**:
- Analyze requirements to produce architectural design
- Generate `design.md` covering CLI modes, workflows, components
- HITL review of technical approach
- Create `design_spec.json` with component specifications

#### Stage 4: Implementation Planning Process
**Input**: Design artifact
**Output**: Implementation Plan and Task List
**Key Operations**:
- Break down design into executable tasks
- Generate prioritized task list with dependencies
- HITL review of implementation approach
- Create `implementation_plan.json` and `todo_list.json`

#### Stage 5: Coding Execution Process
**Input**: Implementation plan
**Output**: Generated/modified code files
**Key Operations**:
- CodePlanner analyzes project structure and generates change plan
- HITL confirmation of proposed changes
- CodeExecutor applies changes using file manipulation tools
- Update task status based on execution results

#### Stage 6: Verification and Validation Process
**Input**: Generated code and requirement artifacts
**Output**: CheckReport with quality assessment
**Key Operations**:
- Execute project-specific verification commands
- Validate requirement coverage and structural integrity
- Generate comprehensive check report
- Automatic progression or feedback loop initiation

#### Stage 7: Delivery Report Generation
**Input**: All previous artifacts
**Output**: Final delivery documentation
**Key Operations**:
- Aggregate capabilities, limitations, usage instructions
- Generate `delivery_report.md`
- Mark project as complete

### 2.2 Project Resumption Workflow

Intelligent session recovery mechanism that preserves workflow state:

```mermaid
flowchart TD
    A[用户协作简历] --> B[CLI检测目录]
    B --> C[加载会话元数据]
    C --> D{确定最后完成阶段}
    
    D -->|"Idea"| E[从PRD阶段开始]
    D -->|"PRD"| F[从设计阶段开始]
    D -->|"Design"| G[从计划阶段开始]
    D -->|"Plan"| H[从编码阶段开始]
    D -->|"Coding"| I[从检查阶段开始]
    
    E --> J[加载所有工件]
    F --> J
    G --> J
    H --> J
    I --> J
    
    J --> K[创建恢复流水线]
    K --> L[执行剩余阶段]
    L --> M[项目完成]
```

**Key Features**:
- **Artifact Detection**: Scans `.cowork/` directory for existing files
- **Stage Inference**: Analyzes artifact completeness to determine restart point
- **Context Preservation**: Loads all previous artifacts into memory
- **Pipeline Construction**: Builds partial pipeline starting from detected stage

### 2.3 Incremental Update Workflow

Efficient modification process for requirement changes:

```mermaid
sequenceDiagram
    participant U as User
    participant CLI as CLI Entry Point
    participant UPD as CodeUpdater
    participant STORE as Artifact Store
    participant CODING as CodingStageAgent
    
    U->>CLI: cowork modify "updated requirements"
    CLI->>STORE: load_current_prd()
    STORE->>CLI: return current PRD
    CLI->>UPD: analyze_delta(current_prd, new_input)
    
    UPD->>UPD: identify_added_modified_removed()
    UPD->>STORE: load_requirement_file_mappings()
    UPD->>UPD: map_delta_to_affected_files()
    UPD->>UPD: generate_update_plan()
    
    UPD->>CODING: execute_with_plan(update_plan)
    CODING->>STORE: load_related_artifacts()
    CODING->>CODING: generate_code_changes()
    CODING->>U: request_HITL_confirmation()
    U->>CODING: approve_changes()
    CODING->>CODING: apply_incremental_edits()
    CODING->>STORE: update_artifacts()
```

**Delta Analysis Process**:
1. **Requirement Comparison**: Identify added, modified, removed requirements
2. **File Mapping**: Correlate requirements to affected source files
3. **Change Isolation**: Focus edits only on impacted components
4. **Plan Generation**: Structured update instructions for CodeExecutor

## 3. Flow Coordination and Control

### 3.1 Multi-Agent Coordination

The system employs a sophisticated agent orchestration mechanism:

```mermaid
graph TB
    subgraph "Agent Orchestration Layer"
        ORCH[Pipeline Orchestrator]
        EXEC[Stage Executor]
        CTX[StageAgentContext]
    end
    
    subgraph "Specialized Agents"
        IDEA[IdeaIntakeAgent]
        PRD[PRDAgent]
        DESIGN[DesignAgent]
        PLAN[PlanAgent]
        CODE[CodingStageAgent]
        CHECK[CheckAgent]
        DELIVERY[DeliveryAgent]
    end
    
    subgraph "Supporting Agents"
        WATCH[WatchDogAgent]
        FEEDBACK[FeedbackAgent]
        UPDATER[CodeUpdater]
        TODO[TodoManager]
    end
    
    ORCH --> EXEC
    EXEC --> CTX
    CTX --> IDEA
    CTX --> PRD
    CTX --> DESIGN
    CTX --> PLAN
    CTX --> CODE
    CTX --> CHECK
    CTX --> DELIVERY
    
    CODE --> TODO
    CHECK --> FEEDBACK
    WATCH --> ALL[All Agents]
```

**Coordination Mechanisms**:
- **Sequential Execution**: Strict stage ordering with dependency validation
- **Context Sharing**: Shared StageAgentContext for resource access
- **State Propagation**: ArtifactStore ensures data consistency across stages
- **Error Containment**: Stage-level error handling prevents cascade failures

### 3.2 State Management and Synchronization

```mermaid
stateDiagram-v2
    [*] --> INITIALIZING
    INITIALIZING --> IDEA_GENERATION
    IDEA_GENERATION --> PRD_GENERATION
    PRD_GENERATION --> DESIGN_GENERATION
    DESIGN_GENERATION --> PLANNING
    PLANNING --> CODING
    CODING --> VERIFICATION
    VERIFICATION --> DELIVERY
    DELIVERY --> COMPLETED
    
    VERIFICATION --> CODING : Validation Failed
    VERIFICATION --> FEEDBACK_ANALYSIS : Issues Found
    FEEDBACK_ANALYSIS --> CODING : Rerun Coding
    FEEDBACK_ANALYSIS --> PLANNING : Rerun Planning
    
    COMPLETED --> [*]
```

**State Persistence Strategy**:
- **Session Metadata**: Tracks current stage, timestamps, restart reasons
- **Artifact Versioning**: Each stage produces versioned artifacts
- **Progress Tracking**: TodoListManager monitors task completion
- **Resume Point Detection**: Automated stage completion analysis

### 3.3 Data Flow Architecture

```mermaid
flowchart LR
    subgraph "Input Data Flow"
        A[User Input] --> B[CLI Parameters]
        C[Config Files] --> D[System Configuration]
        E[Existing Artifacts] --> F[Resume Context]
    end
    
    subgraph "Processing Pipeline"
        B --> G[Agent Execution]
        D --> G
        F --> G
        G --> H[Artifact Generation]
    end
    
    subgraph "Output Data Flow"
        H --> I[JSON Artifacts]
        H --> J[Markdown Docs]
        H --> K[Source Code]
        I --> L[Artifact Store]
        J --> L
        K --> M[Project Files]
    end
    
    L --> N[Delivery Report]
    M --> O[Final Project]
```

## 4. Exception Handling and Recovery

### 4.1 Error Detection and Classification

The system implements comprehensive error detection across multiple dimensions:

**Error Categories**:
- **LLM API Errors**: Rate limits, authentication failures, network issues
- **File System Errors**: Permission denied, disk full, path violations  
- **Validation Errors**: Schema violations, dependency cycles, coverage gaps
- **Execution Errors**: Command failures, syntax errors, runtime exceptions

### 4.2 Exception Recovery Mechanisms

```mermaid
flowchart TD
    A[Agent Execution] --> B{Error Occurred?}
    B -->|No| C[Continue Normal Flow]
    B -->|Yes| D{Error Type}
    
    D -->|LLM API| E[Apply Rate Limiting]
    E --> F[Retry with Backoff]
    F --> G{Max Retries Exceeded?}
    G -->|No| A
    G -->|Yes| H[Graceful Degradation]
    
    D -->|File System| I[Path Validation]
    I --> J[Directory Creation]
    J --> K[Retry Operation]
    K --> A
    
    D -->|Validation| L[Generate Detailed Report]
    L --> M[Trigger Feedback Agent]
    M --> N[Determine Rerun Stages]
    N --> O[Restart from Stage]
    
    D -->|Execution| P[Error Analysis]
    P --> Q[Extract File Paths]
    Q --> R[Update TodoList Status]
    R --> M
```

**Recovery Strategies**:
- **Retry with Exponential Backoff**: For transient errors (network, API limits)
- **Graceful Degradation**: Fallback to simplified operations when complex features fail
- **Targeted Restart**: Resume from specific stages instead of full pipeline
- **Human Escalation**: Request user intervention for unresolvable issues

### 4.3 Fault Tolerance Design

**Multi-Layer Protection**:
1. **Tool-Level Safety**: Path validation, command blocking, input sanitization
2. **Agent-Level Resilience**: Max iteration limits, timeout handling, state checkpointing  
3. **Pipeline-Level Robustness**: Stage isolation, error containment, resume capability
4. **System-Level Monitoring**: Progress tracking, resource usage, performance metrics

## 5. Key Process Implementation

### 5.1 Agent Instruction Processing Pipeline

```mermaid
flowchart TD
    A[Load Agent Instruction] --> B[Initialize LLM Client]
    B --> C[Configure Tools]
    C --> D[Create Agent Session]
    D --> E[Execute Agent Loop]
    
    subgraph "Agent Execution Loop"
        E --> F[Generate LLM Prompt]
        F --> G[Call LLM API]
        G --> H[Parse Structured Response]
        H --> I{Tool Call Required?}
        I -->|Yes| J[Execute Tool]
        J --> K[Process Tool Result]
        K --> F
        I -->|No| L[Generate Final Output]
    end
    
    L --> M[Validate Output Structure]
    M --> N[Save to Artifact Store]
    N --> O[Agent Complete]
```

**Key Implementation Details**:
- **Structured Output Parsing**: LLM responses parsed against predefined schemas
- **Tool Chaining**: Sequential tool execution with context preservation
- **Iteration Control**: Max iteration limits prevent infinite loops
- **State Management**: Session persistence across tool invocations

### 5.2 File-Based Artifact Management

```mermaid
graph TB
    subgraph "Storage Layer"
        STORE[ArtifactStore]
        FILE[FileArtifactStore]
        SERDE[Serialization/Deserialization]
    end
    
    subgraph "Data Models"
        ENV[ArtifactEnvelope]
        META[Metadata]
        SPEC[Domain-Specific Data]
    end
    
    subgraph "File System"
        JSON[JSON Files]
        MD[Markdown Files]
        DIR[Directory Structure]
    end
    
    STORE --> FILE
    FILE --> SERDE
    SERDE --> ENV
    ENV --> META
    ENV --> SPEC
    FILE --> JSON
    FILE --> MD
    FILE --> DIR
```

**Artifact Persistence Strategy**:
- **Dual Format Storage**: JSON for machine processing, Markdown for human readability
- **Versioned Artifacts**: Each stage produces complete artifact set
- **Metadata Enrichment**: Timestamps, session context, dependency information
- **Directory Organization**: Logical separation by artifact type and stage

### 5.3 Human-in-the-Loop Integration

```mermaid
sequenceDiagram
    participant A as Agent
    participant H as HITL Tool
    participant E as External Editor
    participant U as User
    
    A->>H: review_and_edit_file(file_path, content)
    H->>H: generate_preview(content)
    H->>U: display preview with options
    U->>H: select action (edit/approve/feedback)
    
    alt Edit Selected
        H->>E: launch_editor(temp_file)
        E->>U: user edits content
        U->>E: save and close
        E->>H: read_modified_content()
        H->>A: return edited_content
    else Approve Selected
        H->>A: return original_content
    else Feedback Selected
        H->>U: prompt for feedback
        U->>H: provide_feedback_text
        H->>A: return feedback_data
    end
    
    A->>A: incorporate_changes()
```

**HITL Workflow Features**:
- **Non-Blocking Design**: Async user interaction without blocking agent execution
- **Content Preview**: First 10-15 lines displayed for quick assessment
- **Multiple Interaction Modes**: Edit, approve, or provide feedback
- **External Editor Integration**: Uses system default editor for complex edits
- **Structured Response Handling**: Clear action outcomes for agent processing

### 5.4 Performance Optimization Processes

**Concurrent Processing Strategy**:
- **Agent-Level Parallelism**: Independent agent execution with shared context
- **Tool Execution Optimization**: Async tool calls with timeout management
- **LLM Rate Limiting**: Configurable delays between API calls
- **File Operation Batching**: Batch file reads/writes where possible

**Resource Management**:
- **Memory Optimization**: Streaming LLM responses, incremental file processing
- **Disk Usage Control**: Automatic cleanup of temporary files
- **Network Efficiency**: Cached LLM responses, connection pooling
- **CPU Utilization**: Background processing of non-critical tasks

This comprehensive workflow documentation provides development teams with clear implementation guidance, operations teams with monitoring and troubleshooting support, and ensures all stakeholders understand the business value and technical execution of each process step in the Cowork Forge system.