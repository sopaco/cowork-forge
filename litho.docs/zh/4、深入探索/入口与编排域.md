# Cowork Forge 入口与编排域技术文档

## 1. 模块概述

入口与编排域是 Cowork Forge 系统的核心控制中枢，负责系统的启动、流程编排与会话管理。该域作为用户与系统交互的唯一入口，将复杂的多智能体协作流程封装为可复用的流水线，实现软件开发流程的自动化与标准化。

## 2. 架构设计

### 2.1 模块组成

入口与编排域包含两个核心子模块：

#### 2.1.1 CLI 入口模块 (`crates/cowork-cli/src/main.rs`)
- **职责**：命令行参数解析与会话初始化
- **关键功能**：
  - `main`：系统主入口点
  - `create_project`：新建项目处理
  - `modify_project`：项目修改处理
  - `resume_project`：项目恢复处理

#### 2.1.2 流水线编排模块 (`crates/cowork-core/src/pipeline/mod.rs`)
- **职责**：定义并执行不同阶段组合的开发流程
- **关键功能**：
  - `create_cowork_pipeline`：创建完整项目流水线
  - `create_resume_pipeline`：创建恢复流水线
  - `create_partial_pipeline`：创建部分阶段流水线
  - `create_modify_pipeline`：创建修改流水线

### 2.2 技术架构

```rust
// 核心架构依赖
use clap::{Parser, Subcommand};          // 命令行解析
use adk_runner::{Runner, RunnerConfig};  // 智能体运行器
use adk_session::InMemorySessionService; // 会话管理
use tokio;                              // 异步运行时
```

## 3. 核心功能实现

### 3.1 命令行接口设计

系统支持五种操作模式：

```rust[derive(Subcommand)]
enum Commands {
    /// 新建项目 - 完整开发流程
    New { idea: String },
    
    /// 恢复项目 - 从断点继续
    Resume { base: Option<String> },
    
    /// 回滚项目 - 从指定阶段重启
    Revert { from: String },
    
    /// 增量修改 - 基于变更请求的修改
    Modify { idea: String, base: Option<String> },
    
    /// 状态查询 - 项目状态检查
    Status { sessions: bool },
}
```

### 3.2 流水线编排引擎

#### 3.2.1 完整项目流水线
```rust
pub fn create_cowork_pipeline(config: &ModelConfig, session_id: &str) -> Result<Arc<dyn Agent>> {
    // 七阶段智能体流水线
    let pipeline = SequentialAgent::new(
        "cowork_forge_pipeline",
        vec![
            idea_agent,      // 需求捕获
            prd_loop,        // 需求文档生成
            design_loop,     // 架构设计
            plan_loop,       // 实施计划
            coding_loop,     // 代码实现
            check_agent,     // 质量检查
            delivery_agent,  // 交付报告
        ],
    );
    Ok(Arc::new(pipeline))
}
```

#### 3.2.2 智能恢复机制
```rust
pub fn create_resume_pipeline(config: &ModelConfig, session_id: &str, base_session_id: &str) -> Result<Arc<dyn Agent>> {
    // 基于现有数据文件自动判断恢复点
    let start_stage = if has_code_files(base_session_id)? {
        "check"    // 代码存在 → 从检查阶段恢复
    } else if has_implementation_plan(base_session_id)? && has_design_spec(base_session_id)? && has_requirements(base_session_id)? {
        "coding"   // 计划、设计、需求存在 → 从编码阶段恢复
    } else if has_design_spec(base_session_id)? && has_requirements(base_session_id)? {
        "plan"     // 设计、需求存在 → 从计划阶段恢复
    } else if has_requirements(base_session_id)? {
        "design"   // 需求存在 → 从设计阶段恢复
    } else {
        "prd"      // 无数据 → 从需求阶段开始
    };
    
    create_partial_pipeline(config, session_id, base_session_id, start_stage)
}
```

#### 3.2.3 部分流水线构建
```rust
pub fn create_partial_pipeline(config: &ModelConfig, session_id: &str, base_session_id: &str, start_stage: &str) -> Result<Arc<dyn Agent>> {
    match start_stage {
        "prd" => vec![prd_loop, design_loop, plan_loop, coding_loop, check_agent, delivery_agent],
        "design" => vec![design_loop, plan_loop, coding_loop, check_agent, delivery_agent],
        "plan" => vec![plan_loop, coding_loop, check_agent, delivery_agent],
        "coding" => vec![coding_loop, check_agent, delivery_agent],
        "check" => vec![check_agent, delivery_agent],
        "delivery" => vec![delivery_agent],
        _ => bail!("未知阶段")
    }
}
```

#### 3.2.4 增量修改流水线
```rust
pub fn create_modify_pipeline(config: &ModelConfig, session_id: &str, base_session_id: &str) -> Result<Arc<dyn Agent>> {
    // 四阶段修改流程
    let agents = vec![
        create_change_triage_agent(llm.clone(), session_id, base_session_id)?,  // 变更分析
        create_code_patch_agent(llm.clone(), session_id, base_session_id)?,     // 代码修补
        create_check_agent(llm.clone(), session_id)?,                          // 质量验证
        create_modify_delivery_agent(llm, session_id, base_session_id)?,       // 变更报告
    ];
    Ok(Arc::new(SequentialAgent::new(format!("modify_pipeline_{}", session_id), agents)))
}
```

## 4. 关键业务流程

### 4.1 全新项目创建流程
```
用户CLI命令 → 会话初始化 → Idea智能体 → PRD循环 → 设计循环 → 计划循环 → 编码循环 → 检查智能体 → 交付智能体
```

### 4.2 增量修改流程
```
变更请求 → 变更分析智能体 → 代码修补智能体 → 质量检查 → 变更交付报告
```

### 4.3 阶段恢复流程
```
恢复命令 → 会话状态加载 → 智能恢复点判断 → 部分流水线构建 → 目标阶段执行
```

## 5. 技术特性

### 5.1 会话管理
- **会话隔离**：每个项目会话独立存储，支持并行开发
- **状态持久化**：通过 `.cowork/sessions/<id>/` 目录管理会话数据
- **断点续传**：支持从任意阶段恢复执行

### 5.2 错误恢复
- **智能重试**：通过 HITL 机制处理智能体执行异常
- **状态回滚**：支持回退到历史有效状态
- **容错设计**：每个阶段独立执行，失败不影响其他阶段

### 5.3 性能优化
- **异步执行**：基于 tokio 异步运行时，支持并发处理
- **内存优化**：使用 Arc 智能指针管理智能体实例
- **资源复用**：LLM 客户端实例复用，减少连接开销

## 6. 接口规范

### 6.1 命令行参数
```bash
# 新建项目
cowork new "项目描述"

# 恢复项目
cowork resume --base <session_id>

# 增量修改
cowork modify "变更描述" --base <session_id>

# 状态查询
cowork status --sessions
```

### 6.2 配置管理
- **配置文件**：默认 `config.toml`，支持自定义路径
- **环境变量**：支持通过环境变量覆盖配置
- **日志配置**：支持详细日志和流式输出模式

## 7. 扩展性设计

### 7.1 流水线扩展
通过修改 `create_*_pipeline` 函数，可以轻松添加新的智能体阶段或调整执行顺序。

### 7.2 工具集成
新的工具可以通过实现 `Tool` trait 并注册到智能体构建器中集成。

### 7.3 配置扩展
支持自定义 LLM 配置、会话存储路径、超时设置等参数。

## 8. 总结

入口与编排域作为 Cowork Forge 系统的控制中枢，通过精心的架构设计实现了复杂开发流程的自动化管理。其模块化的流水线设计、智能的恢复机制和灵活的扩展能力，为系统的稳定运行和未来演进提供了坚实基础。该域的成功实现是系统能够高效完成从需求构思到代码交付完整流程的关键保障。