# 智能体指令域技术文档

## 1. 模块概述

智能体指令域是 Cowork Forge 系统的核心业务域，负责定义所有 AI 智能体的行为逻辑与决策规则。该域采用模块化架构，包含 10 个独立的指令模块，每个模块为特定开发阶段的智能体提供详细的提示词（prompt）模板。指令域基于 Actor-Critic 模式结合 Human-in-the-Loop（HITL）机制，确保 AI 智能体能够正确理解任务、执行工作并进行自我校验。

## 2. 架构设计

### 2.1 模块结构
```
crates/cowork-core/src/instructions/
├── mod.rs              # 指令聚合模块
├── idea.rs             # Idea 智能体指令
├── prd.rs              # PRD 智能体指令  
├── design.rs           # 设计智能体指令
├── plan.rs             # 计划智能体指令
├── coding.rs           # 编码智能体指令
├── check.rs            # 检查智能体指令
├── delivery.rs         # 交付智能体指令
├── modify.rs           # 修改分流智能体指令
├── code_patch.rs       # 代码修补智能体指令
└── modify_delivery.rs  # 修改交付智能体指令
```

### 2.2 核心设计原则
1. **简洁性优先**：所有智能体指令强调最小可行架构，避免过度设计
2. **分阶段执行**：严格遵循 Idea → PRD → Design → Plan → Coding → Check → Delivery 流程
3. **人机协作**：关键决策点引入 HITL 机制，确保用户控制权
4. **状态驱动**：每个阶段输出明确的状态标记，支持流程恢复

## 3. 智能体指令详解

### 3.1 Idea Agent（想法捕获智能体）
**文件位置**：`crates/cowork-core/src/instructions/idea.rs`

**核心职责**：
- 捕获并结构化用户的初始项目想法
- 生成标准化的 `idea.md` 文档
- 提供用户审查和编辑机会

**工作流程**：
1. 理解用户的项目想法输入
2. 保存结构化摘要到会话范围的 `idea.md`
3. 调用 `review_and_edit_content` 让用户审查
4. 确认后传递给 PRD 阶段

**输出格式标准化**：
```markdown
# Project Idea
## Problem Statement
## Target Users  
## Key Goals
## Initial Thoughts
## Technical Considerations
## Next Steps
```

### 3.2 PRD Agent（产品需求文档智能体）
**文件位置**：`crates/cowork-core/src/instructions/prd.rs`

**核心原则**：**简洁性与核心功能专注**
- ✅ 仅关注核心业务需求（3-6个）
- ✅ 最小可行特性（2-4个）
- ❌ 禁止性能优化、测试、部署等非核心需求

**严格工作流程**：
1. **加载想法**：调用 `load_idea()` 获取项目范围
2. **创建需求草稿**：生成 3-6 个核心需求和 2-4 个核心特性
3. **用户审查（HITL）**：必须调用 `review_with_feedback_content`
4. **创建正式需求**：为每个需求调用 `create_requirement`
5. **保存PRD文档**：调用 `save_prd_doc` 保存完整文档
6. **验证**：确认所有数据保存正确

### 3.3 Design Agent（架构设计智能体）
**文件位置**：`crates/cowork-core/src/instructions/design.rs`

**架构原则**：**最小化架构组件**
- ✅ 使用最简单的技术栈（内置/标准工具优先）
- ✅ 最小化组件数量（2-4个理想，最多6个）
- ✅ 优先采用单体架构
- ❌ 禁止微服务、复杂缓存层、消息队列等

**技术栈选择标准**：
- ✅ 良好示例："Node.js + Express + SQLite"
- ❌ 不良示例："Node.js + Express + Redis + RabbitMQ + Elasticsearch"

**工作流程**：
1. 加载需求并验证非空
2. 创建架构草稿（2-4个简单组件）
3. 用户审查（HITL）
4. 创建正式设计组件
5. 保存设计文档
6. 验证组件创建

### 3.4 Plan Agent（实施计划智能体）
**文件位置**：`crates/cowork-core/src/instructions/plan.rs`

**任务规划原则**：**仅关注核心功能实现**
- ✅ 实现业务逻辑和用户功能的任务
- ❌ 禁止单元测试、集成测试、性能优化任务
- ❌ 禁止部署/DevOps、监控/日志设置任务

**任务数量控制**：
- 简单项目：5-12个任务
- 每个任务应清晰专注

**工作流程**：
1. 加载设计组件并验证
2. 创建任务草稿（仅核心功能）
3. 用户审查（HITL）  
4. 创建正式任务
5. 验证任务创建

### 3.5 Coding Agent（编码智能体）
**文件位置**：`crates/cowork-core/src/instructions/coding.rs`

**编码原则**：**简单、清晰的代码实现**
- 简单代码：避免复杂模式，避免过度工程化
- 最小依赖：优先使用内置功能
- 无测试：除非任务明确要求
- 无优化：除非明确要求
- 清晰结构：易于理解和修改

**自适应任务管理能力**：
- **创建任务**：发现缺失依赖或需要拆分时
- **更新任务**：依赖关系或文件列表变化时  
- **删除任务**：任务不再需要或无法实现时

**工作流程**：
1. 获取所有待处理任务
2. 一次性实现所有任务
3. 标记所有任务为完成状态
4. 所有任务完成后立即停止

### 3.6 Check Agent（检查智能体）
**文件位置**：`crates/cowork-core/src/instructions/check.rs`

**检查原则**：**最小化验证，宽容处理**
- ✅ 基础验证：文件存在、数据格式有效
- ✅ 功能覆盖检查
- ✅ 任务依赖检查
- ❌ 不运行测试（除非项目明确有测试）
- ❌ 不检查代码质量细节

**决策路径**：
- **路径A**：结构合理 → 批准项目
- **路径B**：关键问题 → 调用 `goto_stage` 重启流程

### 3.7 Delivery Agent（交付智能体）
**文件位置**：`crates/cowork-core/src/instructions/delivery.rs`

**关键规则**：**仅在项目真正完成时生成报告**

**预检查流程（必须先执行）**：
1. 检查任务状态
2. **关键**：使用 `list_files(".")` 验证实际代码文件存在
3. 如果无代码文件存在：不生成交付报告，直接停止

**完整工作流程**：
1. 加载项目数据（需求、设计、计划、反馈历史）
2. 生成完整的Markdown交付报告
3. 保存交付报告
4. 流程自动完成

### 3.8 修改相关智能体

#### Modify Triage Agent（修改分流智能体）
**职责**：分析用户变更请求，确定修改范围

**分析维度**：
- 是否需要更新PRD（新需求）
- 是否需要更新设计（新组件/架构变更）  
- 是否需要更新计划（新任务）
- 是否仅为代码修改

**风险评估**：基于影响文件数量、核心功能影响等

#### Code Patch Agent（代码修补智能体）
**职责**：实施增量代码修改

#### Modify Delivery Agent（修改交付智能体）  
**职责**：生成变更报告，整合变更前后状态

## 4. 技术实现特性

### 4.1 指令模板结构
每个指令文件包含：
- **角色定义**：智能体的具体职责和边界
- **核心原则**：强调简洁性和最小化设计
- **工作流程**：分步骤的执行指南
- **工具规范**：明确可用的工具函数
- **输出标准**：格式化的文档模板

### 4.2 HITL机制集成
所有关键智能体（PRD、Design、Plan）都集成HITL：
- 必须调用 `review_with_feedback_content`
- 支持编辑、通过、反馈三种响应处理
- 限制最大重审次数（通常1次）
- 反馈记录持久化供后续参考

### 4.3 状态管理和验证
- 每个阶段完成后必须验证数据保存
- 支持阶段间的状态传递
- 提供工具函数验证创建的数据完整性

## 5. 模块间协作

### 5.1 与智能体执行域的协作
- 指令域提供静态的prompt模板
- 执行域负责动态的智能体实例化和执行
- 通过常量导出机制实现松耦合

### 5.2 与工具执行域的集成
- 指令中明确定义可用的工具函数
- 工具调用规范确保操作的安全性
- 支持文件操作、数据管理、用户交互等

### 5.3 与持久化存储域的数据流
- 指令执行产生的数据通过工具保存到存储域
- 支持会话状态的持久化和恢复
- 确保流程的可追溯性和可恢复性

## 6. 设计优势

### 6.1 模块化优势
- **可扩展性**：新增智能体只需添加新的指令文件
- **可维护性**：每个智能体职责单一，修改影响局部化
- **可测试性**：指令模板可独立验证和优化

### 6.2 流程控制优势  
- **严格阶段控制**：确保开发流程的标准化
- **质量保证**：通过HITL机制引入人工审核
- **错误恢复**：支持阶段重启和流程恢复

### 6.3 用户体验优势
- **透明度**：每个阶段的工作内容和输出明确
- **可控性**：关键决策点保留用户干预权
- **一致性**：标准化输出格式便于理解和复用

## 7. 最佳实践

### 7.1 指令设计原则
1. **明确性**：指令应清晰无歧义
2. **完整性**：覆盖所有预期的执行路径
3. **安全性**：工具调用应有明确的权限控制
4. **可恢复性**：支持错误处理和流程恢复

### 7.2 流程优化建议
1. **渐进式细化**：从想法到代码的逐步细化过程
2. **反馈循环**：及时的HITL反馈确保方向正确
3. **状态持久化**：定期保存进度支持中断恢复

智能体指令域作为Cowork Forge系统的"大脑"，通过精心设计的指令模板指导AI智能体完成从需求分析到代码交付的完整开发流程，是实现自动化软件开发的核心技术组件。