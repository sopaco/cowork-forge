# 智能体编排与流程控制层技术文档

## 概述

智能体编排与流程控制层是 Cowork Forge V2 系统的核心引擎，负责协调多个 AI 智能体按预设流程执行开发任务，实现从用户原始构想到可交付软件产品的全流程自动化。该模块通过**顺序编排**与**智能断点恢复**两大核心机制，构建了一个高度可恢复、可扩展的自动化开发流水线，是系统价值实现的关键所在。

本模块采用 Rust 语言基于 `adk_agent` 和 `adk_core` 框架实现，其设计哲学是“**状态即文件**”与“**人机协同**”。它不依赖外部数据库，而是通过读写 `.cowork/` 目录下的结构化文件（如 `requirements.json`, `design.json`）来感知和管理开发状态，从而实现流程的无缝恢复。同时，它深度集成了人类在环（HITL）交互，确保 AI 生成的内容始终符合业务意图。

## 核心架构与模块组成

智能体编排与流程控制层由四个紧密协作的子模块构成，共同实现其核心功能。

### 1. 流水线编排模块 (`pipeline/mod.rs`)

该模块是整个流程的“指挥中心”，负责定义和构建完整的开发流水线。其核心是两个关键函数：`create_cowork_pipeline` 和 `create_resume_pipeline`，它们共同构成了系统“完整执行”与“智能恢复”的双模式。

- **`create_cowork_pipeline`**: 构建完整的七阶段顺序流水线。该函数接收 `ModelConfig` 配置，创建一个由 `SequentialAgent` 组装的完整工作流，依次包含：
  1.  `IdeaAgent`: 捕获用户初始想法。
  2.  `PRD Loop`: 生成结构化产品需求文档。
  3.  `Design Loop`: 生成系统架构设计方案。
  4.  `Plan Loop`: 将设计分解为可执行任务。
  5.  `Coding Loop`: 编写代码并持久化。
  6.  `Check Agent`: 质量校验。
  7.  `Delivery Agent`: 生成最终交付报告。

  该函数通过 `SequentialAgent::new` 将所有智能体按顺序串联，形成一个线性执行链。其设计遵循“**一个阶段完成，下一个阶段自动启动**”的原则，确保流程的连贯性。

- **`create_resume_pipeline`**: 实现智能断点恢复。这是本模块最具创新性的功能。该函数通过检查 `.cowork/data/` 和 `.cowork/artifacts/` 目录下的特定文件是否存在，自动判断当前开发状态，并决定从哪个阶段恢复：
  - 若 `delivery_report.md` 存在，则报错，项目已完整。
  - 若 `plan.json`, `design.json`, `requirements.json` 均存在，则从 `Coding` 阶段开始。
  - 若 `design.json`, `requirements.json` 存在，则从 `Plan` 阶段开始。
  - 若 `requirements.json` 存在，则从 `Design` 阶段开始。
  - 否则，从 `PRD` 阶段开始。

  该函数的核心价值在于**无需用户手动干预**，系统能自动感知上下文并做出最优决策，极大地提升了用户体验和流程的容错性。

- **`create_partial_pipeline`**: 为 `create_resume_pipeline` 提供底层支持。它根据传入的 `start_stage` 参数（如 `"coding"`, `"design"`），动态构建一个从指定阶段开始的、不包含前置阶段的精简流水线。这使得系统能够灵活地支持“**跳转到任意阶段**”的高级用例，例如用户在 `Coding` 阶段发现需求有误，可以主动要求系统从 `PRD` 阶段重新开始。

### 2. 智能体工厂模块 (`agents/mod.rs`)

该模块是流水线的“零件供应商”，负责根据预设模板创建具有特定能力的智能体实例。它通过 `LlmAgentBuilder` 和 `LoopAgent` 两种核心工具，构建了两类智能体。

- **`LlmAgent`**: 用于单次执行的智能体，如 `IdeaAgent`, `CheckAgent`, `DeliveryAgent`。它们的职责是执行一次性的、非迭代的任务。例如，`IdeaAgent` 接收用户想法后，生成 `idea.md` 文件并结束。

- **`LoopAgent`**: 用于实现 Actor-Critic 迭代循环的智能体，是本模块的核心设计。`PRD`, `Design`, `Plan`, `Coding` 四个关键阶段均采用此模式。每个 `LoopAgent` 包含两个子智能体：
  - **Actor**: 负责生成内容（如生成 PRD 草稿、设计草图、任务列表、代码）。
  - **Critic**: 负责评估 Actor 的输出，提供反馈。

  **关键设计突破**：为了解决 `adk-rust` 框架中 `exit_loop()` 工具会导致整个 `SequentialAgent` 终止的严重 Bug，本模块采用了“**以迭代次数替代退出**”的巧妙方案。通过调用 `.with_max_iterations(1)` 或 `.with_max_iterations(5)`，让 `LoopAgent` 在完成一次完整的 Actor-Critic 循环后自然结束，而非主动退出。这保证了 `SequentialAgent` 能够顺利进入下一个阶段，实现了流程的稳定串联。

  例如，`create_coding_loop` 函数创建的 `Coding Loop` 会进行最多 5 次迭代，让 Actor 有足够机会编写代码，Critic 有足够机会审查并反馈，直到代码质量达标。

### 3. 指令集模块 (`instructions/*.rs`)

该模块是智能体的“大脑”和“行为规范”，集中管理所有智能体的提示词模板（Prompt Templates）。每个智能体（Actor 或 Critic）都有一个独立的 `.rs` 文件，其中定义了其 `*_ACTOR_INSTRUCTION` 和 `*_CRITIC_INSTRUCTION` 常量。

这些指令模板是高度结构化和场景化的，它们不仅定义了智能体的角色，更详细规定了其**工作流程**和**工具调用规范**，是实现高质量输出的关键。

- **`PRD_ACTOR_INSTRUCTION`**: 指令明确要求 Actor 必须先生成 `prd_draft.md` 草稿，然后调用 `review_with_feedback` 工具邀请用户审核。它详细描述了如何处理用户的三种反馈（编辑、通过、反馈），并规定了最多进行两次迭代以避免无限循环。这确保了需求文档的生成是**人机协同**的，而非 AI 自说自话。

- **`PRD_CRITIC_INSTRUCTION`**: 与 Actor 的复杂流程形成鲜明对比，Critic 的指令极其简洁。它明确指示：“**不要读文件**，直接调用 `get_requirements()` 获取所有数据”。这体现了“**Critic 只做评估，不做创作**”的设计哲学，避免了重复劳动和潜在的文件读取错误。

- **`CODING_ACTOR_INSTRUCTION`**: 强调“**简单至上**”原则，要求 Actor 一次性实现所有任务，并立即标记为完成，禁止过度工程化。这确保了生成的代码是轻量、可维护的。

- **`CODING_CRITIC_INSTRUCTION`**: 核心任务是检查“**所有任务是否完成**”和“**代码文件是否真实存在**”。它不关心代码的复杂度，只关心交付物的完整性。这种“**结果导向**”的评估方式，使系统能够高效地判断开发是否真正结束。

### 4. 阶段控制工具模块 (`tools/goto_stage_tool.rs`)

该模块为系统提供了**主动干预**的能力，是“人机协同”理念的直接体现。`GotoStageTool` 是一个由 `Check Agent` 或用户通过 CLI 调用的工具。

- **功能**：允许用户指定一个目标阶段（`prd`, `design`, `plan`, `coding`），并提供一个原因（`reason`）。
- **实现**：工具会解析参数，将目标阶段和原因写入 `.cowork/data/session_meta.json` 文件中的 `current_stage` 和 `restart_reason` 字段。
- **效果**：当用户再次执行 `resume` 命令时，`create_resume_pipeline` 会读取此元数据，强制从指定阶段开始，从而实现**流程的中断与恢复**。

该工具的存在，使得系统不再是“单向的自动化流水线”，而是一个**可被人类专家引导和修正的协作系统**，极大地提升了系统的灵活性和可靠性。

## 核心交互模式与数据流

整个智能体编排与流程控制层的运作，依赖于与**功能工具与数据操作层**以及**持久化存储与数据模型层**的紧密协作。

1.  **启动流程**：用户执行 `cowork-cli new` → CLI 调用 `create_cowork_pipeline` → `IdeaAgent` 调用 `WriteFileTool` → `storage` 模块将 `idea.md` 保存至 `.cowork/artifacts/`。
2.  **智能体协作**：`PRD Actor` 调用 `WriteFileTool` 创建 `prd_draft.md` → 调用 `ReviewWithFeedbackTool` → 用户在终端编辑并保存 → `PRD Critic` 调用 `GetRequirementsTool` 获取 `requirements.json` 中的数据进行评估 → 评估通过后，`PRD Actor` 调用 `CreateRequirementTool` 将需求写入 `requirements.json`。
3.  **阶段恢复**：用户执行 `resume` → `create_resume_pipeline` 检测到 `.cowork/data/requirements.json` 存在 → 调用 `create_partial_pipeline("prd")` → 流水线从 `PRD` 阶段开始，跳过 `Idea` 阶段。
4.  **质量校验**：`Check Agent` 调用 `CheckFeatureCoverageTool` → 该工具查询 `feature_list.json` 和 `implementation_plan.json` → 发现某个功能未被任何任务覆盖 → 调用 `ProvideFeedbackTool` 将反馈写入 `feedback_history.json` → `Coding Agent` 在下一次迭代中读取此反馈并补充任务。

## 设计优势与工程哲学

1.  **高内聚低耦合**：各子模块职责清晰，通过明确的接口（如 `Agent` trait, `Tool` trait）通信，易于独立测试和替换。
2.  **状态即文件**：摒弃数据库，完全依赖本地文件系统作为唯一状态存储，极大简化了部署、运维和数据备份，提升了系统的可靠性和可移植性。
3.  **人机协同深度集成**：HITL 机制不是事后补充，而是流程设计的核心。每个关键阶段都强制要求用户审核，确保 AI 输出符合业务意图。
4.  **卓越的可恢复性**：通过 `create_resume_pipeline` 和 `GotoStageTool`，系统实现了任意阶段的智能恢复，是应对复杂开发场景的“安全网”。
5.  **轻量可移植**：纯 Rust 编写，无外部依赖，可轻松在 Linux/macOS/Windows 上编译运行，符合“开箱即用”的工程哲学。

综上所述，智能体编排与流程控制层通过精巧的架构设计，将复杂的软件工程流程转化为一个稳定、可恢复、可协同的智能体协作网络，为 AI 原生开发工具提供了极具参考价值的范式。