# 持久化存储与数据模型层技术文档

## 概述

持久化存储与数据模型层是 Cowork Forge V2 系统的核心业务域之一，承担着系统状态管理与数据一致性的基石作用。该模块通过严谨的 Rust 类型系统与 Serde 序列化机制，构建了一套完整、可追溯、可恢复的本地化数据持久化体系，完全摒弃了外部数据库依赖，实现了“状态即文件”的轻量级工程哲学。

本模块由两个核心子模块构成：**数据模型模块**（`data/models.rs`）定义了系统所有领域对象的结构契约，**存储管理模块**（`storage/mod.rs`）实现了 `.cowork/` 目录的物理组织与文件读写逻辑。二者协同工作，确保从用户意图到代码交付的全过程数据在各个阶段保持结构化、可验证和可恢复。

## 数据模型模块详解

数据模型模块是系统数据交换的唯一契约，所有智能体、工具和流程控制模块均通过该模块定义的结构体进行数据交互。所有模型均遵循领域驱动设计（DDD）原则，清晰区分实体（Entity）与值对象（Value Object），并采用 Rust 的强类型系统严格约束数据状态，避免非法状态的产生。

### 核心数据结构

#### 1. 需求模型（Requirements）
需求是开发流程的起点，由 `Requirements` 结构体承载，包含多个 `Requirement` 实体。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Requirements {
    pub schema_version: String, // 版本号，用于向后兼容
    pub created_at: DateTime<Utc>, // 创建时间戳
    pub updated_at: DateTime<Utc>, // 最后更新时间戳
    pub requirements: Vec<Requirement>, // 需求列表
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Requirement {
    pub id: String, // 唯一标识，如 REQ-001
    pub title: String, // 需求标题
    pub description: String, // 详细描述
    pub priority: Priority, // 优先级（值对象）
    pub category: RequirementCategory, // 类别（值对象）
    pub acceptance_criteria: Vec<String>, // 接受标准
    pub related_features: Vec<String>, // 关联的功能ID
}
```

- **值对象**：`Priority` 和 `RequirementCategory` 使用 `#[derive(Copy, Serialize, Deserialize, PartialEq, Eq)]` 定义，确保其不可变性与可比较性。
- **版本控制**：`schema_version` 字段为 `1.0`，支持未来数据结构演进。
- **时间戳**：使用 `chrono::Utc` 自动记录创建与更新时间，确保审计追踪。

#### 2. 功能模型（FeatureList）
功能模型将需求分解为可交付的业务功能，是设计与任务规划的输入。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureList {
    pub schema_version: String,
    pub features: Vec<Feature>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feature {
    pub id: String, // FEAT-001
    pub name: String,
    pub description: String,
    pub requirement_ids: Vec<String>, // 关联的需求ID
    pub status: FeatureStatus, // 状态机（值对象）
    pub assigned_to_tasks: Vec<String>, // 分配的任务ID
    pub completion_criteria: Vec<String>, // 完成标准
    pub created_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>, // 可选完成时间
    #[serde(default)]
    pub metadata: FeatureMetadata, // 扩展元数据
}
```

- **状态机**：`FeatureStatus` 枚举（`Pending`, `InProgress`, `Completed`, `Blocked`）严格限制状态流转，防止非法状态。
- **可选字段**：`completed_at` 使用 `Option<DateTime<Utc>>` 表示未完成状态，避免空值歧义。
- **元数据**：`FeatureMetadata` 结构体允许扩展，如 `estimated_effort`（预估工作量）和 `dependencies`（依赖功能），通过 `#[serde(default)]` 和 `#[serde(skip_serializing_if = "Option::is_none")]` 实现条件序列化，减少冗余。

#### 3. 设计模型（DesignSpec）
设计模型描述系统架构，是任务规划的直接依据。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DesignSpec {
    pub schema_version: String,
    pub architecture: Architecture,
    pub technology_stack: TechnologyStack,
    pub deployment: DeploymentInfo,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Architecture {
    pub style: String, // "microservices", "monolith"
    pub components: Vec<DesignComponent>,
    pub data_models: Vec<DataModel>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DesignComponent {
    pub id: String, // COMP-001
    pub name: String,
    #[serde(rename = "type")] // 序列化为 "type" 字段
    pub component_type: ComponentType, // 枚举类型
    pub responsibilities: Vec<String>, // 职责清单
    pub technology: String, // 技术栈
    pub interfaces: Vec<ComponentInterface>, // 接口定义
    pub related_features: Vec<String>, // 关联功能
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")] // 序列化为小写蛇形命名
pub enum ComponentType {
    BackendService,
    FrontendComponent,
    Database,
    ApiGateway,
    MessageQueue,
    Other(String), // 用于扩展
}
```

- **嵌套结构**：设计模型支持复杂的嵌套关系，如组件（`DesignComponent`）关联多个接口（`ComponentInterface`）和数据模型（`DataModel`）。
- **枚举扩展**：`ComponentType` 的 `Other(String)` 变体支持未来新增组件类型，保持开放性。
- **字段重命名**：使用 `#[serde(rename = "type")]` 确保序列化后的 JSON 字段名符合通用规范。

#### 4. 任务模型（ImplementationPlan）
任务模型将设计分解为可执行的开发任务，是编码阶段的直接输入。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImplementationPlan {
    pub schema_version: String,
    pub milestones: Vec<Milestone>,
    pub tasks: Vec<Task>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    pub id: String, // TASK-001
    pub title: String,
    pub description: String,
    pub feature_id: String, // 关联功能
    pub component_id: String, // 关联组件
    pub status: TaskStatus, // 状态机
    pub dependencies: Vec<String>, // 任务依赖ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub estimated_effort: Option<String>, // 预估工作量
    pub files_to_create: Vec<String>, // 将创建的文件路径
    pub acceptance_criteria: Vec<String>, // 验收标准
    pub created_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum TaskStatus {
    Pending,
    InProgress,
    Completed,
    Blocked,
}
```

- **依赖管理**：`dependencies` 字段形成任务间的有向图，为后续的依赖校验工具（`CheckTaskDependenciesTool`）提供数据基础。
- **文件映射**：`files_to_create` 字段直接关联代码生成结果，实现任务与文件的双向追溯。

#### 5. 代码元数据（CodeMetadata）
该模型记录代码生成后的质量指标，是质量校验阶段的核心输入。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeMetadata {
    pub schema_version: String,
    pub files: Vec<FileMetadata>,
    pub build_status: BuildStatus,
    pub test_status: TestStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileMetadata {
    pub path: String, // 文件路径
    pub task_id: String, // 关联任务
    #[serde(skip_serializing_if = "Option::is_none")]
    pub feature_id: Option<String>, // 关联功能
    #[serde(skip_serializing_if = "Option::is_none")]
    pub component_id: Option<String>, // 关联组件
    pub created_at: DateTime<Utc>,
    pub last_modified: DateTime<Utc>,
    pub lines_of_code: usize, // 代码行数
    pub test_coverage: f32, // 测试覆盖率
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuildStatus {
    pub last_build: DateTime<Utc>,
    pub success: bool,
    pub errors: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestStatus {
    pub last_run: DateTime<Utc>,
    pub total: usize,
    pub passed: usize,
    pub failed: usize,
    pub details: Vec<TestDetail>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestDetail {
    pub test_name: String,
    pub status: String, // "passed" or "failed"
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
```

- **质量量化**：`lines_of_code` 和 `test_coverage` 为自动化质量评估提供客观数据。
- **结构化错误**：`errors` 和 `details` 字段以结构化方式记录构建与测试失败信息，便于智能体分析。

#### 6. 会话与反馈模型（SessionMeta & FeedbackHistory）
会话模型记录流程状态，反馈模型记录人类在环（HITL）的干预。

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionMeta {
    pub session_id: String,
    pub created_at: DateTime<Utc>,
    pub current_stage: Option<Stage>, // 当前阶段
    #[serde(skip_serializing_if = "Option::is_none")]
    pub restart_reason: Option<String>, // 恢复原因
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum Stage {
    Idea,
    Prd,
    Design,
    Plan,
    Coding,
    Check,
    Delivery,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeedbackHistory {
    pub feedbacks: Vec<Feedback>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feedback {
    pub feedback_type: FeedbackType, // 反馈类型
    pub severity: Severity, // 严重程度
    pub details: String, // 反馈内容
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_fix: Option<String>, // 建议修复
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FeedbackType {
    BuildError,
    QualityIssue,
    MissingRequirement,
    Suggestion,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    Critical,
    Major,
    Minor,
}
```

- **状态恢复**：`SessionMeta` 的 `current_stage` 字段是 `goto_stage` 恢复流程的核心依据。
- **反馈结构化**：`FeedbackType` 和 `Severity` 枚举确保反馈信息可被工具自动解析与处理，而非自由文本。

### 模型设计原则

1. **类型安全**：所有状态均使用 `enum` 定义，杜绝非法值。
2. **版本兼容**：`schema_version` 字段为所有模型提供演进能力。
3. **时间追踪**：`created_at` 和 `updated_at` 为所有实体提供审计线索。
4. **条件序列化**：`#[serde(skip_serializing_if = "Option::is_none")]` 优化存储空间，避免 `null` 值冗余。
5. **默认构造**：每个模型均提供 `new()` 构造函数，确保初始化时数据一致性。
6. **领域隔离**：实体（如 `Requirement`）与值对象（如 `Priority`）分离，符合 DDD 原则。

## 存储管理模块详解

存储管理模块是数据模型的物理实现层，负责 `.cowork/` 目录的创建、维护与文件读写。它为上层模块提供统一、安全的文件操作接口，屏蔽了路径管理、目录创建和错误处理的复杂性。

### 目录结构

系统所有状态均存储于项目根目录下的 `.cowork/` 目录中，结构清晰：

```
.cowork/
├── data/                  # 结构化数据（JSON）
│   ├── requirements.json
│   ├── feature_list.json
│   ├── design_spec.json
│   ├── implementation_plan.json
│   └── code_metadata.json
├── artifacts/             # 人类可读产物（Markdown）
│   ├── idea.md
│   ├── prd.md
│   ├── design.md
│   └── delivery_report.md
├── session/               # 会话与反馈
│   ├── meta.json
│   └── feedback.json
└── logs/                  # 运行日志（未来扩展）
```

### 核心功能实现

#### 1. 目录初始化
`get_cowork_dir()` 函数确保 `.cowork/` 及其子目录在首次运行时自动创建，避免因目录缺失导致的程序崩溃。

```rust
pub fn get_cowork_dir() -> Result<PathBuf> {
    let path = PathBuf::from(COWORK_DIR);
    if !path.exists() {
        fs::create_dir_all(&path)?; // 创建 .cowork
        fs::create_dir_all(path.join("data"))?; // 创建 data
        fs::create_dir_all(path.join("artifacts"))?; // 创建 artifacts
        fs::create_dir_all(path.join("session"))?; // 创建 session
        fs::create_dir_all(path.join("logs"))?; // 创建 logs
    }
    Ok(path)
}
```

#### 2. 统一路径管理
通过 `data_path()`, `artifact_path()`, `session_path()` 等辅助函数，实现路径的集中管理，避免硬编码路径导致的维护困难。

```rust
fn data_path(filename: &str) -> Result<PathBuf> {
    Ok(get_cowork_dir()?.join("data").join(filename))
}
```

#### 3. 标准化读写接口
每个数据模型都有一组对应的 `load_*` 和 `save_*` 函数，实现“加载-保存”模式。

```rust
pub fn load_requirements() -> Result<Requirements> {
    let path = data_path("requirements.json")?;
    if !path.exists() {
        return Ok(Requirements::new()); // 不存在时返回默认实例
    }
    let content = fs::read_to_string(&path)?;
    let requirements: Requirements = serde_json::from_str(&content)?;
    Ok(requirements)
}

pub fn save_requirements(requirements: &Requirements) -> Result<()> {
    let path = data_path("requirements.json")?;
    
    // 确保父目录存在
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    
    let content = serde_json::to_string_pretty(requirements)?; // 格式化输出
    fs::write(&path, content)?;
    Ok(())
}
```

- **容错设计**：文件不存在时，返回模型的 `new()` 默认实例，而非报错，确保流程可恢复。
- **安全写入**：`fs::create_dir_all(parent)` 确保写入前父目录存在，避免 `Permission denied` 错误。
- **格式化输出**：使用 `serde_json::to_string_pretty` 生成人类可读的 JSON，便于调试与人工审查。

#### 4. 附加功能
- **`append_feedback()`**：提供追加反馈的原子操作，避免读写冲突。
- **`generate_id(prefix, counter)`**：生成唯一ID（如 `REQ-001`），确保跨会话的ID一致性。
- **`cowork_dir_exists()`**：提供快速检测函数，用于判断是否为恢复流程。

### 与数据模型的协作模式

存储模块与数据模型模块通过“契约-实现”模式紧密协作：

1. **数据模型**定义“**是什么**”（What）：结构体字段、枚举、类型约束。
2. **存储模块**实现“**怎么做**”（How）：文件路径、读写逻辑、错误处理。

例如，当 `CreateRequirementTool` 工具需要创建一个新需求时：
- 它调用 `Requirement::new()` 创建一个符合契约的实例。
- 它调用 `load_requirements()` 读取现有需求列表。
- 它将新需求追加到列表中。
- 它调用 `save_requirements(&updated_list)` 将更新后的数据持久化。

整个过程无需关心文件路径、JSON 格式或目录权限，所有复杂性被封装在存储模块中。

## 模块间交互与系统集成

### 1. 与智能体编排层的交互
- **启动流程**：`create_resume_pipeline()` 调用 `load_requirements()`、`load_design_spec()` 等函数检测 `.cowork/data/` 下的文件，判断恢复点。
- **阶段恢复**：`GotoStageTool` 调用 `save_session_meta()` 更新 `current_stage`，并调用 `save_feedback_history()` 记录恢复原因。
- **数据驱动**：智能体的提示词（Prompt）内容直接来源于 `load_requirements()`、`load_design_spec()` 返回的结构化数据。

### 2. 与功能工具层的交互
- **数据操作工具**（`data_tools.rs`）：`CreateRequirementTool`、`UpdateFeatureTool` 等工具直接操作 `Requirements`、`FeatureList` 等模型，并通过 `save_*` 函数持久化。
- **产物管理工具**（`artifact_tools.rs`）：`SavePRDTool`、`SaveDesignTool` 等工具调用 `save_prd_doc()`、`save_design_doc()` 将 Markdown 内容写入 `artifacts/` 目录。
- **验证工具**（`validation_tools.rs`）：`CheckFeatureCoverageTool` 通过 `load_feature_list()` 和 `load_implementation_plan()` 加载数据，验证功能与任务的覆盖关系。

### 3. 与人机协同（HITL）的交互
- **人工审核**：`ReviewWithFeedbackTool` 在用户提交反馈后，调用 `append_feedback()` 将反馈结构化存储。
- **反馈驱动迭代**：下一轮智能体（如 PRD Critic）通过 `load_feedback_history()` 读取历史反馈，作为优化输出的依据。

## 实践价值与优势

1. **完全本地化**：不依赖任何外部数据库，部署简单，数据安全，适合离线环境。
2. **状态可追溯**：所有变更均记录在 JSON 文件中，可通过版本控制（Git）管理开发历史。
3. **高可靠性**：Rust 的所有权系统与 `anyhow` 错误处理确保文件操作的健壮性。
4. **人机协同友好**：JSON 和 Markdown 文件可被人类直接编辑，实现“AI生成，人工修正”的无缝协作。
5. **可恢复性强**：通过 `SessionMeta` 和 `load_*` 函数，系统可在任意阶段恢复，支持灵活的开发路径调整。

## 总结

持久化存储与数据模型层是 Cowork Forge V2 的“记忆”与“契约”之所在。它通过严谨的 Rust 类型系统与 Serde 序列化机制，将复杂的软件开发流程转化为一组可验证、可恢复、可追溯的结构化数据。该模块不仅实现了数据的持久化，更构建了系统智能体协作的“语言”——所有智能体都基于同一套数据模型进行沟通，确保了自动化流程的准确性与一致性。它是实现“状态即文件”这一革命性工程哲学的核心基石，为 AI 原生开发工具提供了极具参考价值的范式。