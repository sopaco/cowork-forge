# 交互领域文档

## 概述

Cowork Forge中的交互领域作为核心AI驱动开发引擎与用户界面之间的关键抽象层，实现了CLI和GUI环境中无缝的人机循环(HITL)协作。该领域实现了策略模式，将业务逻辑与展示关注点解耦，确保相同的核心工作流无论用户通过终端还是图形界面交互都能保持一致运行。

其核心是通过`InteractiveBackend`特征为所有面向用户的操作（包括消息显示、输入收集、进度跟踪和响应提交）提供统一接口。这种设计确保管道执行器、AI智能体和工具实现可以与用户通信，而无需与任何特定UI技术耦合。该领域作为共享组件(`cowork-core`)实现，被CLI界面(`cowork-cli`)和GUI界面(`cowork-gui`)共同使用，在保证跨平台行为一致性的同时，允许每个界面利用平台特定功能。

该领域与EventBus基础设施紧密集成，实现引擎与UI组件之间的实时、事件驱动通信。这种集成使GUI能够呈现实时更新、进度指示器和HITL提示，而无需直接轮询或阻塞调用，创造出响应流畅的用户体验。

## 核心架构

### InteractiveBackend特征

`InteractiveBackend`特征定义了所有UI实现必须满足的契约，建立引擎业务逻辑与展示层之间的清晰分离。此特征由不同界面的具体后端实现，通过依赖注入实现多态行为。

```rust
#[async_trait]
pub trait InteractiveBackend: Send + Sync {
    async fn show_message(&self, level: MessageLevel, content: String);
    async fn request_input(&self, prompt: &str, options: Vec<InputOption>, initial_content: Option<String>) -> Result<InputResponse>;
    async fn show_progress(&self, task_id: String, progress: ProgressInfo);
    async fn submit_response(&self, request_id: String, response: String) -> Result<()>;
    fn event_bus(&self) -> Arc<EventBus>;
}
```

该特征暴露五个基本方法：

1. **`show_message`**：向用户显示带有语义级别（Info、Success、Warning、Error、Debug）和相应表情符号渲染的反馈。
2. **`request_input`**：处理多模态用户输入—文本输入、选项选择或外部编辑器调用—支持初始内容预填充。
3. **`show_progress`**：报告长时间运行操作的实时进度，包含百分比、当前/总计数器和描述性消息。
4. **`submit_response`**：允许从GUI后端异步提交HITL响应（例如模态对话框确认）。
5. **`event_bus`**：提供对共享事件总线的访问，用于订阅引擎事件。

所有方法都是`async`的，以适应非阻塞I/O操作，对于可能涉及网络调用或UI线程协调的GUI交互尤为重要。

### 数据模型

该领域定义了几种结构化数据类型以确保类型安全的通信：

- **`MessageLevel`**：枚举语义反馈级别，带有相关表情符号表示（`ℹ️`、`✅`、`⚠️`、`❌`、`🔍`）。
- **`InputOption`**：表示可选项，带有`id`、`label`和可选的`description`，用于丰富的CLI菜单。
- **`InputResponse`**：将用户响应封装为`Text(String)`、`Selection(String)`或`Cancel`，使引擎能够区分自由反馈和菜单选择。
- **`ProgressInfo`**：使用`current`、`total`和`message`字段跟踪任务进度，用于动态进度渲染。

这些类型启用了`Serialize`/`Deserialize`，便于在IPC边界上序列化和未来扩展到远程UI。

## 实现细节

### CLI后端（`CliBackend`）

CLI后端使用`dialoguer`包提供丰富的基于终端的交互体验，实现高级输入处理和UTF-8兼容I/O。

#### 关键功能：
- **表情符号增强输出**：消息使用语义表情符号呈现，提供视觉清晰度。
- **多模式输入**：支持选择菜单和文本输入，带有可选的编辑器调用。
- **编辑器集成**：当用户输入`edit`时，系统通过`dialoguer::Editor`启动外部编辑器（如VSCode），在会话间保持内容。
- **输入后备**：用户可以输入`pass`跳过输入或输入`cancel`中止操作。
- **实时进度**：进度条显示百分比、当前/总数值和描述性消息。

```rust
async fn request_input(&self, prompt: &str, options: Vec<InputOption>, initial_content: Option<String>) -> Result<InputResponse> {
    if options.is_empty() {
        // 带编辑器选项的文本输入
        let input = read_line(prompt)?;
        if input.to_lowercase() == "edit" {
            let edited = Editor::new().edit(initial_content.as_deref())?;
            return Ok(InputResponse::Text(edited.unwrap_or_default()));
        }
        Ok(InputResponse::Text(input))
    } else {
        // 带文本后备的菜单选择
        for (i, option) in options.iter().enumerate() {
            println!("  {}. {}", i + 1, option.label);
        }
        let input = read_line("您的选择:")?;
        if let Ok(num) = input.parse::<usize>() {
            if num > 0 && num <= options.len() {
                return Ok(InputResponse::Selection(options[num - 1].id.clone()));
            }
        }
        // 回退到文本输入
        Ok(InputResponse::Text(input))
    }
}
```

CLI后端的交互模型是完全同步的，意味着用户响应在执行流内立即接收，使其成为命令行工作流的理想选择。

### GUI后端（`TauriBackend`）

Tauri后端目前在`cowork-core`中实现为占位符，但其设计预见了与Tauri GUI应用程序（`cowork-gui/src-tauri`）的完全集成。这种架构决策遵循了保持核心逻辑独立于UI实现细节的原则。

#### 当前实现：
- 所有方法输出到控制台用于调试目的。
- `submit_response`和`request_input`是存根，等待与Tauri的事件系统集成。
- `event_bus()`方法提供与CLI相同的事件总线实例，确保一致的事件传播。

#### 未来集成计划：

- `request_input`将发布`EngineEvent::HITLRequest`并通过`oneshot`通道或WebSocket订阅等待响应。
- `show_message`和`show_progress`将发出Tauri事件（`emit_all`）以触发React前端中的UI更新。
- `submit_response`将通过Tauri的`Emitter`系统从前端接收响应，完成HITL循环。

这种设计实现了清晰的分离：核心引擎保持不知道它是在与终端还是基于Web的GUI交互，而GUI层处理平台特定的渲染和用户交互。

### 事件总线集成

交互领域与`EventBus`深度集成，EventBus是一个基于`tokio::sync::broadcast::channel(1000)`构建的发布-订阅系统。

#### 关键特性：
- **广播通道**：支持最多1,000个订阅者，非阻塞发布。
- **线程安全**：所有组件（`Arc<EventBus>`）可以跨线程共享。
- **事件类型**：包括14个不同的事件变体，涵盖：
  - 阶段生命周期（`StageStarted`、`StageCompleted`）
  - 智能体活动（`AgentThinking`、`AgentOutput`）
  - 工具执行（`ToolStarted`、`ToolCompleted`）
  - 文件操作（`FileCreated`、`FileModified`）
  - 错误（`Error`）
  - HITL工作流（`HITLRequest`、`HITLResponse`）
  - 进度跟踪（`Progress`）

#### 事件结构示例：
```rust
pub enum EngineEvent {
    HITLRequest {
        tool: String,
        content: String,
        options: Vec<String>,
        session_id: String,
    },
    HITLResponse {
        tool: String,
        response: String,
        session_id: String,
    },
    Progress {
        task_id: String,
        current: u32,
        total: u32,
        message: String,
    },
}
```

#### 使用模式：
```rust
// 在管道阶段中：
event_bus.publish(EngineEvent::HITLRequest {
    tool: "ReviewAndEditFileTool".to_string(),
    content: file_content,
    options: vec!["approve".to_string(), "reject".to_string()],
    session_id: session_id.clone(),
});

// 在GUI前端中：
let mut rx = event_bus.subscribe();
while let Ok(event) = rx.recv().await {
    match event {
        EngineEvent::HITLRequest { content, .. } => {
            show_modal_dialog(&content); // 在React中显示模态框
        }
        EngineEvent::Progress { task_id, current, total, .. } => {
            update_progress_bar(task_id, current, total); // 更新UI
        }
        _ => {}
    }
}
```

这种事件驱动模型使GUI能够在引擎继续处理时保持响应，并允许多个UI组件（例如状态栏、进度面板、HITL模态框）独立订阅相关事件。

## 工作流集成

交互领域在开发工作流的多个关键点被调用：

### 1. 开发迭代过程
在管道的每个阶段（创意→PRD→设计→计划→编码→检查→交付），AI智能体可能触发HITL交互：

- **PRD阶段**：`ReviewAndEditContentTool`调用`request_input`提示用户审查生成的需求。
- **编码阶段**：`ReviewAndEditFileTool`通过`request_input`调用编辑器进行代码修改。
- **检查阶段**：`ProvideFeedbackTool`使用`show_message`显示质量发现，使用`request_input`收集用户验证。

### 2. 变更请求分析
当用户发起修改（`cowork modify`）时，系统：
1. 通过`request_input`捕获自然语言输入。
2. 使用`show_message`显示范围分析。
3. 发布`HITLRequest`事件，允许GUI用户批准或优化更改。

### 3. 实时反馈循环
事件总线实现闭环反馈系统：
- **引擎→UI**：发布`StageStarted`、`Progress`、`HITLRequest`。
- **UI→引擎**：通过`submit_response`（GUI）或直接`InputResponse`（CLI）提交响应。
- **引擎→UI**：使用`HITLResponse`和`StageCompleted`确认完成。

这确保用户始终了解系统状态，并可在任何点进行干预而不破坏工作流。

## 架构优势

### 1. 关注点清晰分离

通过`InteractiveBackend`抽象交互，核心引擎保持对UI技术的不可知性。这使：
- CLI和GUI界面的并行开发。
- 轻松添加新后端（例如，Web仪表板、移动应用）。
- 无UI依赖的引擎逻辑独立测试。

### 2. 可扩展性
可以添加新的交互模式而无需修改引擎：
- 为多步骤审批添加`request_confirmation`方法。
- 引入`show_modal`用于丰富的GUI对话框。
- 通过`SpeechInput`后端支持语音输入。

### 3. 韧性和安全性
- **非阻塞I/O**：异步方法防止UI冻结。
- **错误处理**：所有方法返回`Result`，确保错误适当传播。
- **UTF-8支持**：CLI后端显式处理UTF-8输入/输出，确保与国际字符的兼容性。

### 4. 跨平台一致性
尽管实现不同，CLI和GUI都提供相同的语义交互：
- 相同的输入模式（`Text`、`Selection`、`Cancel`）
- 相同的事件语义（`HITLRequest`→`HITLResponse`）
- 相同的进度报告格式

这保证用户无论使用哪种界面都能体验一致的行为，减少认知负荷和培训开销。

## 集成点

| 组件 | 交互类型 | 目的 |
|---------|------------------|---------|
| **管道执行器** | 调用`InteractiveBackend`方法 | 在阶段执行期间触发用户反馈 |
| **HITL工具** | 使用`request_input`和`submit_response` | 启用文档/代码审查工作流 |
| **EventBus** | 发布`EngineEvent` | 启用实时UI更新 |
| **Tauri GUI** | 订阅`EventBus` | 呈现HITL模态框、进度条和消息 |
| **LLM智能体** | 通过工具间接 | 从用户反馈接收上下文 |

## 结论

交互领域是Cowork Forge架构的基础支柱，在CLI和GUI界面上实现无缝、一致和可扩展的人机循环体验。通过利用Rust的特征系统、async/await并发和事件驱动通信，它在简单性、健壮性和灵活性之间实现了难得的平衡。

该领域的设计体现 了整洁架构原则：它将UI关注点从业务逻辑中隔离，促进可测试性，并在不破坏架构的情况下实现未来创新。随着系统发展，新的交互模式——如语音命令、AI辅助建议或协作编辑——可以通过实现`InteractiveBackend`特征无缝集成，确保Cowork Forge保持在AI辅助软件开发的前沿。