# Cowork Forge 持久化存储域技术文档

## 1. 模块概述

持久化存储域是 Cowork Forge 系统的核心基础设施组件，负责所有开发产物与会话状态的持久化管理。该域以会话为单位，在项目根目录下创建 `.cowork` 目录结构，使用 JSON 文件存储模型数据、配置、反馈历史与中间产物。其核心价值在于实现开发流程的可恢复性、可追溯性与状态隔离，是支持增量修改与历史回溯的基石。

## 2. 架构设计

### 2.1 核心模块组成

持久化存储域由以下核心模块构成：

#### 2.1.1 存储管理模块 (`storage/mod.rs`)
- **文件路径**: `crates/cowork-core/src/storage/mod.rs`
- **核心职责**: 管理 `.cowork/sessions/<id>/` 目录结构，负责创建、复制、加载会话目录与元数据
- **关键功能**:
  - `create_session_dir` - 创建会话目录结构
  - `load_session_metadata` - 加载会话元数据
  - `save_session_metadata` - 保存会话状态
  - `copy_session_state` - 会话继承复制

#### 2.1.2 数据模型模块 (`data/models.rs`)
- **文件路径**: `crates/cowork-core/src/data/models.rs`
- **核心职责**: 定义所有结构化数据的 Rust 结构体，支持 Serde 序列化
- **关键模型**:
  - `Requirement` - 需求定义
  - `Feature` - 功能特性
  - `DesignComponent` - 设计组件
  - `ImplementationTask` - 实现任务
  - `SessionMetadata` - 会话元数据
  - `ChangeRequest` - 变更请求

#### 2.1.3 数据模式模块 (`data/schemas.rs`)
- **文件路径**: `crates/cowork-core/src/data/schemas.rs`
- **核心职责**: 定义 JSON Schema 验证规则（当前为占位符实现）

### 2.2 目录结构设计

```
.cowork/
├── index.json                    # 项目索引文件
└── sessions/
    └── <session_id>/             # 会话隔离目录
        ├── input.json            # 会话输入配置
        ├── change_request.json   # 变更请求（仅修改会话）
        ├── artifacts/            # 文档产物
        │   ├── idea.md
        │   ├── prd.md
        │   ├── design.md
        │   └── delivery_report.md
        ├── state/                # 结构化状态数据
        │   ├── requirements.json
        │   ├── feature_list.json
        │   ├── design_spec.json
        │   ├── implementation_plan.json
        │   ├── code_metadata.json
        │   ├── meta.json
        │   └── feedback.json
        ├── patch/                # 变更追踪数据
        │   └── metadata.json
        └── logs/                 # 执行日志
```

## 3. 核心技术实现

### 3.1 会话隔离机制

```rust
/// 获取会话目录路径
pub fn get_session_dir(session_id: &str) -> Result<PathBuf> {
    let cowork_dir = get_cowork_dir()?;
    let session_path = cowork_dir.join(SESSIONS_DIR).join(session_id);
    
    // 创建会话子目录
    fs::create_dir_all(&session_path)?;
    fs::create_dir_all(session_path.join("artifacts"))?;
    fs::create_dir_all(session_path.join("state"))?;
    fs::create_dir_all(session_path.join("patch"))?;
    fs::create_dir_all(session_path.join("logs"))?;
    
    Ok(session_path)
}
```

### 3.2 数据序列化与持久化

系统使用 Serde 库实现 JSON 序列化，所有数据模型都实现了 `Serialize` 和 `Deserialize` trait：

```rust
[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Requirements {
    pub schema_version: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub requirements: Vec<Requirement>,
}
```

### 3.3 会话继承机制

支持增量修改流程的关键特性，允许新会话基于现有会话状态启动：

```rust
pub fn init_session_from_base(new_session_id: &str, base_session_id: &str) -> Result<()> {
    // 复制状态文件（requirements.json, design_spec.json 等）
    // 复制产物文件（idea.md, prd.md 等）
    // 保持代码文件不变（仅在项目根目录）
}
```

## 4. 核心数据结构

### 4.1 项目索引 (`ProjectIndex`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectIndex {
    pub schema_version: String,
    pub project_name: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub latest_successful_session: Option<String>,
    pub sessions: Vec<SessionRecord>,
}
```

### 4.2 需求模型 (`Requirements`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Requirement {
    pub id: String,  // REQ-001, REQ-002 等
    pub title: String,
    pub description: String,
    pub priority: Priority,
    pub category: RequirementCategory,
    pub acceptance_criteria: Vec<String>,
    pub related_features: Vec<String>,
}
```

### 4.3 设计规范 (`DesignSpec`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DesignSpec {
    pub schema_version: String,
    pub architecture: Architecture,
    pub technology_stack: TechnologyStack,
    pub deployment: DeploymentInfo,
}
```

### 4.4 变更请求 (`ChangeRequest`)

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeRequest {
    pub id: String,
    pub session_id: String,
    pub created_at: DateTime<Utc>,
    pub idea: String,
    pub base_session_id: String,
    pub scope: ChangeScope,
    pub acceptance_criteria: Vec<String>,
    pub constraints: Vec<String>,
    pub analysis: Option<ChangeAnalysis>,
}
```

## 5. 关键业务流程支持

### 5.1 全新项目创建流程

1. **会话初始化**: 创建新的会话目录结构
2. **状态持久化**: 依次保存需求、设计、计划等状态文件
3. **产物生成**: 保存 PRD、设计文档等 Markdown 文件
4. **元数据更新**: 更新项目索引和会话记录

### 5.2 增量修改流程

1. **基础会话加载**: 使用 `init_session_from_base` 复制基础会话状态
2. **变更范围分析**: 保存变更请求和影响分析
3. **选择性更新**: 仅更新受影响的状态文件
4. **变更追踪**: 记录文件变更和产物更新

### 5.3 阶段恢复流程

1. **会话状态恢复**: 加载指定阶段的完整状态
2. **上下文重建**: 恢复需求、设计、计划等结构化数据
3. **流程继续**: 从恢复点继续后续阶段执行

## 6. 容错与数据完整性

### 6.1 文件存在性检查

```rust
pub fn state_file_exists(session_id: &str, filename: &str) -> Result<bool> {
    Ok(state_path(session_id, filename)?.exists())
}

pub fn has_requirements(session_id: &str) -> Result<bool> {
    state_file_exists(session_id, "requirements.json")
}
```

### 6.2 默认值处理

所有加载函数都支持默认值返回，避免因文件不存在导致流程中断：

```rust
pub fn load_requirements(session_id: &str) -> Result<Requirements> {
    let path = state_path(session_id, "requirements.json")?;
    if !path.exists() {
        return Ok(Requirements::new());  // 返回空需求对象
    }
    // ... 正常加载逻辑
}
```

## 7. 性能与扩展性考虑

### 7.1 文件操作优化

- **批量操作**: 支持状态文件的批量保存和加载
- **增量更新**: 仅更新发生变化的状态文件
- **内存管理**: 使用流式读取处理大文件

### 7.2 数据模型版本控制

所有数据模型都包含 `schema_version` 字段，支持未来数据结构变更的向后兼容：

```rust
pub struct Requirements {
    pub schema_version: String,  // "1.0", "2.0" 等
    // ... 其他字段
}
```

## 8. 总结

持久化存储域作为 Cowork Forge 系统的核心基础设施，通过精心设计的目录结构和数据模型，为整个开发流程提供了可靠的状态管理和历史追溯能力。其会话隔离机制支持并发开发，继承机制支持增量修改，而完善的数据验证和容错处理确保了系统的稳定性和可靠性。

该模块的设计充分体现了"最小可行架构"原则，在保证功能完整性的同时，保持了实现的简洁性和可维护性，为系统的长期演进奠定了坚实的基础。