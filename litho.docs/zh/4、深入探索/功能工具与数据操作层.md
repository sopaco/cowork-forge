# 功能工具与数据操作层技术文档

## 概述

功能工具与数据操作层是 Cowork Forge V2 系统的核心支撑域，作为智能体编排与流程控制层的执行基础，提供了一组原子化、可复用的工具集合。该层遵循“工具模式”（Tool Pattern）设计哲学，通过统一的 `Tool Trait` 接口，将复杂的业务操作（如文件读写、数据管理、用户交互）封装为独立的、可被智能体动态调用的模块。其核心价值在于实现了业务逻辑与执行细节的彻底解耦，使智能体能够专注于高层决策与流程协调，而无需关心底层实现细节。

该层由六个核心子模块构成：**文件操作工具**、**数据操作工具**、**验证工具**、**HITL 交互工具**、**反馈与控制工具**和**产物管理工具**。这些工具共同构成了系统数据流转与执行控制的“肌肉系统”，直接决定了自动化开发的质量、安全性和人机协同的流畅度。所有工具均基于 Rust 语言实现，采用异步（`async/await`）架构，确保在高并发场景下的响应性能，并通过严格的输入验证与安全机制保障系统稳定。

## 核心子模块详解

### 1. 文件操作工具模块（file_tools.rs）

该模块负责所有与本地文件系统交互的安全操作，是代码生成、文档管理与项目结构探索的基础。其设计核心是**安全优先**，通过 `validate_path_security` 函数强制实施严格的路径访问策略，有效防止路径穿越（Path Traversal）等安全风险。

- **核心工具**：
  - **`ListFilesTool`**：安全地列出目录内容，支持递归遍历与深度限制。自动过滤 `.git`, `target`, `node_modules`, `.cowork` 等常见忽略目录，为智能体提供清晰的项目结构视图。
  - **`ReadFileTool`**：读取指定文件内容。在读取前会调用路径安全验证，确保文件位于项目根目录或 `.cowork` 目录内。
  - **`WriteFileTool`**：创建或覆盖文件。同样受路径安全机制约束，确保写入操作不会破坏系统文件结构。
  - **`RunCommandTool`**：执行系统命令（如 `cargo build`）。该工具内置了命令白名单机制，会阻断 `npm dev`, `http.server` 等可能长期运行或暴露服务的危险命令，防止系统被滥用。

- **安全机制**：
  - **绝对路径禁止**：所有路径必须为相对路径（如 `src/main.rs`），禁止使用 `/tmp` 或 `C:\\` 等绝对路径。
  - **目录逃逸禁止**：路径中禁止包含 `..`，防止访问父目录或系统其他位置。
  - **路径范围校验**：最终解析的路径必须位于当前工作目录（`current_dir`）的子路径内。

该模块为智能体提供了安全、可靠的“文件系统操作沙箱”，是实现“状态即文件”架构的基石。

### 2. 数据操作工具模块（data_tools.rs）

该模块是系统数据流转的中枢，负责对核心数据模型（`Requirement`, `Feature`, `DesignComponent`, `ImplementationTask` 等）进行增删改查（CRUD）操作。所有数据均以 JSON 格式持久化在 `.cowork/data/` 目录下，该模块是连接内存数据模型与磁盘存储的唯一桥梁。

- **核心工具**：
  - **`CreateRequirementTool`**：根据智能体提供的标题、描述、优先级和验收标准，生成唯一 ID（如 `REQ-001`），并将其添加至 `requirements.json`。
  - **`AddFeatureTool`**：创建新功能，关联其依赖的需求 ID，并初始化状态为 `Pending`，写入 `feature_list.json`。
  - **`CreateDesignComponentTool`**：为架构设计添加新组件（如 API Gateway, User Service），并记录其职责与关联功能。
  - **`CreateTaskTool`**：将设计组件分解为具体的实现任务，设置任务依赖关系，存入 `implementation_plan.json`。
  - **`UpdateFeatureStatusTool`** / **`UpdateTaskStatusTool`**：更新功能或任务的完成状态（如从 `Pending` 变为 `Completed`）。
  - **`GetRequirementsTool`** / **`GetDesignTool`** / **`GetPlanTool`**：读取并反序列化对应的数据文件，为智能体提供上下文信息。

- **关键实现**：
  - **ID 生成**：使用 `generate_id(prefix, count)` 函数生成全局唯一、可读的 ID（如 `FEAT-005`），确保数据引用的一致性。
  - **数据一致性**：所有写入操作均先加载整个 JSON 对象，修改后整体保存，避免并发写入导致的数据损坏。
  - **结构化输入**：每个工具的 `parameters_schema` 定义了严格的 JSON Schema，确保智能体传入的参数类型和结构完全符合预期。

该模块确保了开发流程中所有关键数据（需求、功能、设计、任务）的结构化、可追溯和可验证。

### 3. 验证工具模块（validation_tools.rs）

验证工具模块是系统质量保障的“质检员”，在关键节点自动检查数据的完整性、一致性与逻辑正确性，是实现“自动化校验”而非“人工检查”的核心。

- **核心工具**：
  - **`CheckDataFormatTool`**：验证指定数据文件（`requirements`, `features`, `design`, `plan`）是否符合其预设的结构规范。例如，检查需求是否包含验收标准，功能是否关联了需求。
  - **`CheckFeatureCoverageTool`**：**关键质量门禁**。检查 `feature_list.json` 中的所有功能是否都被 `design_spec.json` 中的架构组件所覆盖。若发现未覆盖的功能，会立即通知智能体进行补充，防止“有需求无设计”的重大缺陷。
  - **`CheckTaskDependenciesTool`**：**关键逻辑校验**。使用深度优先搜索（DFS）算法分析 `implementation_plan.json` 中的任务依赖图，检测是否存在循环依赖（如 A 依赖 B，B 又依赖 A）。若发现环，会阻止流程继续，避免任务无法执行。

- **设计哲学**：
  - **主动防御**：这些工具不是在流程结束时才进行检查，而是在每个阶段（如 Coding 阶段开始前）由 Check Agent 主动调用，实现“左移”质量保障。
  - **结构化输出**：验证结果以标准化 JSON 返回，包含 `status`（`valid`, `invalid`, `incomplete_coverage`）和详细的错误信息，便于智能体进行决策和迭代。

该模块将“经验性”的质量要求，转化为可自动化、可重复执行的代码逻辑，极大提升了交付物的可靠性。

### 4. HITL 交互工具模块（hitl_tools.rs）

HITL (Human-in-the-Loop) 交互工具是实现“人机协同”这一核心价值的关键接口。它将人类专家的判断、经验和意图，无缝地融入自动化流程中，确保 AI 输出符合业务意图。

- **核心工具**：
  - **`ReviewAndEditFileTool`**：早期版本的交互工具。它会展示文件预览，并询问用户是否要编辑。用户选择“是”则打开默认编辑器（如 VSCode），修改后保存，流程继续。
  - **`ReviewWithFeedbackTool`**：**当前主力工具**。提供更灵活的三种交互模式：
    1.  **`edit`**：打开编辑器进行修改。
    2.  **`pass`**：直接确认，无需修改。
    3.  **任意文本**：输入具体的修改建议（如“此处应增加错误处理”），该文本将被作为结构化反馈传递给智能体。

- **交互体验**：
  - 基于 `dialoguer` 库实现，提供清晰的 CLI 交互界面。
  - 支持预览文件内容（默认显示前15行），避免用户面对大文件时的困惑。
  - 用户的任何操作（编辑、通过、反馈）都会被工具捕获并返回给调用它的智能体，形成一个完整的“生成-审查-反馈-优化”闭环。

该模块是系统从“全自动”走向“智能增强”的分水岭，赋予了人类专家在关键节点上的“否决权”和“指导权”。

### 5. 反馈与控制工具模块（control_tools.rs）

该模块为 HITL 交互提供了更深层次的控制能力，允许智能体主动向用户提问并获取结构化响应，实现双向、有目的的对话。

- **核心工具**：
  - **`ProvideFeedbackTool`**：**结构化反馈的入口**。智能体（通常是 Critic）通过此工具提交反馈，而非简单的文本。它要求提供 `feedback_type`（`build_error`, `quality_issue`, `missing_requirement`, `suggestion`）、`severity`（`critical`, `major`, `minor`）和 `details`。这些结构化信息会被追加到 `feedback_history.json`，供后续智能体（如 Coding Agent）在下一轮迭代中参考，实现“有记忆”的学习。
  - **`AskUserTool`**：**主动提问**。智能体可以向用户提出明确的问题，如“是否需要为用户模块添加登录功能？”（`question_type: yes_no`）或“请指定数据库的连接地址？”（`question_type: text_input`）。该工具返回布尔值或文本，为智能体提供决策依据。

- **价值**：
  - 将模糊的“用户反馈”转化为**可解析、可追溯、可复用**的结构化数据。
  - 使智能体能够进行**主动式**的交互，而非被动等待，极大地提升了流程的效率和精准度。

### 6. 产物管理工具模块（artifact_tools.rs）

该模块负责将开发流程中产生的、面向最终交付的“成果物”（Artifacts）进行规范化生成与持久化。这些产物是项目交付的直接证据，也是团队知识沉淀的载体。

- **核心工具**：
  - **`SaveDeliveryReportTool`**：将 Delivery Agent 生成的完整交付报告（Markdown 格式）保存为 `delivery_report.md`。
  - **`SavePrdDocTool`** / **`SaveDesignDocTool`**：将 PRD 和设计文档的 Markdown 内容分别保存为 `prd.md` 和 `design.md`。
  - **`SaveFeedbackHistoryTool`**：将所有阶段的反馈历史（`feedback_history.json`）合并并持久化，形成完整的审计日志。
  - **`LoadFeedbackHistoryTool`**：在流程恢复或审查时，加载历史反馈，为智能体提供上下文。

- **设计特点**：
  - 所有产物均以**人类可读的 Markdown**格式存储，而非二进制或专有格式，确保了长期可访问性。
  - 产物统一存放在 `.cowork/artifacts/` 目录下，与核心数据（`.cowork/data/`）分离，体现了清晰的职责划分。
  - 工具仅负责“写入”，不负责内容生成，内容由智能体（如 Delivery Agent）生成，实现了关注点分离。

## 工具交互模式与数据流

所有工具均遵循统一的交互模式，确保了系统的高度一致性与可预测性。

1.  **接口统一**：所有工具实现 `adk_core::Tool` trait，提供 `name()`, `description()`, `parameters_schema()` 和 `execute()` 方法。
2.  **参数强校验**：`parameters_schema()` 定义了 JSON Schema，智能体在调用前必须提供符合 Schema 的参数，否则调用失败。
3.  **异步非阻塞**：`execute()` 方法为 `async fn`，确保工具调用不会阻塞智能体的主流程。
4.  **标准化响应**：所有工具返回的 JSON 响应都包含 `status`（`success`, `error`, `invalid` 等）和 `message` 字段，部分工具会返回 `data` 字段携带结果。这种一致性使得智能体的解析逻辑变得极其简单和健壮。

**典型数据流示例**：
1.  **Coding Agent** 生成代码后，调用 `WriteFileTool` 将 `user_service.rs` 写入磁盘。
2.  **Check Agent** 调用 `CheckFeatureCoverageTool`，发现新功能 `User Login` 未被设计覆盖。
3.  **Check Agent** 调用 `ProvideFeedbackTool`，提交一条 `missing_requirement` 类型的反馈。
4.  **Coding Agent** 在下一轮迭代中，读取 `feedback_history.json`，并调用 `ReviewWithFeedbackTool`，向用户展示反馈并询问是否需要补充设计。
5.  用户输入 `edit`，工具打开 `design.md`，用户补充了 `User Login` 组件。
6.  用户保存文件，工具返回 `action: edit`，Coding Agent 继续执行。

## 总结

功能工具与数据操作层是 Cowork Forge V2 系统中承上启下的关键一环。它通过精心设计的原子化工具，将复杂的软件工程活动（文件管理、数据建模、质量验证、人机交互）转化为可被 AI 智能体调用的标准化服务。其卓越的安全性、一致性和人机协同能力，是系统能够实现“端到端自动化”且“质量可控”的根本保障。该层的设计完美体现了“高内聚、低耦合”的架构原则，是构建可靠 AI 原生开发工具的典范。