# 迭代管理领域文档

## 概述

迭代管理领域是Cowork Forge的核心引擎，负责通过结构化的AI辅助工作流协调单个开发周期。每个迭代代表一个完整的、自包含的软件开发周期——从初始概念到最终交付——遵循七阶段管道（创意→PRD→设计→计划→编码→检查→交付）。该领域确保所有开发活动的可追溯性、一致性和自动化，使开发者能够以最少的手动干预交付高质量软件。

该领域实现为包含两个主要组件的分层系统：**迭代实体**（领域模型）和**迭代持久化层**（仓库）。这些组件与管道执行器协同工作，管理生命周期转换、继承模式和制品跟踪，形成Cowork Forge迭代开发范式的主干。

## 核心组件

### 1. 迭代实体

`Iteration`结构体是代表单个开发周期的中央领域模型。它封装了与迭代相关的所有元数据、状态和制品，提供开发过程的丰富、可序列化表示。

#### 结构和字段

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Iteration {
    pub id: String,                    // 唯一标识符（例如"iter-123-1770079582"）
    pub number: u32,                   // 项目中的顺序迭代编号
    pub title: String,                 // 人类可读的标题
    pub description: String,           // 变更范围的自然语言描述

    // 继承
    pub base_iteration_id: Option<String>, // 对父迭代的引用（用于进化）
    pub inheritance: InheritanceMode,     // 继承模式：None、Full、Partial

    // 执行状态
    pub status: IterationStatus,         // Draft、Running、Paused、Completed、Failed
    pub started_at: DateTime<Utc>,       // 迭代开始时间戳
    pub completed_at: Option<DateTime<Utc>>, // 迭代完成时间戳
    pub current_stage: Option<String>,   // 正在执行的当前阶段
    pub completed_stages: Vec<String>,   // 已完成阶段的有序列表

    // 制品
    pub artifacts: Artifacts,            // 生成的文档和代码的文件路径
}
```

#### 关键行为和方法

`Iteration`实体提供了全面的生命周期和状态管理方法：

- **`create_genesis()`**：初始化一个新的、无继承的独立迭代。用于项目初始化或全新功能开发。
- **`create_evolution()`**：基于先前迭代创建新的迭代，支持继承模式（`Full`、`Partial`或`None`）。这支持迭代优化和变更驱动开发。
- **`start()`、`pause()`、`resume()`、`complete()`、`fail()`**：管理迭代的执行状态，实现人机循环控制和从失败中恢复。
- **`set_stage()`**：在管道执行期间更新当前阶段。
- **`complete_stage()`**：记录阶段的完成，并将其生成的制品（例如`prd.md`、`design.md`）与迭代关联。
- **`determine_start_stage()`**：领域中最复杂的方法，通过关键词匹配分析迭代的`description`字段，自动确定进化迭代的适当起始阶段。

#### 智能阶段确定

`determine_start_stage()`方法实现语义分析，减少手动配置并加速开发周期：

```rust
fn analyze_change_scope(description: &str) -> String {
    let desc_lower = description.to_lowercase();

    // 架构变更 → 从'idea'开始
    let arch_keywords = ["架构", "architecture", "重构", "rewrite", "重新设计", "redesign"];
    if arch_keywords.iter().any(|kw| desc_lower.contains(kw)) {
        return "idea".to_string();
    }

    // 需求变更 → 从'prd'开始
    let req_keywords = ["需求", "requirement", "功能", "feature", "添加", "add"];
    if req_keywords.iter().any(|kw| desc_lower.contains(kw)) {
        return "prd".to_string();
    }

    // 设计变更 → 从'design'开始
    let design_keywords = ["设计", "design", "数据库", "database", "接口", "api"];
    if design_keywords.iter().any(|kw| desc_lower.contains(kw)) {
        return "design".to_string();
    }

    // 默认：代码变更 → 从'plan'开始
    "plan".to_string()
}
```

这种智能自动检测使用户能够用自然语言描述发起迭代，例如：
- _"使用OAuth2添加用户身份验证"_ → 从`prd`开始
- _"重构数据库模式以支持多租户"_ → 从`idea`开始
- _"将API端点更新到v2"_ → 从`design`开始
- _"修复auth模块中的登录错误"_ → 从`plan`开始

这减少了认知负荷，确保AI智能体从最相关的阶段开始工作，提高效率和相关性。

#### 制品跟踪

`Artifacts`结构跟踪所有生成的文档和代码文件的位置：

```rust
pub struct Artifacts {
    pub idea: Option<String>,
    pub prd: Option<String>,
    pub design: Option<String>,
    pub plan: Option<String>,
    pub delivery: Option<String>,
}
```

每个制品作为会话工作区中的相对文件路径存储（例如`.cowork/sessions/iter-123/artifacts/prd.md`）。这使得与工具支持层无缝集成，实现文件访问和人机循环编辑。

#### 摘要接口

`to_summary()`方法返回轻量级的`IterationSummary`，用于UI渲染和列表操作，最小化序列化开销：

```rust
pub struct IterationSummary {
    pub id: String,
    pub number: u32,
    pub title: String,
    pub status: IterationStatus,
    pub completed_stages: Vec<String>,
    pub created_at: DateTime<Utc>,
}
```

这种关注点分离确保UI组件可以高效显示迭代列表，而无需加载完整制品内容。

### 2. 迭代持久化层

`IterationStore`实现了仓库模式，在领域模型和物理存储之间提供清晰的抽象。

#### 关键操作

| 方法 | 目的 |
|--------|---------|
| `load(iteration_id)` | 从JSON文件加载迭代（`iterations/iter-xxx.json`） |
| `save(iteration)` | 将迭代状态持久化到磁盘，使用美化格式的JSON |
| `exists(iteration_id)` | 检查迭代文件是否存在 |
| `delete(iteration_id)` | 删除迭代文件和关联制品 |
| `load_all()` | 检索所有迭代，按编号排序 |
| `load_summaries()` | 返回轻量级摘要用于UI列表 |
| `workspace_path()` | 返回迭代工作区的路径 |
| `ensure_workspace()` | 确保工作区目录存在，必要时创建 |
| `iteration_path()` | 返回迭代制品目录的路径 |

#### 存储结构

所有迭代数据持久化在分层、会话隔离的结构中：

```
.cowork/
├── sessions/
│   └── iter-123/                 # 会话目录
│       ├── artifacts/            # 生成的文档（prd.md、design.md等）
│       └── state/                # 临时状态文件
├── iterations/
│   ├── iter-123.json             # 迭代元数据（序列化的Iteration结构体）
│   └── iter-124.json
└── workspace/                    # 活动迭代的共享工作区
```

这种设计确保：
- **隔离**：每个迭代有自己的工作区和制品。
- **可追溯性**：所有变更都有版本控制并链接到特定迭代。
- **可重现性**：可以从持久化状态重新加载和重新执行任何迭代。

#### 工作区继承逻辑

管道执行器中的`prepare_workspace()`方法利用`IterationStore`实现继承：

- **完全继承**：从基础迭代的工作区复制所有文件（用于重大重构）。
- **部分继承**：仅复制非代码资产（配置文件、README、文档）和制品，强制代码重新生成（用于功能添加）。
- **无继承**：从空工作区开始（用于起源迭代）。

这种逻辑在`inherit_from_base()`中实现，确保进化迭代仅继承必要的内容，避免不必要的代码复制，同时保留上下文。

## 与其他领域的集成

### 1. 项目管理领域

迭代管理领域与项目管理领域紧密耦合：

- **所有权**：一个`Project`包含`Iteration`实体集合并引用当前迭代。
- **ID生成**：`Project`通过`next_iteration_number()`生成唯一迭代编号，确保顺序编号。
- **生命周期协调**：当迭代完成时，更新`Project`以反映新的当前迭代。

```rust
// 在IterationExecutor::create_genesis_iteration中
let iteration = Iteration::create_genesis(project, title.into(), description.into());
self.iteration_store.save(&iteration)?;
self.project_store.add_iteration(project, iteration.to_summary())?; // 更新项目
```

### 2. 管道领域

管道领域是迭代管理领域的主要消费者：

- **执行器**：`IterationExecutor`使用`Iteration`确定起始阶段、准备工作区和跟踪进度。
- **阶段执行**：每个管道阶段（PRD、设计等）通过`Iteration.artifacts`字段读取和写入制品。
- **反馈循环**：如果阶段失败或需要人工审查，迭代的`status`更新为`Paused`，执行器等待用户输入。

### 3. 工具支持领域

工具支持层通过与迭代管理领域交互：

- **制品工具**：`SavePrdDocTool`、`SaveDesignDocTool`等在生成文档后更新`Iteration.artifacts`字段。
- **HITL工具**：`ReviewAndEditFileTool`在外部编辑器（如VSCode）中打开`Iteration.artifacts`中引用的文件。
- **跳转阶段工具**：允许智能体跳转到特定阶段，更新`current_stage`并清除后续的`completed_stages`。

### 4. 存储领域

`IterationStore`依赖存储领域进行路径解析：

- 使用`get_cowork_dir()`定位`.cowork/`
- 创建和验证目录结构（`iterations/`、`workspace/`、`artifacts/`）
- 确保文件路径安全并在项目边界内

## 工作流集成

### 开发迭代过程

迭代管理领域是核心开发工作流的核心：

1. **启动**：用户触发`cowork run` → `IterationExecutor.create_genesis_iteration()` → 创建新`Iteration`
2. **阶段执行**：管道阶段顺序执行，每步后调用`complete_stage(stage, path)`
3. **HITL干预**：在任何阶段，用户可以请求审查 → `Iteration.status`变为`Paused`
4. **恢复**：用户批准变更 → `Iteration.resume()` → 管道继续
5. **完成**：`DeliveryStage`将代码复制到项目根目录 → `Iteration.complete()` → 更新`Project.current_iteration`

### 变更请求分析

当用户发起修改（`cowork modify`）时：

1. 创建带有`base_iteration_id`和`inheritance: Partial`的新`Iteration`
2. `determine_start_stage()`分析变更描述以确定起始阶段
3. 管道从该阶段恢复，仅重用相关制品
4. 原迭代保持不变，保留历史记录

这使得软件的安全、可追溯进化在不干扰先前工作的情况下成为可能。

## 技术实现细节

### 序列化和持久化

- **格式**：使用`serde_json`的JSON
- **编码**：UTF-8
- **结构**：人类可读、版本化、友好差异
- **原子性**：文件写入是原子的（通过`std::fs::write`），防止损坏

### 错误处理

- 使用`anyhow::Result`进行统一错误处理
- 所有文件操作包装在try-catch块中
- 无效路径或损坏的JSON文件被优雅处理并提供信息性错误

### 并发和安全

- 迭代文件同步读/写（无并发写入）
- 工作区隔离防止跨迭代污染
- 路径验证防止目录遍历攻击

### 性能考虑

- `to_summary()`最小化UI数据传输
- `load_summaries()`避免在列表期间反序列化完整制品
- 工作区继承使用异步文件复制（`tokio::fs`）避免阻塞主线程

## 最佳实践和使用指南

### 对于开发者

- **使用描述性迭代标题**："添加用户资料页面"优于"功能1"
- **在变更描述中明确表达**：使用"architecture"、"design"、"requirement"等关键词触发智能阶段选择
- **利用部分继承**：对于小型功能添加，使用`Partial`继承避免重新生成整个代码库
- **在完成前审查制品**：使用HITL工具验证生成的文档和代码

### 对于系统集成者

- **扩展`analyze_change_scope()`**：添加领域特定关键词（例如"security"、"performance"）以提高阶段检测
- **自定义继承规则**：修改`inherit_from_base()`以支持自定义制品过滤
- **与外部系统集成**：使用`IterationStore.load_all()`将迭代历史暴露给CI/CD或报告工具

## 结论

迭代管理领域是Cowork Forge的架构核心，将抽象开发概念转化为可执行、可追溯和自动化的工作流。通过结合丰富的领域模型与智能语义分析和健壮的持久化，它实现了无缝的人机协作模型，减少手动开销，同时保持质量和可追溯性。

其设计体现 了整洁架构原则：  
- **封装**：所有迭代状态包含在`Iteration`实体内  
- **关注点分离**：领域逻辑与存储和UI隔离  
- **可扩展性**：可以添加新的继承模式、阶段或制品类型而不破坏现有代码  

该领域确保每个软件变更——无论多么小——都被视为一等、文档化和可重复的过程，使Cowork Forge不仅是代码生成器，而且是真正的AI驱动开发伙伴。