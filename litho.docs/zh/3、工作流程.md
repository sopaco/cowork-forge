# Core Workflows

## 1. 工作流概述

Cowork Forge 是一个基于AI智能体的软件开发编排系统，通过精心设计的核心工作流实现从需求构思到代码交付的完整自动化开发周期。系统采用人类参与循环（HITL）机制，在关键决策节点引入人工审核，确保开发过程符合简洁性原则。

### 1.1 核心工作流类型
- **全新项目创建流程**：从零开始构建完整项目的标准流程
- **增量修改流程**：基于现有项目进行功能扩展或修改的迭代流程  
- **阶段恢复流程**：断点续传机制，支持从任意阶段重新开始
- **人机交互反馈流程**：智能体与用户之间的交互与错误恢复机制

### 1.2 核心执行路径
系统采用七阶段智能体流水线：Idea → PRD → Design → Plan → Coding → Check → Delivery，每个阶段都包含详细的Actor-Critic审核机制。

### 1.3 关键流程节点
- **会话管理**：每个开发任务创建独立的会话目录，确保状态隔离
- **智能体编排**：通过SequentialAgent实现多智能体顺序执行
- **数据持久化**：JSON文件存储结构化数据，Markdown存储文档
- **错误恢复**：ResilientAgent包装器提供错误拦截和人工干预能力

## 2. 主要工作流

### 2.1 全新项目创建流程

```
graph TD
   [用户执行cowork-cli new命令] --> B[解析CLI参数并初始化会话]
    B --> C[IdeaAgent捕获并结构化用户想法]
    C --> D[PRD Actor-Critic循环生成需求文档]
    D --> E[Design Actor-Critic循环生成架构设计]
    E --> F[Plan Actor-Critic循环生成任务清单]
    F --> G[Coding Actor-Critic循环实现代码]
    G --> H[文件工具读写代码文件]
    H --> I[CheckAgent验证代码结构完整性]
    I --> J[DeliveryAgent生成交付报告]
    J --> K[保存交付产物至会话目录]
    
    C --> C1{HITL审核}
    D --> D1{HITL审核}
    E --> E1{HITL审核}
    F --> F1{HITL审核}
    G --> G1{HITL审核}
    
    C1 -->|通过| D
    D1 -->|通过| E
    E1 -->|通过| F
    F1 -->|通过| G
    G1 -->|通过| I
    
    C1 -->|需修改| C
    D1 -->|需修改| D
    E1 -->|需修改| E
    F1 -->|需修改| F
    G1 -->|需修改| G
```

#### 2.1.1 详细执行过程

**阶段1：会话初始化**
```rust
// 代码入口：crates/cowork-cli/src/main.rs cmd_new函数
let session_id = format!("session-{}", chrono::Utc::now().timestamp());
let session_record = SessionRecord {
    session_id: session_id.clone(),
    session_type: SessionType::New,
    // ... 其他字段
};
```

**阶段2：智能体流水线执行**
```rust
// 代码入口：crates/cowork-core/src/pipeline/mod.rs create_cowork_pipeline函数
let pipeline = SequentialAgent::new(
    "cowork_forge_pipeline",
    vec![
        idea_agent,        // IdeaAgent
        prd_loop,          // PRD Actor-Critic循环
        design_loop,       // Design Actor-Critic循环  
        plan_loop,         // Plan Actor-Critic循环
        coding_loop,       // Coding Actor-Critic循环
        check_agent,       // CheckAgent
        delivery_agent,    // DeliveryAgent
    ],
);
```

**阶段3：数据流处理**
- **输入**：用户原始想法（字符串）
- **输出**：结构化需求、设计文档、实现代码、交付报告
- **状态转移**：每个阶段完成后生成对应的JSON数据文件

### 2.2 增量修改流程

```
graph TD
    A[用户执行cowork-cli modify命令] --> B[加载当前会话状态与历史数据]
    B --> C[Modify Triage Agent分析变更范围]
    C --> D{变更影响分析}
    D -->|影响PRD| E[回退至PRD阶段重新生成需求]
    D -->|影响Design| F[回退至Design阶段重新设计]
    D -->|影响Plan| G[回退至Plan阶段重新规划]
    D -->|仅影响代码| H[直接进入代码修补阶段]
    
    E --> I[执行PRD到Delivery完整流程]
    F --> J[执行Design到Delivery完整流程]
    G --> K[执行Plan到Delivery完整流程]
    H --> L[Coding Agent执行代码修补]
    
    I --> M[Modify Delivery Agent生成变更报告]
    J --> M
    K --> M
    L --> M
    
    M --> N[保存变更报告至会话目录]
```

#### 2.2.1 变更范围分析逻辑
```rust
// 代码逻辑：crates/cowork-core/src/pipeline/mod.rs create_resume_pipeline函数
let start_stage = if has_code_files(base_session_id)? {
    "check"  // 代码文件存在 → 从Check阶段恢复
} else if has_implementation_plan(base_session_id)?
    && has_design_spec(base_session_id)?
    && has_requirements(base_session_id)?
{
    "coding" // 需求、设计、计划都存在 → 从Coding阶段恢复
} else if has_design_spec(base_session_id)? && has_requirements(base_session_id)? {
    "plan"   // 需求、设计存在 → 从Plan阶段恢复
} else if has_requirements(base_session_id)? {
    "design" // 仅需求存在 → 从Design阶段恢复
} else {
    "prd"    // 无数据或只有想法 → 从PRD阶段开始
};
```

### 2.3 阶段恢复流程

```
graph TD
    A[用户执行cowork-cli resume命令] --> B[解析目标阶段参数]
    B --> C[验证阶段有效性]
    C --> D[加载会话元数据与中间产物]
    D --> E[构建从指定阶段开始的子流程]
    E --> F[启动目标阶段及后续智能体流水线]
    F --> G[持续更新状态与文件]
    G --> H[更新会话元数据标记执行阶段]
```

#### 2.3.1 会话状态恢复机制
系统通过检查`.cowork/sessions/<id>/`目录下的文件存在性来判断恢复点：
- **requirements.json**：PRD阶段完成标志
- **design_spec.json**：Design阶段完成标志  
- **implementation_plan.json**：Plan阶段完成标志
- **源代码文件**：Coding阶段完成标志

### 2.4 人机交互反馈流程

```
graph TD
    A[智能体检测到错误或需决策] --> B[调用ResilientAgent包装器]
    B --> C[调用HITL交互工具请求用户介入]
    C --> D{用户选择操作}
    D -->|编辑内容| E[ReviewAndEditContentTool]
    D -->|提供反馈| F[ProvideFeedbackTool]
    D -->|请求重规划| G[RequestReplanningTool]
    
    E --> H[收集用户输入并持久化]
    F --> H
    G --> H
    
    H --> I{ResilientAgent决策}
    I -->|重试| J[重置计数器并重试智能体]
    I -->|继续| K[继续执行后续流程]
    I -->|中止| L[中止当前流程]
    
    J --> B
    K --> M[流程继续]
    L --> N[流程终止]
```

## 3. 流程协调与控制

### 3.1 多模块协调机制

#### 3.1.1 智能体编排策略
```rust
// 代码实现：crates/cowork-core/src/agents/mod.rs
// 关键设计：避免LoopAgent的exit_loop()导致SequentialAgent提前终止
let mut loop_agent = LoopAgent::new("prd_loop", vec![actor, critic]);
loop_agent = loop_agent.with_max_iterations(3); // 使用迭代次数控制而非exit_loop
```

#### 3.1.2 工具调用协调
每个智能体通过统一的Tool trait接口调用工具：
- **文件操作工具**：读写项目文件
- **数据操作工具**：管理结构化数据
- **验证工具**：质量保证检查
- **HITL工具**：用户交互接口

### 3.2 状态管理与同步

#### 3.2.1 会话状态机
系统维护完整的状态转移图：

```
stateDiagram-v2
    [*] --> INITIALIZED : cowork init
    INITIALIZED --> IDEA_CAPTURED : IdeaAgent完成
    IDEA_CAPTURED --> PRD_COMPLETED : PRD Loop完成
    PRD_COMPLETED --> DESIGN_COMPLETED : Design Loop完成
    DESIGN_COMPLETED --> PLAN_COMPLETED : Plan Loop完成
    PLAN_COMPLETED --> CODING_COMPLETED : Coding Loop完成
    CODING_COMPLETED --> CHECK_PASSED : CheckAgent通过
    CHECK_PASSED --> DELIVERY_GENERATED : DeliveryAgent完成
    DELIVERY_GENERATED --> [*]
    
    PRD_COMPLETED --> PRD_COMPLETED : HITL审核不通过
    DESIGN_COMPLETED --> DESIGN_COMPLETED : HITL审核不通过
    PLAN_COMPLETED --> PLAN_COMPLETED : HITL审核不通过
    CODING_COMPLETED --> CODING_COMPLETED : HITL审核不通过
```

#### 3.2.2 数据传递机制
- **会话隔离**：每个会话拥有独立的`.cowork/sessions/<id>/`目录
- **数据继承**：修改流程从基础会话复制状态到新会话
- **状态持久化**：通过JSON文件保存智能体执行状态

### 3.3 执行控制与调度

#### 3.3.1 流水线控制策略
```rust
// 代码实现：crates/cowork-core/src/pipeline/mod.rs
pub fn create_partial_pipeline(
    config: &ModelConfig,
    session_id: &str, 
    base_session_id: &str,
    start_stage: &str,  // "prd", "design", "plan", "coding", "check"
) -> Result<Arc<dyn Agent>> {
    // 根据start_stage参数构建部分流水线
    match start_stage {
        "prd" => create_pipeline_from_prd(config, session_id, base_session_id),
        "design" => create_pipeline_from_design(config, session_id, base_session_id),
        "plan" => create_pipeline_from_plan(config, session_id, base_session_id),
        "coding" => create_pipeline_from_coding(config, session_id, base_session_id),
        "check" => create_pipeline_from_check(config, session_id, base_session_id),
        _ => Err(anyhow::anyhow!("Invalid start stage: {}", start_stage)),
    }
}
```

## 4. 异常处理与恢复

### 4.1 错误检测与处理

#### 4.1.1 ResilientAgent错误恢复机制
```rust
// 代码实现：crates/cowork-core/src/agents/hitl.rs
pub struct ResilientAgent {
    inner: Arc<dyn Agent>,
}

impl ResilientAgent {
    pub fn new(agent: Arc<dyn Agent>) -> Self {
        Self { inner: agent }
    }
    
    // 拦截智能体执行错误，提供三种恢复选项
    async fn handle_error(&self, error: &anyhow::Error) -> RecoveryAction {
        if error.to_string().contains("Max iterations") {
            // 提供用户交互选项
            let choice = dialoguer::Select::new()
                .items(&["Retry with reset counter", "Provide guidance and retry", "Abort"])
                .interact()
                .unwrap();
            
            match choice {
                0 => RecoveryAction::Retry,
                1 => RecoveryAction::RetryWithGuidance,
                2 => RecoveryAction::Abort,
                _ => RecoveryAction::Abort,
            }
        } else {
            RecoveryAction::Abort
        }
    }
}
```

#### 4.1.2 文件系统异常处理
系统通过安全的文件操作工具防止常见错误：
- **路径验证**：确保所有路径相对且在当前工作目录内
- **目录遍历保护**：防止越权访问系统文件
- **自动目录创建**：写入文件前自动创建所需目录结构

### 4.2 异常恢复机制

#### 4.2.1 HITL交互恢复策略
当智能体遇到困难时，系统通过以下工具请求用户介入：
- **ReviewAndEditContentTool**：直接编辑内容
- **ReviewWithFeedbackTool**：提供文本反馈
- **ProvideFeedbackTool**：结构化反馈收集
- **RequestReplanningTool**：请求重新规划

#### 4.2.2 会话状态恢复
系统支持从任意阶段恢复执行：
```rust
// 恢复逻辑：检查各阶段产物文件的存在性
fn determine_resume_point(base_session_id: &str) -> Result<&str> {
    if has_code_files(base_session_id)? {
        Ok("check")
    } else if has_implementation_plan(base_session_id)? 
        && has_design_spec(base_session_id)? 
        && has_requirements(base_session_id)? 
    {
        Ok("coding") 
    }
    // ... 其他条件判断
}
```

### 4.3 容错策略设计

#### 4.3.1 LLM调用容错
- **速率限制**：通过RateLimiter中间件控制API调用频率
- **超时处理**：配置合理的请求超时时间
- **重试机制**：对临时性错误自动重试

#### 4.3.2 数据完整性保证
```rust
// 代码实现：crates/cowork-core/src/tools/validation_tools.rs
pub struct CheckDataFormatTool {
    session_id: String,
}

impl CheckDataFormatTool {
    async fn execute(&self, params: Value) -> Result<Value> {
        // 验证JSON数据格式符合预期schema
        // 检查必需字段是否存在
        // 验证数据类型正确性
    }
}
```

## 5. 关键流程实现

### 5.1 核心算法流程

#### 5.1.1 智能体决策算法
每个智能体遵循特定的决策逻辑：
- **IdeaAgent**：非交互式理解用户想法，结构化保存到idea.md
- **PRD Actor-Critic**：Actor生成需求草案，Critic验证完整性和简洁性
- **Design Actor-Critic**：强制执行"最多4个组件"的最小架构原则
- **Plan Actor-Critic**：仅包含核心功能实现任务，排除测试和部署

#### 5.1.2 变更影响分析算法
```rust
// 伪代码：变更影响分析逻辑
fn analyze_change_impact(change_request: ChangeRequest, current_state: SessionState) -> ImpactAnalysis {
    let mut impact = ImpactAnalysis::new();
    
    // 分析PRD影响
    if change_request.affects_requirements() {
        impact.add_affected_stage("prd");
    }
    
    // 分析设计影响  
    if change_request.affects_design_components() {
        impact.add_affected_stage("design");
    }
    
    // 分析计划影响
    if change_request.affects_tasks() {
        impact.add_affected_stage("plan");
    }
    
    // 分析代码影响
    if change_request.affects_code() {
        impact.add_affected_stage("coding");
    }
    
    impact
}
```

### 5.2 数据处理流水线

#### 5.2.1 结构化数据流
系统维护清晰的数据转换流水线：

```
sequenceDiagram
    participant User as 用户
    participant IdeaA as IdeaAgent
    participant PRDA as PRD Actor
    participant PRDC as PRD Critic
    participant Storage as 存储系统
    
    User->>IdeaA: 提供原始想法
    IdeaA->>Storage: 保存idea.md
    IdeaA->>PRDA: 传递结构化想法
    
    PRDA->>PRDA: 生成需求草案
    PRDA->>Storage: 保存requirements.json
    PRDA->>PRDC: 提交审核
    
    PRDC->>PRDC: 验证需求质量
    PRDC->>Storage: 保存反馈记录
    alt 审核通过
        PRDC->>PRDA: 批准进入下一阶段
    else 需要修改
        PRDC->>PRDA: 返回修改建议
    end
```

#### 5.2.2 文件指纹追踪
系统通过文件指纹机制追踪变更：
```rust
// 文件变更追踪逻辑
fn track_file_changes(session_id: &str) -> Result<FileChangeSet> {
    let mut changes = FileChangeSet::new();
    
    for entry in WalkDir::new(".") {
        let entry = entry?;
        if entry.file_type().is_file() {
            let path = entry.path();
            let fingerprint = calculate_file_fingerprint(path)?;
            
            if is_file_modified(session_id, path, &fingerprint)? {
                changes.add_modified_file(path, fingerprint);
            }
        }
    }
    
    Ok(changes)
}
```

### 5.3 业务规则执行

#### 5.3.1 简洁性原则执行
系统通过指令模板强制执行简洁性规则：
```rust
// DESIGN_CRITIC_INSTRUCTION 片段
const DESIGN_CRITIC_INSTRUCTION: &str = r#"
CRITICAL RULES:
1. REJECT any design with more than 4 components
2. REJECT any design that includes testing, deployment, or monitoring components
3. REJECT over-engineered architectures
4. Focus ONLY on core functionality implementation
"#;
```

#### 5.3.2 质量验证规则
CheckAgent执行最小化验证原则：
- **特征覆盖验证**：确保所有需求特征都有对应的设计组件
- **任务依赖分析**：检测循环依赖并使用DFS算法验证
- **文件存在性检查**：验证代码文件实际存在而不仅仅是任务标记完成

### 5.4 技术实现细节

#### 5.4.1 异步执行架构
系统基于Tokio运行时实现全异步执行：
```rust
#[tokio::main]
async fn main() -> Result<()> {
    // 异步执行智能体流水线
    let mut stream = runner.run_stream(pipeline, initial_content).await?;
    
    while let Some(result) = stream.next().await {
        match result {
            Ok(content) => process_agent_output(content).await?,
            Err(e) => handle_agent_error(e).await?,
        }
    }
    
    Ok(())
}
```

#### 5.4.2 内存管理优化
- **智能体实例复用**：通过Arc共享LLM客户端实例
- **流式处理**：支持LLM流式输出，减少内存占用
- **会话数据懒加载**：按需加载会话数据，避免一次性加载所有历史

## 6. 性能优化流程

### 6.1 并发处理策略

#### 6.1.1 智能体执行优化
虽然主要流程是顺序执行，但系统在以下方面优化性能：
- **LLM调用并行化**：Actor和Critic可以并行执行验证
- **文件操作异步化**：所有文件读写操作均为异步非阻塞
- **缓存策略**：频繁访问的配置数据和会话元数据缓存

#### 6.1.2 资源管理
```rust
// 资源受限环境下的优化策略
impl RateLimiter {
    pub fn with_default_delay() -> Self {
        // 默认2秒延迟，适合<30次/分钟的速率限制
        Self::new(Duration::from_secs(2))
    }
    
    pub fn with_custom_delay(delay: Duration) -> Self {
        Self::new(delay)
    }
}
```

### 6.2 工作流性能监控

系统通过以下指标监控工作流性能：
- **阶段执行时间**：记录每个智能体阶段的执行时长
- **LLM调用次数**：统计API调用频率和成功率
- **用户交互次数**：监控HITL介入频率和类型
- **文件操作统计**：跟踪读写操作的性能和错误率

这套核心工作流设计确保了Cowork Forge系统在保持开发质量的同时，提供了高效的自动化开发体验，特别适合独立开发者和初创团队快速验证产品想法。