# 核心工作流

## 1. 工作流概述

Cowork Forge 是一个基于人工智能的软件开发系统，通过迭代式、多智能体工作流自动化整个软件开发生命周期。系统的核心价值主张是减少需求收集、架构设计、代码生成和文档编写中的手动工作，实现更快、质量一致的MVP交付。

### 核心执行路径

系统通过三个主要执行路径运行：

1. **项目初始化**：创建带有基础制品的新项目
2. **开发迭代**：通过顺序管道阶段执行完整的开发周期
3. **变更请求分析**：分析对现有项目的修改并启动针对性开发

每个路径遵循一致的模式：用户输入 → AI分析 → 制品生成 → 人机循环验证 → 持久化 → 状态更新。

### 关键流程节点

系统的工作流围绕七个关键流程节点展开：

1. **创意捕获**：将用户输入转化为结构化需求
2. **PRD生成**：创建正式的产品需求文档
3. **设计规范**：生成技术架构文档
4. **实现规划**：将设计分解为可执行任务
5. **代码生成**：生成实际的源代码制品
6. **质量保证**：根据需求和最佳实践验证代码
7. **交付**：打包并交付完成的制品和全面文档

### 流程协调机制

系统采用复杂的协调框架：

- **管道执行器**：中央控制器，协调阶段执行，管理工作区继承，处理重试逻辑
- **阶段特征**：所有管道阶段的统一接口，实现即插即用扩展性
- **交互后端**：抽象UI关注点，使CLI和GUI实现能够共享相同的核心逻辑
- **工具支持领域**：为AI智能体提供安全的、会话范围的工具，与系统状态、文件系统和外部服务交互
- **事件总线**：管道组件和UI之间实时通信的发布-订阅系统

## 2. 主要工作流

### 核心业务流程详情

#### 开发迭代流程

主要工作流通过七个顺序阶段执行完整的开发周期：

1. **创意阶段**：捕获用户输入并生成`idea.md`文档，包含问题描述、目标用户、核心功能、成功标准和约束条件。
2. **PRD阶段**：将创意转换为正式的产品需求文档，包含用户故事、功能/非功能需求、UI/UX规范和数据/API需求。
3. **设计阶段**：将PRD转换为技术设计文档，包含架构概述、组件设计、数据模型、API规范、技术栈建议、安全考虑和部署架构。
4. **计划阶段**：创建实现计划，包含任务分解、文件结构、实现顺序、关键算法、测试策略、风险缓解和完成定义。
5. **编码阶段**：基于实现计划生成源代码文件，使用两阶段方法：先生成文件结构，然后为每个文件生成代码。
6. **检查阶段**：通过使用LLM驱动的审查分析生成的代码与需求，执行自动化质量保证，生成带有通过/不通过结果的`check_report.md`。
7. **交付阶段**：生成全面的`delivery_report.md`总结迭代，并将所有生成的代码文件复制到项目根目录。

每个阶段遵循一致的模式：加载配置 → 加载先前置件 → 使用LLM生成内容 → 将制品写入文件系统 → 向用户提供反馈。

#### 关键技术流程描述

**创意阶段实现**：系统使用提示工程方法，指示LLM生成具有特定部分的结构化markdown文档。提示包括用户的原始请求作为上下文，并生成带有识别迭代编号和标题的元数据标题的内容。

**PRD阶段实现**：PRD阶段在创意文档基础上构建，添加正式需求工程。LLM被指示以"作为[用户]，我希望[功能]以便[受益]"的格式生成用户故事，并区分功能和非功能需求。系统在保存前验证生成的文档包含所有必需部分。

**设计阶段实现**：此阶段将需求转化为技术规范。LLM被指示创建架构图（文本形式）、组件职责、数据模型、API端点和技术栈建议。系统通过除非明确需要否则不鼓励微服务、缓存和队列来强制架构简单性。

**编码阶段实现**：编码阶段采用复杂的两阶段生成过程：
1. **结构分析**：首先，LLM生成完整的文件结构，列出所有要创建的文件及其路径和描述
2. **代码生成**：对于每个识别的文件，LLM使用包含文件路径、描述和项目上下文的定制提示生成完整的、功能性的代码

系统包含强大的解析逻辑以处理各种LLM响应格式和后备策略（例如，如果文件列表解析失败，则回退到生成单个main.rs文件）。

**质量保证实现**：检查阶段使用提示执行轻量级质量验证，要求LLM从七个维度审查代码：总体评估、代码质量、功能性、错误处理、安全性、性能和建议。系统在响应中搜索"通过"或"批准"关键词以确定结果，但无论结果如何管道都会继续，遵循故障安全设计理念。

**交付实现**：交付阶段聚合先前阶段的所有制品，并使用LLM按照PR描述惯例生成专业的交付报告。然后递归地将所有生成的代码文件从工作区复制到项目根目录，同时排除`.git`、`node_modules`和`target`目录等系统制品。

#### 流程执行顺序和依赖关系

开发迭代流程遵循严格的顺序依赖链：

```
创意 → PRD → 设计 → 计划 → 编码 → 检查 → 交付
```

每个阶段依赖于前一阶段的输出：
- PRD需要创意文档作为上下文
- 设计需要PRD文档作为输入
- 计划需要设计文档作为输入
- 编码需要计划文档作为输入
- 检查需要生成的代码和计划文档
- 交付需要所有先前置件

系统采用"快速失败"方法，如果任何阶段无法生成其制品，整个迭代失败。但是，检查阶段被设计为非阻塞质量门 - 它报告问题但允许管道继续。

#### 输入/输出数据流

**输入数据流**：
- **用户输入**：期望功能的自然语言描述（通过CLI或GUI提供）
- **项目上下文**：来自`project.json`的项目元数据（技术栈、语言、类型）
- **先前置件**：先前阶段的markdown文档（idea.md、prd.md、design.md、plan.md）
- **配置**：来自`config.toml`或环境变量的LLM设置

**输出数据流**：
- **制品**：markdown文档（idea.md、prd.md、design.md、plan.md、check_report.md、delivery_report.md）
- **代码文件**：在工作区目录中生成的源代码文件
- **摘要文件**：`.generated_files.txt`列出所有生成的文件及行数
- **状态更新**：更新带有状态和制品路径的`iteration.json`和`project.json`文件

数据流是单向和顺序的，每个阶段消耗前一阶段的输出并为下一阶段生成输出。

## 3. 流程协调与控制

### 多模块协调机制

系统采用基于策略和观察者模式的复杂多模块协调架构：

**管道执行器（控制器）**：`IterationExecutor`作为协调所有工作流执行的中央控制器。它：
- 从持久化加载项目和迭代上下文
- 使用继承逻辑准备工作区（完全、部分或无）
- 使用Stage特征接口顺序执行阶段
- 管理重试逻辑（每个阶段最多3次尝试）
- 处理反馈循环（每个阶段最多5次修订）
- 成功完成后更新项目状态

**阶段特征（策略模式）**：所有管道阶段实现`Stage`特征，定义统一接口：
```rust
pub trait Stage: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    async fn execute(&self, ctx: &PipelineContext, interaction: Arc<dyn InteractiveBackend>) -> StageResult;
    async fn execute_with_feedback(&self, ctx: &PipelineContext, interaction: Arc<dyn InteractiveBackend>, feedback: &str) -> StageResult;
}
```

这使执行器能够统一处理所有阶段，无论其特定实现如何，轻松扩展新阶段。

**交互后端（策略模式）**：`InteractiveBackend`特征抽象用户交互，允许不同的UI实现（CLI和Tauri GUI）提供相同接口：
```rust
pub trait InteractiveBackend {
    async fn show_message(&self, level: MessageLevel, content: String);
    async fn request_input(&self, prompt: &str, options: Vec<InputOption>, initial_content: Option<String>) -> Result<InputResponse>;
    async fn show_progress(&self, task_id: String, progress: ProgressInfo);
    fn event_bus(&self) -> Arc<EventBus>;
}
```

这使得核心引擎能够与不同的UI后端协同工作而无需修改。

**工具支持领域（依赖注入）**：AI智能体通过一组实现`Tool`特征的工具与系统交互。这些工具被注入到智能体执行上下文中，提供对系统功能的安全访问：
- 文件操作（`ListFilesTool`、`ReadFileTool`、`WriteFileTool`）
- 数据操作（`CreateRequirementTool`、`AddFeatureTool`、`CreateTaskTool`）
- 控制操作（`ProvideFeedbackTool`、`RequestHumanReviewTool`）
- 制品操作（`SavePrdDocTool`、`SaveDesignDocTool`）

### 状态管理与同步

系统实现了围绕两个核心实体的强大状态管理系统：

**项目状态**：由`Project`实体和`ProjectStore`管理：
- 包含项目元数据（名称、技术栈、语言）
- 跟踪迭代历史和当前迭代
- 在任何修改时自动更新`updated_at`时间戳
- 使用不可变ID生成（`proj-{timestamp}`）

**迭代状态**：由`Iteration`实体和`IterationStore`管理：
- 跟踪五阶段生命周期：idea → prd → design → plan → delivery
- 维护状态：Draft、Running、Paused、Completed、Failed
- 记录完成的阶段和当前阶段
- 支持继承模式：None、Full、Partial
- 自动生成唯一ID（`iter-{iteration_number}-{timestamp}`）

状态同步通过以下方式实现：
1. **基于文件的持久化**：所有状态作为JSON文件持久化在`.cowork-v2`目录中
2. **原子写入**：文件操作使用`fs::write`进行原子更新
3. **时间戳跟踪**：所有实体包含`created_at`和`updated_at`字段
4. **版本化制品**：每个迭代有自己的隔离工作区和制品目录

### 数据传递与共享

组件间的数据流通过直接传递和共享存储的组合实现：

**直接传递**： 
- `PipelineContext`在阶段之间传递项目、迭代和工作区路径
- 阶段执行方法接收上下文作为参数
- LLM提示通过将上下文与先前置件结合构建

**共享存储**：
- **项目存储**：持久化带有项目元数据和迭代历史的`project.json`
- **迭代存储**：持久化带有迭代状态和制品路径的`iteration.json`
- **制品目录**：存储markdown文档（idea.md、prd.md、design.md等）
- **工作区目录**：存储生成的代码文件
- **内存存储**：持久化项目级决策和会话级见解

系统使用分层存储结构：
```
.cowork-v2/
├── project.json
├── sessions/
│   ├── <iteration_id>/
│   │   ├── artifacts/
│   │   │   ├── idea.md
│   │   │   ├── prd.md
│   │   │   ├── design.md
│   │   │   ├── plan.md
│   │   │   ├── check_report.md
│   │   │   └── delivery_report.md
│   │   ├── workspace/
│   │   │   ├── src/
│   │   │   │   └── main.rs
│   │   │   └── ...
│   │   └── iteration.json
└── ...
```

### 执行控制与调度

系统实现了复杂的执行控制机制：

**阶段执行控制**：
- **顺序执行**：阶段按固定顺序执行（创意 → PRD → 设计 → 计划 → 编码 → 检查 → 交付）
- **关键阶段检测**：`is_critical_stage()`函数识别需要人工确认的阶段（创意、PRD、设计、计划、编码）
- **人机循环（HITL）**：在关键阶段，系统暂停并通过`request_input()`请求用户反馈
- **重试逻辑**：每个阶段可以重试最多3次，可提供反馈
- **修订循环**：用户可以请求每个阶段最多5次修订

**调度机制**：
- **自动调度**：`IterationExecutor`根据迭代状态自动调度阶段
- **恢复能力**：用户可以使用`resume_stage`参数从任何阶段恢复暂停的迭代
- **基于继承的调度**：对于进化迭代，系统根据变更范围分析确定起始阶段：
  ```rust
  fn analyze_change_scope(description: &str) -> String {
      if description.contains("architecture") || description.contains("重构") { "idea" }
      else if description.contains("requirement") || description.contains("需求") { "prd" }
      else if description.contains("design") || description.contains("设计") { "design" }
      else { "plan" }
  }
  ```

**并发控制**：
- **全局速率限制器**：将LLM API调用限制为最多1个并发请求，请求间有2秒延迟
- **会话隔离**：每个迭代有自己的工作区和制品目录
- **线程安全操作**：对共享所有权使用`Arc`，对关键区域使用`Mutex`

## 4. 异常处理与恢复

### 错误检测与处理

系统在多个层面实现全面的错误检测和处理：

**LLM交互错误**：
- LLM客户端创建失败（无效的API密钥、不可达的端点）
- 生成失败（超时、超出令牌限制）
- 内容生成期间的流式错误
- 响应解析失败（空或格式错误的响应）

**文件系统错误**：
- 目录创建失败
- 文件读/写权限错误
- 路径验证失败（安全违规）
- 磁盘空间耗尽

**数据验证错误**：
- 工具调用中缺少所需参数
- 工具输入中的JSON模式无效
- 持久化文件损坏
- 项目和迭代之间的状态不一致

**错误处理实现**：
```rust
// 来自CodingStage的示例
let mut stream = match llm.generate_content(request, false).await {
    Ok(resp) => resp,
    Err(e) => {
        return StageResult::Failed(format!("LLM生成失败: {}", e));
    }
};
```

所有错误都被捕获并转换为带有描述性消息的`StageResult::Failed(String)`。系统在整个代码库中使用`anyhow::Result`进行上下文丰富的错误传播。

### 异常恢复机制

系统实现了多种恢复机制：

**重试逻辑**：
- 每个阶段可以自动重试最多3次
- 成功执行时重置重试计数器
- 失败尝试与错误详情一起记录

**人机循环恢复**：
- 当智能体遇到错误时，它可以调用`RequestHumanReviewTool`将问题升级到人工干预
- 用户可以在HITL交互期间提供反馈，用于重新生成制品
- 系统支持迭代优化，每个阶段最多5次修订

**后备策略**：
- **代码生成后备**：如果在编码期间文件列表解析失败，系统回退到生成单个`main.rs`文件
- **制品后备**：如果所需制品（例如PRD）不存在，系统回退使用迭代描述
- **配置后备**：LLM配置从`config.toml` → 可执行目录 → 环境变量加载

**优雅降级**：
- 质量检查（检查阶段）是非阻塞的 - 即使检测到质量问题，管道也会继续
- 即使编码期间单个文件生成失败，系统也会继续处理

### 容错策略设计

系统采用多层容错策略：

**1. 隔离**：
- 每个迭代有自己的隔离工作区和制品目录
- 会话范围工具防止跨会话污染
- 文件系统操作被限制在当前工作目录内

**2. 冗余**：
- 所有制在生成后立即持久化到磁盘
- 项目和迭代状态在每次主要操作后保存
- 配置有多个后备来源

**3. 监控**：
- 事件总线为所有重要操作发布`EngineEvent`
- 进度跟踪为长时间运行的操作提供实时反馈
- 错误消息包含上下文（迭代ID、阶段名称、时间戳）

**4. 恢复点**：
- 每个阶段创建持久化制品作为恢复点
- 系统可以使用`resume_stage`参数从任何阶段恢复
- 每个阶段完成后保存迭代状态

### 故障重试与降级

**重试策略**：
- **最大尝试次数**：每个阶段3次重试
- **退避**：无指数退避 - 重试间有固定延迟
- **重置条件**：成功执行时重置重试计数器
- **用户覆盖**：用户可以在重试前手动中止或提供指导

**降级策略**：
- **代码生成**：如果LLM无法生成文件结构，回退到单文件生成
- **制品加载**：如果PRD/设计/计划文件丢失，使用迭代描述作为后备
- **配置**：如果配置文件丢失，回退到环境变量
- **存储**：如果持久化失败，系统继续使用内存状态（虽然不推荐）

**故障影响分析**：
- **阶段故障**：仅当前阶段失败；先前阶段保持完整
- **迭代故障**：迭代被标记为失败，但项目状态保持不变
- **系统故障**：`.cowork-v2`目录保留所有制品，允许手动恢复

## 5. 关键流程实现

### 核心算法流程

**变更范围分析算法**：
```rust
fn analyze_change_scope(description: &str) -> String {
    let desc_lower = description.to_lowercase();
    
    // 架构变更（从创意开始）
    let arch_keywords = ["架构", "architecture", "重构", "rewrite", "重新设计", "redesign"];
    for kw in &arch_keywords {
        if desc_lower.contains(kw) { return "idea".to_string(); }
    }
    
    // 需求变更（从PRD开始）
    let req_keywords = ["需求", "requirement", "功能", "feature", "添加", "add"];
    for kw in &req_keywords {
        if desc_lower.contains(kw) { return "prd".to_string(); }
    }
    
    // 设计变更（从设计开始）
    let design_keywords = ["设计", "design", "数据库", "database", "接口", "api"];
    for kw in &design_keywords {
        if desc_lower.contains(kw) { return "design".to_string(); }
    }
    
    // 默认：仅代码变更（从计划开始）
    "plan".to_string()
}
```

该算法通过基于变更描述关键词的语义分析自动确定进化迭代的适当起始阶段，实现智能继承。

**文件结构生成算法**：
```rust
fn parse_file_list(structure_text: &str) -> Vec<String> {
    let mut files = Vec::new();
    
    // 查找FILES:部分
    if let Some(start) = structure_text.find("FILES:") {
        let rest = &structure_text[start + 6..];
        
        // 解析以-开头的行
        for line in rest.lines() {
            if let Some(path) = line.strip_prefix("- ") {
                if let Some(file_path) = path.split(':').next() {
                    files.push(file_path.trim().to_string());
                }
            }
        }
    }
    
    // 后备：从代码块中提取
    if files.is_empty() {
        // 从``` files块中提取
        let re = regex::Regex::new(r"```(?:\w+)?\n(.*?)(?:\n```|$)").unwrap();
        for cap in re.captures_iter(structure_text) {
            for line in cap[1].lines() {
                if let Some(file_path) = line.strip_prefix("- ") {
                    files.push(file_path.trim().to_string());
                }
            }
        }
    }
    
    files
}
```

该算法通过支持多种格式（项目点、代码块）和提供后备策略来处理非确定性LLM输出。

### 数据处理管道

**制品生成管道**：
```
用户输入 → 创意阶段 → PRD阶段 → 设计阶段 → 计划阶段 → 编码阶段 → 检查阶段 → 交付阶段
```

每个阶段通过一致的管道处理数据：
1. **加载配置**：从配置文件或环境检索LLM设置
2. **加载上下文**：检索先前置件（如果可用）
3. **构建提示**：将上下文与阶段特定指令结合
4. **生成内容**：调用带有流式响应的LLM
5. **提取内容**：解析LLM响应（处理流式、代码块）
6. **验证输出**：检查必需部分、格式、完整性
7. **持久化制品**：写入文件系统并带有元数据标题
8. **提供反馈**：通知用户完成

**内存上下文管道**：
```
LLM智能体请求 → QueryMemoryIndexTool → LoadMemoryDetailTool → 注入到提示 → 生成输出 → 更新内存上下文
```

该管道通过从项目级和会话级内存存储检索历史决策和模式，实现上下文感知的AI辅助。

### 业务规则执行

**简单性强制规则**：
1. **架构简单性**： 
   - 优先选择单体架构而非微服务
   - 使用SQLite/JSON而非复杂数据库
   - 使用内置工具而非外部依赖
   - 将组件限制为最多2-4个

2. **需求过滤**：
   - 拒绝非核心需求（性能、测试、CI/CD、监控）
   - 关注最小可行产品（MVP）质量门
   - 非核心功能需要明确用户请求

3. **代码生成规则**：
   - 不过度工程
   - 不过早优化
   - 除非明确要求否则不编写测试
   - 不编写服务器或长时间运行进程

**继承规则**：
1. **无**：全新开始（起源迭代）
2. **完全**：从基础迭代复制所有代码
3. **部分**：仅复制制品和配置文件（非生成的代码）

**质量门规则**：
1. **检查阶段**： 
   - 验证功能覆盖
   - 验证任务依赖
   - 检查文件存在性
   - 不检查测试、代码检查、详细代码质量、性能

### 技术实现细节

**LLM集成**：
- 使用带有自定义基础URL的`adk-rust` OpenAIClient
- 实现带有信号量的全局速率限制器（最多1个并发请求）
- 强制请求间有2秒延迟（<30次调用/分钟）
- 通过`LlmProvider`特征支持多个LLM提供商

**文件系统安全性**：
```rust
fn validate_path_security(path: &str) -> Result<PathBuf, String> {
    // 规则1：拒绝绝对路径
    if path_obj.is_absolute() { return Err("不允许绝对路径"); }
    
    // 规则2：拒绝父目录访问（..）
    if path.contains("..") { return Err("不允许父目录访问"); }
    
    // 规则3：规范化并验证在当前目录内
    let full_path = current_dir.join(path);
    let canonical_path = full_path.canonicalize()?;
    let normalized_current_dir = current_dir.canonicalize()?;
    
    if !canonical_path.starts_with(&normalized_current_dir) {
        return Err("路径逃离当前目录");
    }
    
    Ok(canonical_path)
}
```

此安全模型防止目录遍历攻击，确保智能体无法访问其指定工作区之外的文件。

**状态管理**：
- 所有状态作为JSON文件持久化在`.cowork-v2`目录中
- 使用`serde`进行序列化/反序列化
- 为幂等读操作实现`Default`特征
- 使用`chrono::Utc::now()`进行时间戳生成

**并发模型**：
- 使用`async/await`完全异步
- 使用`tokio`作为异步运行时
- 对共享所有权使用`Arc`
- 对关键区域使用`Mutex`
- 使用`broadcast`通道作为事件总线

**错误处理**：
- 使用`anyhow::Result`进行上下文丰富的错误传播
- 将存储错误转换为`AdkError::Tool`变体
- 提供带有上下文的描述性错误消息
- 对非关键失败实现优雅降级

系统的技术实现展示了一个成熟的、生产就绪的架构，在自动化与人工监督之间取得平衡，利用AI处理重复性任务同时保持对关键决策的人工控制。