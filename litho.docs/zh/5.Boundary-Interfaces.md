# 系统边界接口文档

本文档描述系统的外部调用接口，包括 CLI 命令、API 端点、配置参数和其他边界机制。

## 命令行界面（CLI）

### cowork iter

**描述**：创建并执行新迭代。支持创世（新建）和演进（基于先前迭代）两种类型。演进模式需要 --base 参数，并使用继承模式确定知识转移策略。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `title` (String)：必需 - 迭代标题（必需）
- `description` (Option<String>)：可选 - 迭代的详细描述
- `base` (Option<String>)：可选 - 要继承的基线迭代 ID（用于演进迭代）
- `inherit` (String)：可选 - 继承模式：none、full 或 partial（默认：`full`）

**选项**：

- `config, c`(String)：可选 - 配置文件路径（默认：config.toml）
- `verbose, v`(bool)：可选 - 启用详细日志（debug 级别）（默认：`false`）

**使用示例**：

```bash
cowork iter "Implement user authentication"
```

```bash
cowork iter "Add payment gateway" --base ITER-123 --inherit partial
```

```bash
cowork iter "Fix bug #42" --description "Resolve null pointer exception" --inherit none
```

### cowork list

**描述**：列出所有迭代，支持可选过滤。显示状态、当前阶段和迭代 ID。默认显示活动迭代；使用 --all 包含已完成的。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `all` (bool)：可选 - 显示所有迭代，包括已完成的

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork list
```

```bash
cowork list --all
```

### cowork show

**描述**：显示迭代的详细信息，包括状态、时间戳、基线迭代、继承模式、阶段进度和工件完成状态。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `iteration_id` (Option<String>)：可选 - 迭代 ID（未指定时默认为当前迭代）

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork show ITER-abc123
```

```bash
cowork show
```

### cowork continue

**描述**：恢复暂停迭代的执行。错误或 HITL（人在回路）请求需要用户输入时自动暂停。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `iteration_id` (Option<String>)：可选 - 迭代 ID（未指定时默认为第一个暂停的迭代）

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork continue
```

```bash
cowork continue ITER-abc123
```

### cowork init

**描述**：在当前目录初始化新项目。创建 .cowork-v2 目录结构，包含项目元数据和迭代文件夹。必须在创建迭代之前运行。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `name` (Option<String>)：可选 - 项目名称（默认为当前目录名称）

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork init
```

```bash
cowork init --name my-awesome-project
```

### cowork status

**描述**：显示项目状态，包括创建日期、当前迭代和统计信息（已完成的、运行中的、暂停的、失败的迭代数量）。

**源文件**：`crates/cowork-cli/src/main.rs`

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork status
```

### cowork delete

**描述**：按 ID 删除迭代。显示迭代详情，并在移除前需要 'y' 确认。更新项目元数据以从列表中移除迭代。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `iteration_id` (String)：必需 - 要删除的迭代 ID

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork delete ITER-abc123
```

### cowork regenerate-knowledge

**描述**：为已完成的迭代重新生成知识。重新分析工件（idea、PRD、design、plan）并为项目内存创建更新的知识条目。仅适用于已完成的迭代。

**源文件**：`crates/cowork-cli/src/main.rs`

**参数**：

- `iteration_id` (String)：必需 - 迭代 ID

**选项**：

- `config, c`(String)：可选 - 配置文件路径
- `verbose, v`(bool)：可选 - 启用详细日志（默认：`false`）

**使用示例**：

```bash
cowork regenerate-knowledge ITER-abc123
```

## API 接口

### POST 通过 config.toml 中的 api_base_url 或 LLM_API_BASE_URL 环境变量配置

**描述**：OpenAI 兼容的 LLM API 端点配置。系统用于生成代码、文档和架构设计。支持自定义基础 URL 以兼容各种 LLM 提供商（OpenAI、Azure、本地实例）。实现自动限流，最大 1 个并发请求和 2 秒延迟，以保持每分钟 30 次调用配额。

**源文件**：`crates/cowork-core/src/llm/config.rs`

**请求格式**：JSON（OpenAI 聊天补全格式，由 adk-rust 客户端内部处理）

**响应格式**：JSON（OpenAI 补全格式）

**认证**：通过 config.toml 或环境变量（LLM_API_KEY）的 API 密钥

### RPC 命令 tauri://localhost（内部 IPC）

**描述**：Tauri 桌面应用程序中 React 前端和 Rust 后端之间的 RPC 接口。提供项目生命周期管理、迭代执行、文件操作和实时事件流访问。命令通过 tauri::Command 暴露，使用 @tauri-apps/api/core 从 JavaScript 调用。

**源文件**：`crates/cowork-gui/src-tauri/src/lib.rs`

**请求格式**：JSON（通过 Tauri's invoke 系统序列化）

**响应格式**：JSON（Result<T, String> 模式）

**认证**：无（Tauri IPC）

## 路由

### projects

**描述**：主项目仪表板，显示注册项目列表，带搜索和过滤功能。显示项目元数据、最后打开时间戳和快速操作。

**源文件**：`crates/cowork-gui/src/App.jsx`

### iterations

**描述**：当前项目的迭代列表视图。显示所有迭代，带状态指示器、阶段进度和继承关系。支持选择单个迭代用于聊天/工件查看。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `project_id` (String)：项目上下文（从活动工作区隐含）

### chat

**描述**：所选迭代的聊天界面。显示智能体消息、用户输入、工具调用和思考过程。支持实时流式传输和工件确认工作流。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `iteration_id` (String)：上下文迭代 ID

### artifacts

**描述**：工件查看器，以渲染的 markdown 格式显示生成的文档（idea.md、prd.md、design.md、plan.md）。支持工件类型之间的选项卡导航。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `iteration_id` (String)：迭代 ID
- `active_tab` (String)：活动选项卡（idea/requirements/design/plan）

### code

**描述**：代码编辑器界面，显示当前迭代生成的源文件。显示文件树结构和基于 Monaco 的编辑器，用于语法高亮的代码查看和编辑。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `iteration_id` (String)：迭代 ID
- `current_file` (String)：当前选择的文件路径

### run

**描述**：用于执行和监控生成应用程序的运行器面板。提供启动/停止开发服务器、查看运行时日志和在浏览器中打开实时预览的控件。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `iteration_id` (String)：迭代 ID

### execution-memory

**描述**：内存面板，显示迭代执行期间收集的会话特定内存。包含见解、决策和上下文信息，带全文搜索功能。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `session_id` (String)：会话/迭代 ID

### project-knowledge

**描述**：知识面板，显示跨所有迭代累积的项目级知识。包括 PRD 摘要、架构决策和组织的技术约束，按迭代组织。

**源文件**：`crates/cowork-gui/src/App.jsx`

**参数**：

- `project_id` (String)：项目 ID

## 集成建议

### CLI 自动化

用于自动化流程和 CI/CD 的 CLI 集成。cowork CLI 可以集成到自动化构建流程中，以根据自然语言描述生成样板代码、文档和初始项目结构。

**示例代码**：

```bash
# Shell script integration example
#!/bin/bash
set -e

export LLM_API_KEY="${LLM_API_KEY}"
export LLM_MODEL_NAME="gpt-4"

cd /workspace

# Initialize project if not exists
if [ ! -d ".cowork-v2" ]; then
    cowork init --name $(basename $(pwd))
fi

# Create and execute iteration from requirements
cowork iter "Implement OAuth2 authentication" \
    --description "Add Google and GitHub OAuth providers with JWT token management" \
    --inherit full

# Check status for CI/CD validation
if cowork status | grep -q "Failed"; then
    echo "Iteration failed"
    exit 1
fi
```

**最佳实践**：

- 对缺陷修复和小增强使用 'inherit partial' 以保留相关上下文同时避免污染
- 在首次迭代前始终运行 'cowork init' 以建立正确的 .cowork-v2 目录结构
- 在初始设置期间使用详细标志（-v）诊断 LLM 配置问题
- 为容器化部署设置 LLM_API_KEY 和 LLM_MODEL_NAME 环境变量
- 使用与功能名称匹配的描述性标题创建迭代，以获得更好的知识索引
- 恢复暂停工作时使用 'cowork continue' 而不是创建新迭代

### LLM 配置

LLM 提供商配置集成。配置 Cowork Forge 以与各种 OpenAI 兼容的 LLM 提供商配合工作，包括 OpenAI、Azure OpenAI、通过 LocalAI/Ollama 的本地模型或自定义端点。

**示例代码**：

```bash
# config.toml
[llm]
api_base_url = "https://api.openai.com/v1"
api_key = "${LLM_API_KEY}"  # Use env var substitution
model_name = "gpt-4"

# Or for local development with Ollama:
# api_base_url = "http://localhost:11434/v1"
# model_name = "codellama"

# Environment setup
export LLM_API_KEY="sk-your-key-here"
export LLM_API_BASE_URL="https://api.openai.com/v1"
export LLM_MODEL_NAME="gpt-4"
```

**最佳实践**：

- 将 config.toml 提交到版本控制，包含 API 基础 URL 但排除 API 密钥（使用环境变量）
- 生产部署中使用环境变量处理敏感凭证
- 为共享 LLM 端点显式配置限流以避免配额耗尽
- 通过设置 api_base_url 使用本地 LLM 端点（例如 LocalAI、Ollama）用于气隙环境
- 通过详细日志监控 API 使用情况以优化令牌消耗

### 前端开发

用于使用基于 Tauri 的 GUI 架构构建自定义前端接口的 JavaScript/TypeScript 集成。使用 invoke 进行命令，listen 进行后端事件。

**示例代码**：

```javascript
import { invoke } from '@tauri-apps/api/core';
import { listen } from '@tauri-apps/api/event';

// Initialize project and workspace
async function initializeProject(workspacePath) {
  await invoke('set_workspace', { workspace_path: workspacePath });
  
  // Register event listeners
  await listen('agent_event', (event) => {
    const { content, agent_name, message_type } = event.payload;
    updateChatUI(content, agent_name, message_type);
  });
  
  await listen('input_request', (event) => {
    const [requestId, prompt, options] = event.payload;
    showInputModal(requestId, prompt, options);
  });
}

// Create and execute iteration
async function createIteration(title, description) {
  const request = {
    title,
    description,
    base_iteration_id: null,
    inheritance: 'none'
  };
  
  const iteration = await invoke('gui_create_iteration', { request });
  await invoke('gui_execute_iteration', { iterationId: iteration.id });
  return iteration;
}
```

**最佳实践**：

- 从项目管理器打开项目时使用 --workspace 参数以隔离上下文
- 为 'iteration_completed' 和 'iteration_failed' 实现事件监听器以触发 UI 刷新
- 考虑超时处理 input_request 事件（默认 3000 秒）
- 使用 project_loaded 事件在切换项目时重置 UI 状态
- 为 Tauri 事件监听器实现适当的清理以防止内存泄漏

### 开发工作流

演进迭代模式集成。实现演进开发工作流，其中每个迭代在前一工作的基础上构建，带有受控的知识继承。对维护项目连续性和避免上下文丢失至关重要。

**示例代码**：

```javascript
// Evolution workflow example
// 1. Genesis iteration for initial foundation
const genesis = await invoke('gui_create_iteration', {
  request: {
    title: "Initial API Foundation",
    description: "Set up Express server with basic routing and middleware",
    base_iteration_id: null,
    inheritance: "none"
  }
});

// 2. Evolution iteration inheriting full context
const evolution = await invoke('gui_create_iteration', {
  request: {
    title: "Add User Authentication",
    description: "Implement JWT-based auth middleware",
    base_iteration_id: genesis.id,
    inheritance: "full"
  }
});

// 3. Partial inheritance for isolated feature
const feature = await invoke('gui_create_iteration', {
  request: {
    title: "Email Notification Service",
    description: "Add SendGrid integration (isolated from auth)",
    base_iteration_id: evolution.id,
    inheritance: "partial"
  }
});
```

**最佳实践**：

- 对实验性探索和全新功能使用 'none' 继承
- 对跨迭代一致的架构模式使用 'full' 继承
- 在编码阶段使用 HITL（人在回路）实现反馈循环进行代码审查
- 重大架构变更后利用知识重新生成来更新项目内存
- 将迭代与语义版本对齐的描述性命名约定结合使用

---

**分析置信度**：8.5/10