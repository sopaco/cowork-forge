# Storage Domain Documentation

## Overview

The Storage Domain in Cowork Forge is the foundational infrastructure layer responsible for managing all persistent data within the system. It implements a session-scoped hierarchical file system structure under the `.cowork/` directory, ensuring complete isolation and traceability of every development iteration. This domain provides the physical storage layer upon which all other components rely, enabling the system's core capabilities of state persistence, artifact management, session inheritance, and workflow continuity.

The Storage Domain is not merely a file system wrapper—it is a carefully architected persistence layer that enforces data integrity, supports complex workflows like modification and resumption, and enables the system's AI agents to operate with full context across sessions. Its design follows the principle of "session isolation," where each development cycle (initiated via `cowork run`, `cowork modify`, or `cowork resume`) operates within its own dedicated directory structure, preventing cross-contamination of requirements, designs, code, and feedback.

## Core Architecture and Directory Structure

The Storage Domain enforces a strict, hierarchical directory structure that organizes all project data into logical, session-scoped compartments. This structure ensures data isolation, simplifies debugging, and enables powerful session inheritance patterns.

### Root Directory Structure

All data is contained within a single `.cowork/` directory located at the project root:

```
.cowork/
├── index.json                  # Project-wide metadata and session history
├── sessions/                   # Root for all session directories
│   ├── <session_id_1>/         # Unique session directory (e.g., "dev-001")
│   │   ├── artifacts/          # Human-readable documentation artifacts
│   │   ├── state/              # Structured JSON state files
│   │   ├── patch/              # Metadata for modification sessions
│   │   └── logs/               # Execution logs (optional)
│   └── <session_id_2>/
└── ... (other sessions)
```

### Session Subdirectory Structure

Each session has a dedicated subdirectory under `sessions/<session_id>/` with four key subdirectories:

| Directory | Purpose | File Types | Importance |
|----------|---------|------------|------------|
| `artifacts/` | Human-readable documentation generated by AI agents | `.md` files (idea.md, prd.md, design.md, delivery_report.md) | High — Primary output artifacts |
| `state/` | Structured, machine-readable state of the development process | `.json` files (requirements.json, design_spec.json, implementation_plan.json, etc.) | Critical — Core state for AI agent context |
| `patch/` | Metadata for modification sessions only | `metadata.json` | Medium — Enables change tracking |
| `logs/` | Execution logs and diagnostics | `.log` files (optional) | Low — Diagnostic aid |

This structure is created automatically and atomically by the `get_session_dir()` function, which ensures all necessary subdirectories exist before any file operations occur.

### Project Index (`index.json`)

The `index.json` file at the root of `.cowork/` serves as the project's central metadata registry:

```json
{
  "project_name": "MyApp",
  "created_at": "2024-06-15T10:30:00Z",
  "sessions": [
    {
      "session_id": "dev-001",
      "session_type": "new",
      "status": "completed",
      "created_at": "2024-06-15T10:30:00Z",
      "completed_at": "2024-06-15T11:45:00Z"
    },
    {
      "session_id": "mod-002",
      "session_type": "modify",
      "status": "in_progress",
      "created_at": "2024-06-16T09:00:00Z",
      "base_session_id": "dev-001"
    }
  ],
  "latest_successful_session": "dev-001"
}
```

The index tracks:
- Project name and creation timestamp
- All session records with their IDs, types, statuses, and timestamps
- The latest successfully completed session, enabling `cowork continue` to resume from the last good state

## Key Functional Components

### 1. Session Lifecycle Management

The Storage Domain provides a complete lifecycle management system for sessions, from creation to completion.

#### Session Creation and Initialization

- **`init_project_index()`**: Creates the `.cowork/` directory and initializes `index.json` when a project is first created (`cowork new`).
- **`get_session_dir()`**: Creates a new session directory with all required subdirectories (`artifacts/`, `state/`, etc.) and returns the path. This function is called before any session-specific file operations.
- **`generate_id(prefix, counter)`**: Generates deterministic, human-readable session IDs (e.g., `dev-001`, `mod-002`) based on a prefix and counter, ensuring uniqueness and traceability.

#### Session Status Tracking

- **`mark_session_completed(session_id)`**: Updates the project index to mark a session as `Completed`, sets its `completed_at` timestamp, and updates `latest_successful_session`.
- **`mark_session_failed(session_id)`**: Marks a session as `Failed` in the index, allowing the system to avoid resuming from broken states.
- **`is_project_initialized()`**: Checks for the existence of `index.json` to determine if a project has been initialized.

These functions ensure that the system maintains a reliable audit trail of all development activities and can intelligently resume workflows.

### 2. State Persistence and Retrieval

The domain provides a comprehensive set of functions for saving and loading structured state data using JSON serialization via `serde_json`.

#### State Files (in `state/`)

| File | Type | Purpose | Default on Missing |
|------|------|---------|-------------------|
| `requirements.json` | `Requirements` | Core feature and requirement definitions | `Requirements::new()` |
| `feature_list.json` | `FeatureList` | List of features with status tracking | `FeatureList::new()` |
| `design_spec.json` | `DesignSpec` | Architecture and component design | `DesignSpec::new()` |
| `implementation_plan.json` | `ImplementationPlan` | Task breakdown and assignment | `ImplementationPlan::new()` |
| `code_metadata.json` | `CodeMetadata` | List of generated code files and their metadata | `CodeMetadata::new()` |
| `meta.json` | `SessionMeta` | Session metadata (type, description, base session) | None (optional) |
| `feedback.json` | `FeedbackHistory` | Human feedback history | `FeedbackHistory::new()` |

**Key Design Principle: Idempotent Reads**

All `load_*` functions return default empty structures (e.g., `Requirements::new()`) if the file does not exist. This is a critical design decision that enables **idempotent reads**:

```rust
pub fn load_requirements(session_id: &str) -> Result<Requirements> {
    let path = state_path(session_id, "requirements.json")?;
    if !path.exists() {
        return Ok(Requirements::new()); // ← Default empty state
    }
    let content = fs::read_to_string(&path)?;
    let requirements: Requirements = serde_json::from_str(&content)?;
    Ok(requirements)
}
```

This allows AI agents and pipeline stages to safely read state files without prior existence checks. If a file is missing, the system treats it as "empty" rather than "error," enabling seamless workflows where state is incrementally built.

### 3. Artifact Management

Artifacts are human-readable documentation files generated by AI agents during each pipeline stage. These are stored in the `artifacts/` directory and are primarily `.md` files:

| Artifact | Stage | Purpose |
|----------|-------|---------|
| `idea.md` | Idea | Initial project concept and vision |
| `prd.md` | PRD | Product Requirements Document |
| `design.md` | Design | System architecture and component design |
| `delivery_report.md` | Delivery | Final summary of changes, features, and architecture |

The domain provides simple, type-safe functions for saving and loading these files:

```rust
pub fn save_prd_doc(session_id: &str, content: &str) -> Result<()> { ... }
pub fn load_idea(session_id: &str) -> Result<String> { ... }
```

These functions use atomic `fs::write()` operations to ensure data integrity. If a file is missing during a load, it returns an empty string (`""`), consistent with the idempotent design philosophy.

### 4. Session Inheritance (`init_session_from_base`)

The most sophisticated feature of the Storage Domain is **session inheritance**, implemented in `init_session_from_base(new_session_id, base_session_id)`.

This function is the backbone of the `cowork modify` workflow. When a user requests a modification, the system creates a new session that inherits the entire state and artifacts from a base session, while excluding feedback history to avoid bias.

#### What is Copied:
- All state files: `requirements.json`, `design_spec.json`, `implementation_plan.json`, `code_metadata.json`, `meta.json`
- All artifact files: `idea.md`, `prd.md`, `design.md`, `delivery_report.md`

#### What is NOT Copied:
- `feedback.json` — Feedback history is intentionally excluded to ensure the new session starts with a "clean slate" for evaluation.
- Code files in the project root — Only metadata about code files is inherited, not the actual files themselves.

```rust
pub fn init_session_from_base(new_session_id: &str, base_session_id: &str) -> Result<()> {
    let base_dir = get_session_dir(base_session_id)?;
    let new_dir = get_session_dir(new_session_id)?;

    fn copy_if_exists(src: &Path, dst: &Path) -> Result<()> {
        if !src.exists() { return Ok(()); } // Skip if source doesn't exist
        fs::create_dir_all(dst.parent().unwrap())?;
        fs::copy(src, dst)?;
        Ok(())
    }

    // Copy state files
    let state_files = ["requirements.json", "design_spec.json", "implementation_plan.json", "code_metadata.json", "meta.json"];
    for name in state_files {
        let src = base_dir.join("state").join(name);
        let dst = new_dir.join("state").join(name);
        copy_if_exists(&src, &dst)?;
    }

    // Copy artifact files
    let artifact_files = ["idea.md", "prd.md", "design.md", "delivery_report.md"];
    for name in artifact_files {
        let src = base_dir.join("artifacts").join(name);
        let dst = new_dir.join("artifacts").join(name);
        copy_if_exists(&src, &dst)?;
    }

    Ok(())
}
```

This mechanism enables powerful workflows:
- **Modify**: Start a new session with the current requirements and design, then generate a new plan.
- **Revert**: Create a new session from a previous successful state to undo changes.
- **Resume**: Continue a session from a specific point without losing context.

### 5. Feature Status Auto-Update

The Storage Domain includes a sophisticated utility for automatically updating feature status based on task completion:

```rust
pub fn update_feature_status_if_needed(session_id: &str, feature_id: &str) -> Result<()> { ... }
```

This function:
1. Loads the `ImplementationPlan` and `FeatureList`
2. Finds all tasks associated with the given `feature_id`
3. Evaluates their statuses (`Completed`, `InProgress`, `Blocked`)
4. Updates the feature's status accordingly:
   - **Completed**: All tasks are completed
   - **Blocked**: Any task is blocked
   - **InProgress**: Any task is in progress
   - **Pending**: All tasks are pending

This automation ensures that the system's state is always consistent. When an AI agent marks a task as completed, the feature status is automatically updated, providing real-time feedback to both the user and subsequent pipeline stages.

### 6. Change Request and Patch Metadata

For modification workflows, the domain supports `change_request.json` and `patch/metadata.json`:

- **`change_request.json`**: Stores the natural language change request and its AI-generated analysis (scope, risk, affected components).
- **`patch/metadata.json`**: Tracks the specific changes made in a modification session, including file diffs and rationale.

These files enable traceability and auditability of changes, allowing users to understand why a modification was made and what was affected.

## Integration with Other Domains

The Storage Domain is the central data hub for the entire Cowork Forge system. It is consumed by nearly every other domain:

| Domain | Integration Points |
|--------|-------------------|
| **Tool Support Domain** | All tools (`SavePrdDocTool`, `SaveRequirementsTool`, `LoadDesignSpecTool`, etc.) rely on Storage functions to persist and retrieve data. |
| **Pipeline Domain** | The `IterationExecutor` uses `init_session_from_base()` to prepare workspaces for modification flows and uses `load_*` functions to populate agent contexts. |
| **Project Management Domain** | `ProjectStore` and `IterationStore` use Storage to resolve file paths and persist project/iteration entities. |
| **Memory Domain** | While Memory stores long-term decisions, Storage stores session-specific context. The two work in tandem: Memory provides historical patterns, Storage provides current state. |
| **Interaction Domain** | The CLI and GUI use Storage to display session history (`index.json`) and load artifacts for user review. |

## Error Handling and Reliability

The Storage Domain employs robust error handling using the `anyhow` crate to provide rich, contextual error messages:

- All file operations use `.with_context(|| "message")` to attach meaningful context (e.g., "Failed to write requirements.json for session dev-001").
- Missing files are handled gracefully with default values, avoiding cascading failures.
- Directory creation is atomic and recursive (`fs::create_dir_all`), ensuring the structure is always valid.
- All writes use `fs::write()` for atomicity, preventing partial writes.

## Practical Usage Examples

### Example 1: Project Initialization

```bash
$ cowork new myapp
```

1. `init_project_index("myapp")` → Creates `.cowork/` and `index.json`
2. Pipeline executes `IdeaStage` → Generates `idea.md`
3. `save_idea("dev-001", content)` → Saves to `.cowork/sessions/dev-001/artifacts/idea.md`
4. `mark_session_completed("dev-001")` → Updates `index.json`

### Example 2: Modify Workflow

```bash
$ cowork modify "Add user authentication"
```

1. `get_latest_successful_session()` → Returns `dev-001`
2. `init_session_from_base("mod-002", "dev-001")` → Copies state/artifacts from `dev-001` to `mod-002`
3. `save_change_request("mod-002", change_request)` → Persists the natural language request
4. Pipeline executes `ModifyStage` → Analyzes scope and generates new plan
5. `save_implementation_plan("mod-002", new_plan)` → Saves updated task list
6. `update_feature_status_if_needed("mod-002", "auth-001")` → Updates feature status as tasks complete

### Example 3: AI Agent Context Loading

An AI agent in the `DesignStage` needs to know the current requirements:

```rust
let requirements = load_requirements(session_id)?; // ← Returns empty if file missing
let design = DesignSpec::generate_from_requirements(requirements);
save_design_spec(session_id, &design)?; // ← Atomic write
```

The agent does not need to check if `requirements.json` exists—it simply reads it. The Storage Domain ensures the system behaves predictably whether the file is present or not.

## Conclusion

The Storage Domain in Cowork Forge is a masterclass in practical, domain-driven persistence design. It transforms a simple file system into a powerful, reliable, and intelligent state management system that enables the entire AI-assisted development workflow.

Its key strengths are:
- **Session Isolation**: Every iteration is completely isolated, enabling safe experimentation.
- **Idempotent State**: Default empty structures eliminate error-prone existence checks.
- **Session Inheritance**: The `init_session_from_base` function enables powerful modify/revert/resume workflows.
- **Automatic Status Updates**: Feature status is kept in sync with task completion without manual intervention.
- **Clean Abstraction**: All other domains interact with a simple, consistent API, unaware of the underlying file system complexity.

This domain is not just storage—it is the foundation upon which Cowork Forge's autonomy, traceability, and reliability are built.