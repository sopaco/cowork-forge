# System Boundary Interface Documentation

This document describes the system's external invocation interfaces, including CLI commands, API endpoints, configuration parameters, and other boundary mechanisms.

## Command Line Interface (CLI)

### cowork

**Description**: AI-powered software development system - Iteration Architecture

**Source File**: `crates/cowork-cli/src/main.rs`

**Arguments**:

- `config` (string): optional - Path to config file (default: config.toml) (default: `config.toml`)
- `verbose` (boolean): optional - Enable verbose logging (default: `false`)

**Options**:

- `iter`(object): required - Create and execute a new iteration
- `list`(object): required - List all iterations
- `show`(object): required - Show iteration details
- `continue`(object): required - Continue a paused iteration
- `init`(object): required - Initialize a new project
- `status`(object): required - Show project status
- `delete`(object): required - Delete an iteration

**Usage Examples**:

```bash
cowork iter "My First Project"
```

```bash
cowork list --all
```

```bash
cowork show 123e4567-e89b-12d3-a456-426614174000
```

```bash
cowork continue
```

```bash
cowork init --name "MyApp"
```

```bash
cowork status
```

```bash
cowork delete 123e4567-e89b-12d3-a456-426614174000
```

## Integration Suggestions

### CLI

Integrate with CI/CD pipelines by invoking cowork commands in automation scripts

**Example Code**:

```
# In a GitHub Actions workflow
- name: Initialize project
  run: cowork init --name "my-app"
- name: Create first iteration
  run: cowork iter "Implement login feature"
- name: Check project status
  run: cowork status
```

**Best Practices**:

- Use environment variables for sensitive configuration (e.g., LLM_API_KEY)
- Validate project state before running iterations
- Handle exit codes to fail CI jobs on iteration failures
- Use --verbose flag for debugging in CI environments

### GUI

Integrate with external editors for human-in-the-loop editing

**Example Code**:

```
// In a Tauri command, open file in external editor
tauri::api::process::Command::new_sidecar("code")
    .args(["/path/to/artifacts/idea.md"])
    .spawn()
    .expect("Failed to open editor");
```

**Best Practices**:

- Use tauri-plugin-opener for cross-platform file opening
- Ensure file paths are properly escaped
- Handle cases where external editor is not installed
- Provide fallback to in-app editor when external editor fails

### LLM

Configure LLM client with custom endpoints and rate limiting

**Example Code**:

```
# config.toml
[llm]
api_base_url = "http://localhost:8000/v1"
api_key = "your-api-key-here"
model_name = "gpt-4"

# Or set via environment variables
export LLM_API_BASE_URL="http://localhost:8000/v1"
export LLM_API_KEY="your-api-key-here"
export LLM_MODEL_NAME="gpt-4"
```

**Best Practices**:

- Use environment variables for API keys in production
- Configure rate limiting to stay within API provider limits
- Validate LLM configuration at startup
- Implement fallback to default model if specified model is unavailable

### Security

Secure the system by implementing proper capability-based access control

**Example Code**:

```
// In tauri.conf.json, restrict capabilities to minimum required
{
  "security": {
    "dangerous_remote_origin_api": false,
    "insecure_dev_server": false
  },
  "allowlist": {
    "all": false,
    "core": {
      "all": false
    },
    "dialog": {
      "all": false
    }
  }
}
```

**Best Practices**:

- Use Tauri's capability system to restrict API access to only what's needed
- Regularly audit permissions in capabilities.json
- Avoid using "all": true in allowlist configuration
- Keep Tauri and dependencies updated to patch security vulnerabilities


---

**Analysis Confidence**: 9.5/10
