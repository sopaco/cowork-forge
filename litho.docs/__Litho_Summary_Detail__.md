# Project Analysis Summary Report (Full Version)

Generation Time: 2026-02-07 02:08:15 UTC

## Execution Timing Statistics

- **Total Execution Time**: 1087.20 seconds
- **Preprocessing Phase**: 170.81 seconds (15.7%)
- **Research Phase**: 389.14 seconds (35.8%)
- **Document Generation Phase**: 527.25 seconds (48.5%)
- **Output Phase**: 0.00 seconds (0.0%)
- **Summary Generation Time**: 0.006 seconds

## Cache Performance Statistics and Savings

### Performance Metrics
- **Cache Hit Rate**: 79.5%
- **Total Operations**: 176
- **Cache Hits**: 140 times
- **Cache Misses**: 36 times
- **Cache Writes**: 37 times

### Savings
- **Inference Time Saved**: 817.5 seconds
- **Tokens Saved**: 198240 input + 122086 output = 320326 total
- **Estimated Cost Savings**: $0.2200
- **Performance Improvement**: 79.5%
- **Efficiency Improvement Ratio**: 0.8x (saved time / actual execution time)

## Core Research Data Summary

Complete content of four types of research materials according to Prompt template data integration rules:

### System Context Research Report
Provides core objectives, user roles, and system boundary information for the project.

```json
{
  "business_value": "Reduces manual effort in software development by automating requirement elicitation, architecture design, code generation, and documentation, enabling faster MVP delivery with consistent quality.",
  "confidence_score": 0.95,
  "external_systems": [
    {
      "description": "Used for generating requirements, designs, code, and documentation; accessed via API endpoint configured in config.toml or environment variables.",
      "interaction_type": "HTTP",
      "name": "LLM API (OpenAI-compatible)"
    },
    {
      "description": "Launched by the system for human-in-the-loop edits to documents and code files.",
      "interaction_type": "Process spawn",
      "name": "External Editor (e.g., VSCode)"
    }
  ],
  "project_description": "An AI-powered software development system that automates the entire development lifecycle through iterative workflows, using multi-agent collaboration to generate requirements, design, code, and delivery documentation.",
  "project_name": "Cowork Forge",
  "project_type": "FullStackApp",
  "system_boundary": {
    "excluded_components": [
      "Cloud deployment infrastructure",
      "CI/CD pipelines",
      "Testing frameworks",
      "Database servers (e.g., PostgreSQL)",
      "External authentication systems",
      "Mobile or web client applications beyond Tauri GUI"
    ],
    "included_components": [
      "CLI interface",
      "GUI interface (Tauri)",
      "Core domain models (Project, Iteration, Memory)",
      "Pipeline executor and stages (Idea, PRD, Design, Plan, Coding, Check, Delivery)",
      "LLM configuration and rate limiting",
      "File system persistence (.cowork directory)",
      "Human-in-the-loop interaction tools",
      "Change request analysis and tracking"
    ],
    "scope": "End-to-end AI-assisted software development workflow from idea to delivery"
  },
  "target_users": [
    {
      "description": "Developers who want to accelerate development by leveraging AI for repetitive tasks like writing PRDs, designing architectures, and generating code.",
      "name": "Software Developers",
      "needs": [
        "Automated requirement gathering",
        "AI-assisted architecture design",
        "Code generation from plans",
        "Automated delivery documentation"
      ]
    },
    {
      "description": "Product owners who need structured documentation and clear traceability from idea to delivery without manual writing.",
      "name": "Product Managers",
      "needs": [
        "Automated PRD generation",
        "Traceable feature implementation",
        "Clear delivery reports",
        "Consistent project documentation"
      ]
    },
    {
      "description": "Tech leads overseeing multiple projects who need standardized development processes and quality assurance without manual code reviews.",
      "name": "Engineering Leads",
      "needs": [
        "Enforced simplicity in architecture",
        "Automated quality checks",
        "Audit trails of changes",
        "Consistent team workflows"
      ]
    }
  ]
}
```

### Domain Modules Research Report
Provides high-level domain division, module relationships, and core business process information.

```json
{
  "architecture_summary": "Cowork Forge employs a layered, domain-driven architecture centered around an iterative software development workflow. The system is divided into core business domains (Project, Iteration, Memory, Pipeline) with supporting infrastructure domains for interaction, persistence, and tooling. The architecture follows a clean separation of concerns: domain models encapsulate business logic, pipeline stages orchestrate workflows, and interaction layers abstract UI concerns. The system integrates LLM-based agents through a tool-based interface, enabling human-in-the-loop collaboration. All data is persisted in a session-scoped .cowork directory structure, ensuring isolation and traceability. The CLI and Tauri GUI share the same core engine through a unified InteractiveBackend abstraction, enabling consistent behavior across interfaces.",
  "business_flows": [
    {
      "description": "Initializes a new software project by creating a project entity, establishing the .cowork directory structure, and generating an initial idea document. This process sets the foundation for all subsequent development iterations.",
      "entry_point": "CLI: 'cowork init' command; GUI: New Project button",
      "importance": 9.0,
      "involved_domains_count": 3,
      "name": "Project Initialization Process",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "Project Management Domain",
          "operation": "Creates Project entity with auto-generated ID and initializes project directory structure",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Executes IdeaStage to generate initial idea.md document using LLM based on user input",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Persistence Domain",
          "operation": "Persists Project entity to project.json and saves idea.md artifact in .cowork/sessions/<id>/artifacts/",
          "step": 3,
          "sub_module": null
        }
      ]
    },
    {
      "description": "Executes a complete development cycle through sequential pipeline stages (Idea → PRD → Design → Plan → Coding → Check → Delivery), with optional human-in-the-loop feedback at each stage. Each iteration produces a complete, documented, and validated software artifact.",
      "entry_point": "CLI: 'cowork run' or 'cowork continue'; GUI: Start Iteration button",
      "importance": 10.0,
      "involved_domains_count": 5,
      "name": "Development Iteration Process",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Loads current project and iteration context from persistence layer",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Executes sequential pipeline stages: Idea, PRD, Design, Plan, Coding, Check, Delivery",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Interaction Domain",
          "operation": "At each stage, invokes Human-in-the-Loop (HITL) tools for user review, feedback, or editing",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Uses LLM agents with structured prompts and tool calls to generate artifacts at each stage",
          "step": 4,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Persistence Domain",
          "operation": "Saves all generated artifacts (PRD.md, design.md, etc.) and updates iteration state in storage",
          "step": 5,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Project Management Domain",
          "operation": "Updates project's current iteration reference and iteration history",
          "step": 6,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Final DeliveryStage copies generated code files to project root and generates delivery_report.md",
          "step": 7,
          "sub_module": null
        }
      ]
    },
    {
      "description": "Analyzes user-initiated modifications to an existing project, determining the scope of changes across requirements, design, plan, and code layers. Generates a structured ChangeRequest that guides subsequent development.",
      "entry_point": "CLI: 'cowork modify'; GUI: Modify Project button",
      "importance": 8.0,
      "involved_domains_count": 4,
      "name": "Change Request Analysis Process",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "Interaction Domain",
          "operation": "Captures user's natural language change request through CLI input or GUI form",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Invokes Change Triage Agent (modify.rs) to analyze scope using LLM with access to requirements, design, plan, and code artifacts",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Tool Support Domain",
          "operation": "Uses SaveChangeRequestTool to persist structured ChangeRequest with risk assessment and affected components",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Project Management Domain",
          "operation": "Creates new session based on current project, inheriting state and artifacts",
          "step": 4,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Executes modified pipeline (starting from affected stage) with updated context from ChangeRequest",
          "step": 5,
          "sub_module": null
        }
      ]
    },
    {
      "description": "Retrieves relevant historical knowledge (decisions, patterns, experiences) from both project-level and session-level memory stores to provide context-aware AI assistance during development.",
      "entry_point": "Triggered automatically by LLM agents during PRD, Design, Plan, or Coding stages",
      "importance": 7.0,
      "involved_domains_count": 2,
      "name": "Memory Context Retrieval Process",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "Memory Domain",
          "operation": "Queries MemoryIndex using QueryMemoryIndexTool with filters for category (decisions/patterns), stage, and scope (project/iteration)",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Tool Support Domain",
          "operation": "LoadMemoryDetailTool retrieves full markdown content of identified memory items",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Injects retrieved memory context into LLM prompts for stage execution to inform AI decisions",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Memory Domain",
          "operation": "GetMemoryContextTool aggregates summary of current memory state for system status reporting",
          "step": 4,
          "sub_module": null
        }
      ]
    },
    {
      "description": "Performs automated quality checks on generated code artifacts and generates comprehensive delivery documentation, ensuring completeness before finalizing an iteration.",
      "entry_point": "Automatically triggered as final stage in Development Iteration Process",
      "importance": 8.0,
      "involved_domains_count": 3,
      "name": "Quality Assurance and Delivery Process",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Loads all previous artifacts (requirements, design, plan, code files)",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Executes CheckStage with LLM agent using structured prompt to validate functionality, code quality, and coverage",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Tool Support Domain",
          "operation": "Uses SaveDeliveryReportTool to generate and persist delivery_report.md with summary of changes, features, and architecture",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Pipeline Domain",
          "operation": "Recursively copies generated code files from workspace to project root, excluding system artifacts",
          "step": 4,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "Interaction Domain",
          "operation": "Displays completion status and report location to user via interactive backend",
          "step": 5,
          "sub_module": null
        }
      ]
    }
  ],
  "confidence_score": 0.96,
  "domain_modules": [
    {
      "code_paths": [
        "crates/cowork-core/src/domain/project.rs",
        "crates/cowork-core/src/persistence/project_store.rs"
      ],
      "complexity": 7.0,
      "description": "Manages the core project entity and its lifecycle, including iteration tracking, status management, and project metadata. This domain represents the container for all development activities and serves as the anchor point for persistence and state management.",
      "domain_type": "Core Business Domain",
      "importance": 10.0,
      "name": "Project Management Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/domain/project.rs"
          ],
          "description": "Core domain model representing a software project with automatic ID generation, timestamp tracking, tech stack metadata, and iteration history management.",
          "importance": 10.0,
          "key_functions": [
            "Project::new",
            "Project::add_iteration",
            "Project::set_current_iteration",
            "Project::get_latest_completed_iteration"
          ],
          "name": "Project Entity"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/persistence/project_store.rs"
          ],
          "description": "Repository pattern implementation for serializing and deserializing Project entities to/from JSON files in the .cowork directory.",
          "importance": 9.0,
          "key_functions": [
            "ProjectStore::load",
            "ProjectStore::save",
            "ProjectStore::create",
            "ProjectStore::exists"
          ],
          "name": "Project Persistence"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/domain/iteration.rs",
        "crates/cowork-core/src/persistence/iteration_store.rs"
      ],
      "complexity": 8.0,
      "description": "Manages the lifecycle of individual development iterations, tracking execution state, inheritance patterns, and artifacts produced at each stage. This domain embodies the core iterative workflow of the system.",
      "domain_type": "Core Business Domain",
      "importance": 10.0,
      "name": "Iteration Management Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/domain/iteration.rs"
          ],
          "description": "Core domain model representing a single development cycle with five-stage lifecycle (idea → prd → design → plan → delivery), inheritance modes, and artifact tracking.",
          "importance": 10.0,
          "key_functions": [
            "Iteration::new",
            "Iteration::get_stage_status",
            "Iteration::get_next_stage",
            "Iteration::apply_inheritance"
          ],
          "name": "Iteration Entity"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/persistence/iteration_store.rs"
          ],
          "description": "Repository pattern implementation for storing and retrieving Iteration entities and their associated artifacts in a hierarchical file structure.",
          "importance": 9.0,
          "key_functions": [
            "IterationStore::load",
            "IterationStore::save",
            "IterationStore::list_all",
            "IterationStore::load_summary"
          ],
          "name": "Iteration Persistence"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/domain/memory.rs",
        "crates/cowork-core/src/persistence/memory_store.rs",
        "crates/cowork-core/src/tools/memory_tools.rs"
      ],
      "complexity": 7.0,
      "description": "Provides persistent and transient memory systems to store decisions, patterns, and experiences across sessions and within sessions. This domain enables context-aware AI assistance by leveraging historical knowledge.",
      "domain_type": "Core Business Domain",
      "importance": 9.0,
      "name": "Memory Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/domain/memory.rs",
            "crates/cowork-core/src/persistence/memory_store.rs"
          ],
          "description": "Long-term storage for architectural decisions, reusable patterns, and technical context that persists across all iterations of a project.",
          "importance": 9.0,
          "key_functions": [
            "ProjectMemory::new",
            "ProjectMemory::query",
            "ProjectMemory::promote"
          ],
          "name": "Project Memory"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/domain/memory.rs",
            "crates/cowork-core/src/persistence/memory_store.rs"
          ],
          "description": "Ephemeral storage for insights, issues, and learnings specific to a single development session, cleared upon session completion.",
          "importance": 8.0,
          "key_functions": [
            "IterationMemory::new",
            "IterationMemory::add_insight",
            "IterationMemory::query"
          ],
          "name": "Session Memory"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/memory_tools.rs"
          ],
          "description": "Agent-accessible tools for querying and managing memory content, enabling AI agents to retrieve contextual knowledge during execution.",
          "importance": 8.0,
          "key_functions": [
            "QueryMemoryIndexTool::execute",
            "LoadMemoryDetailTool::execute",
            "SaveSessionMemoryTool::execute",
            "PromoteToProjectMemoryTool::execute",
            "GetMemoryContextTool::execute"
          ],
          "name": "Memory Tools"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/pipeline/executor.rs",
        "crates/cowork-core/src/pipeline/stages/idea.rs",
        "crates/cowork-core/src/pipeline/stages/prd.rs",
        "crates/cowork-core/src/pipeline/stages/design.rs",
        "crates/cowork-core/src/pipeline/stages/plan.rs",
        "crates/cowork-core/src/pipeline/stages/coding.rs",
        "crates/cowork-core/src/pipeline/stages/check.rs",
        "crates/cowork-core/src/pipeline/stages/delivery.rs",
        "crates/cowork-core/src/pipeline/mod.rs"
      ],
      "complexity": 9.0,
      "description": "Orchestrates the end-to-end development workflow through a sequence of pipeline stages (Idea, PRD, Design, Plan, Coding, Check, Delivery). This domain implements the core business process of automated software development.",
      "domain_type": "Core Business Domain",
      "importance": 10.0,
      "name": "Pipeline Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/pipeline/executor.rs"
          ],
          "description": "Controller component that coordinates stage execution, handles retry logic, feedback loops, and workspace preparation for inheritance scenarios.",
          "importance": 10.0,
          "key_functions": [
            "IterationExecutor::execute_iteration",
            "IterationExecutor::prepare_workspace",
            "IterationExecutor::execute_stage"
          ],
          "name": "Pipeline Executor"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/pipeline/stages/idea.rs",
            "crates/cowork-core/src/pipeline/stages/prd.rs",
            "crates/cowork-core/src/pipeline/stages/design.rs",
            "crates/cowork-core/src/pipeline/stages/plan.rs",
            "crates/cowork-core/src/pipeline/stages/coding.rs",
            "crates/cowork-core/src/pipeline/stages/check.rs",
            "crates/cowork-core/src/pipeline/stages/delivery.rs"
          ],
          "description": "Individual stage implementations that perform specific development tasks using LLM agents and tool calls, each implementing the Stage trait.",
          "importance": 10.0,
          "key_functions": [
            "IdeaStage::execute",
            "PRDStage::execute",
            "DesignStage::execute",
            "PlanStage::execute",
            "CodingStage::execute",
            "CheckStage::execute",
            "DeliveryStage::execute"
          ],
          "name": "Pipeline Stages"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/pipeline/mod.rs"
          ],
          "description": "Support utilities for stage enumeration, critical stage detection, and pipeline context management.",
          "importance": 7.0,
          "key_functions": [
            "get_all_stages",
            "get_stages_from",
            "is_critical_stage"
          ],
          "name": "Pipeline Utilities"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/interaction/mod.rs",
        "crates/cowork-core/src/interaction/cli.rs",
        "crates/cowork-core/src/interaction/tauri.rs",
        "crates/cowork-core/src/event_bus.rs"
      ],
      "complexity": 6.0,
      "description": "Abstracts user interaction through a unified interface supporting both CLI and GUI backends. This domain enables Human-in-the-Loop (HITL) collaboration by providing consistent input/output mechanisms.",
      "domain_type": "Infrastructure Domain",
      "importance": 9.0,
      "name": "Interaction Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/interaction/mod.rs"
          ],
          "description": "Trait defining the contract for all UI interactions, including message display, input handling, progress tracking, and response submission.",
          "importance": 10.0,
          "key_functions": [
            "InteractiveBackend::show_message",
            "InteractiveBackend::request_input",
            "InteractiveBackend::show_progress",
            "InteractiveBackend::submit_response",
            "InteractiveBackend::event_bus"
          ],
          "name": "Interactive Backend"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/interaction/cli.rs"
          ],
          "description": "Concrete implementation of InteractiveBackend for terminal-based interaction with UTF-8 support, multi-mode input handling, and emoji-enhanced output.",
          "importance": 9.0,
          "key_functions": [
            "CliBackend::show_message",
            "CliBackend::request_input",
            "CliBackend::show_progress"
          ],
          "name": "CLI Backend"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/interaction/tauri.rs"
          ],
          "description": "Placeholder implementation for Tauri GUI integration, currently outputting to console but designed for future GUI communication.",
          "importance": 7.0,
          "key_functions": [
            "TauriBackend::show_message",
            "TauriBackend::request_input",
            "TauriBackend::show_progress"
          ],
          "name": "GUI Backend"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/event_bus.rs"
          ],
          "description": "Publish-subscribe system for real-time communication between pipeline components and UI, using tokio broadcast channels.",
          "importance": 8.0,
          "key_functions": [
            "EventBus::new",
            "EventBus::subscribe",
            "EventBus::publish",
            "EngineEvent::stage_started",
            "EngineEvent::agent_completed"
          ],
          "name": "Event Bus"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/tools/file_tools.rs",
        "crates/cowork-core/src/tools/data_tools.rs",
        "crates/cowork-core/src/tools/control_tools.rs",
        "crates/cowork-core/src/tools/artifact_tools.rs",
        "crates/cowork-core/src/tools/hitl_content_tools.rs",
        "crates/cowork-core/src/tools/hitl_tools.rs",
        "crates/cowork-core/src/tools/idea_tools.rs",
        "crates/cowork-core/src/tools/modify_tools.rs",
        "crates/cowork-core/src/tools/goto_stage_tool.rs"
      ],
      "complexity": 8.0,
      "description": "Provides a suite of specialized tools that enable AI agents to interact with the system's state, file system, and external services. These tools implement the ADK Tool trait and form the interface between LLM agents and system capabilities.",
      "domain_type": "Tool Support Domain",
      "importance": 9.0,
      "name": "Tool Support Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/tools/file_tools.rs"
          ],
          "description": "Secure file system operations with path validation to prevent directory traversal attacks, enabling agents to list, read, write, and delete files within workspace boundaries.",
          "importance": 9.0,
          "key_functions": [
            "ListFilesTool::execute",
            "ReadFileTool::execute",
            "WriteFileTool::execute",
            "DeleteFileTool::execute",
            "DeleteDirectoryTool::execute",
            "RunCommandTool::execute"
          ],
          "name": "File Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/data_tools.rs"
          ],
          "description": "Tools for managing project data entities (requirements, features, design components, tasks) with automatic ID generation and status tracking.",
          "importance": 9.0,
          "key_functions": [
            "CreateRequirementTool::execute",
            "AddFeatureTool::execute",
            "CreateDesignComponentTool::execute",
            "CreateTaskTool::execute",
            "UpdateFeatureStatusTool::execute",
            "UpdateTaskStatusTool::execute",
            "GetRequirementsTool::execute",
            "GetDesignTool::execute",
            "GetPlanTool::execute"
          ],
          "name": "Data Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/control_tools.rs"
          ],
          "description": "Tools for human-in-the-loop control, including feedback submission, request for replanning, and escalation to human review.",
          "importance": 9.0,
          "key_functions": [
            "ProvideFeedbackTool::execute",
            "RequestReplanningTool::execute",
            "AskUserTool::execute",
            "RequestHumanReviewTool::execute"
          ],
          "name": "Control Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/artifact_tools.rs"
          ],
          "description": "Tools for saving and loading key artifacts (PRD, design, delivery reports) with session isolation.",
          "importance": 8.0,
          "key_functions": [
            "SavePrdDocTool::execute",
            "SaveDesignDocTool::execute",
            "SaveDeliveryReportTool::execute",
            "LoadFeedbackHistoryTool::execute"
          ],
          "name": "Artifact Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/hitl_content_tools.rs",
            "crates/cowork-core/src/tools/hitl_tools.rs"
          ],
          "description": "Tools for interactive content review and editing, enabling users to modify documents and code files through external editors.",
          "importance": 9.0,
          "key_functions": [
            "ReviewAndEditContentTool::execute",
            "ReviewWithFeedbackContentTool::execute",
            "ReviewAndEditFileTool::execute",
            "ReviewWithFeedbackTool::execute"
          ],
          "name": "HITL Content Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/idea_tools.rs"
          ],
          "description": "Specialized tools for managing idea.md documents, enabling agents to save and load initial project concepts.",
          "importance": 7.0,
          "key_functions": [
            "SaveIdeaTool::execute",
            "LoadIdeaTool::execute"
          ],
          "name": "Idea Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/modify_tools.rs"
          ],
          "description": "Tools for managing ChangeRequest entities, capturing scope analysis and risk assessments for modification workflows.",
          "importance": 8.0,
          "key_functions": [
            "SaveChangeRequestTool::execute",
            "LoadChangeRequestTool::execute"
          ],
          "name": "Modify Tools"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/tools/goto_stage_tool.rs"
          ],
          "description": "Tool that allows agents to restart the pipeline from a specified stage, enabling iterative refinement.",
          "importance": 7.0,
          "key_functions": [
            "GotoStageTool::execute"
          ],
          "name": "Goto Stage Tool"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/llm/config.rs",
        "crates/cowork-core/src/llm/rate_limiter.rs"
      ],
      "complexity": 6.0,
      "description": "Manages Large Language Model configuration, rate limiting, and client creation. This domain ensures controlled and sustainable interaction with external LLM services.",
      "domain_type": "Infrastructure Domain",
      "importance": 8.0,
      "name": "LLM Infrastructure Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/llm/config.rs"
          ],
          "description": "Handles loading and parsing LLM configuration from config.toml or environment variables, with fallback strategies.",
          "importance": 9.0,
          "key_functions": [
            "LlmConfig::load",
            "ModelConfig::load",
            "create_llm_client"
          ],
          "name": "LLM Configuration"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/llm/rate_limiter.rs"
          ],
          "description": "Implements global concurrency control and per-call delays to prevent exceeding LLM API quotas, using semaphore and delay patterns.",
          "importance": 8.0,
          "key_functions": [
            "init_global_rate_limiter",
            "RateLimitedLlm::generate_content"
          ],
          "name": "Rate Limiter"
        }
      ]
    },
    {
      "code_paths": [
        "crates/cowork-core/src/storage/mod.rs"
      ],
      "complexity": 5.0,
      "description": "Manages the session-scoped file system structure for all project data, ensuring isolation and persistence of artifacts, state, and logs. This domain provides the physical storage layer for the system.",
      "domain_type": "Infrastructure Domain",
      "importance": 8.0,
      "name": "Storage Domain",
      "sub_modules": [
        {
          "code_paths": [
            "crates/cowork-core/src/storage/mod.rs"
          ],
          "description": "Implements hierarchical storage structure (.cowork/sessions/<id>/) with support for session inheritance, state persistence, and artifact management.",
          "importance": 9.0,
          "key_functions": [
            "init_session_from_base",
            "load_state",
            "save_state",
            "create_session_directory"
          ],
          "name": "Session Storage"
        },
        {
          "code_paths": [
            "crates/cowork-core/src/storage/mod.rs"
          ],
          "description": "Handles creation and validation of the .cowork directory structure and its subdirectories (sessions, artifacts, state, patch, logs).",
          "importance": 7.0,
          "key_functions": [
            "cowork_dir",
            "sessions_dir",
            "artifact_dir",
            "state_dir",
            "patch_dir"
          ],
          "name": "Directory Management"
        }
      ]
    }
  ],
  "domain_relations": [
    {
      "description": "Project entity contains a collection of iterations and references the current iteration, creating a strong ownership relationship. Project persistence operations trigger iteration persistence.",
      "from_domain": "Project Management Domain",
      "relation_type": "Data Dependency",
      "strength": 9.0,
      "to_domain": "Iteration Management Domain"
    },
    {
      "description": "Pipeline executor requires current project context to initialize iteration execution. Project state determines which stages are relevant and whether inheritance should be applied.",
      "from_domain": "Project Management Domain",
      "relation_type": "Service Call",
      "strength": 9.0,
      "to_domain": "Pipeline Domain"
    },
    {
      "description": "Pipeline stages operate on iteration entities to progress through development stages. Iteration state tracks the completion status of each stage in the pipeline.",
      "from_domain": "Iteration Management Domain",
      "relation_type": "Service Call",
      "strength": 9.0,
      "to_domain": "Pipeline Domain"
    },
    {
      "description": "Pipeline stages (especially AI agents) rely heavily on tool support domain for file operations, data management, and human interaction. This is the primary mechanism for agent-system interaction.",
      "from_domain": "Pipeline Domain",
      "relation_type": "Service Call",
      "strength": 10.0,
      "to_domain": "Tool Support Domain"
    },
    {
      "description": "All tool implementations (file, data, artifact tools) depend on the storage domain's path resolution and persistence mechanisms to read/write data to the .cowork directory structure.",
      "from_domain": "Tool Support Domain",
      "relation_type": "Data Dependency",
      "strength": 8.0,
      "to_domain": "Storage Domain"
    },
    {
      "description": "Pipeline stages invoke interaction backend to display progress, request user input, and handle HITL feedback during execution. The event bus enables UI to subscribe to pipeline events.",
      "from_domain": "Interaction Domain",
      "relation_type": "Service Call",
      "strength": 8.0,
      "to_domain": "Pipeline Domain"
    },
    {
      "description": "HITL tools use the interaction backend to display content and receive user responses. The global InteractiveBackend is accessed by both interaction and tool components.",
      "from_domain": "Interaction Domain",
      "relation_type": "Service Call",
      "strength": 7.0,
      "to_domain": "Tool Support Domain"
    },
    {
      "description": "Pipeline stages create and use LLM clients for generating content at each stage. Rate limiting ensures compliance with API quotas.",
      "from_domain": "LLM Infrastructure Domain",
      "relation_type": "Service Call",
      "strength": 8.0,
      "to_domain": "Pipeline Domain"
    },
    {
      "description": "Pipeline stages query memory tools to retrieve historical context (decisions, patterns) to inform AI-generated artifacts, enhancing consistency and quality.",
      "from_domain": "Memory Domain",
      "relation_type": "Service Call",
      "strength": 7.0,
      "to_domain": "Pipeline Domain"
    },
    {
      "description": "Project and iteration persistence layers depend on storage domain to resolve file paths and manage directory structure for persistence operations.",
      "from_domain": "Storage Domain",
      "relation_type": "Data Dependency",
      "strength": 8.0,
      "to_domain": "Project Management Domain"
    },
    {
      "description": "HITL tools rely on the interaction backend to display content and receive user input, creating a dependency from tool support to interaction layer.",
      "from_domain": "Tool Support Domain",
      "relation_type": "Tool Support",
      "strength": 6.0,
      "to_domain": "Interaction Domain"
    }
  ]
}
```

### Workflow Research Report
Contains static analysis results of the codebase and business process analysis.

```json
{
  "main_workflow": {
    "description": "Executes a complete development cycle through sequential pipeline stages (Idea → PRD → Design → Plan → Coding → Check → Delivery), with optional human-in-the-loop feedback at each stage. Each iteration produces a complete, documented, and validated software artifact.",
    "flowchart_mermaid": "graph TD\n    A[Start Iteration] --> B[Load Project & Iteration Context]\n    B --> C[Execute Idea Stage: Generate idea.md]\n    C --> D[Execute PRD Stage: Generate prd.md]\n    D --> E[Execute Design Stage: Generate design.md]\n    E --> F[Execute Plan Stage: Generate plan.md]\n    F --> G[Execute Coding Stage: Generate code files]\n    G --> H[Execute Check Stage: Quality Review]\n    H --> I[Execute Delivery Stage: Generate delivery_report.md & copy files]\n    I --> J[Update Project Current Iteration]\n    J --> K[End Iteration]\n    C -.-> L[Human Review: Edit/Feedback]\n    D -.-> L\n    E -.-> L\n    F -.-> L\n    G -.-> L\n    H -.-> L\n    I -.-> L\n    L --> C\n    L --> D\n    L --> E\n    L --> F\n    L --> G\n    L --> H\n    L --> I\n    style A fill:#4CAF50,stroke:#388E3C\n    style K fill:#4CAF50,stroke:#388E3C\n    style L fill:#FFC107,stroke:#FFA000\n    style B fill:#E0E0E0,stroke:#9E9E9E\n    style C fill:#E3F2FD,stroke:#2196F3\n    style D fill:#E3F2FD,stroke:#2196F3\n    style E fill:#E3F2FD,stroke:#2196F3\n    style F fill:#E3F2FD,stroke:#2196F3\n    style G fill:#E3F2FD,stroke:#2196F3\n    style H fill:#FFF3E0,stroke:#FF9800\n    style I fill:#E8F5E9,stroke:#43A047\n    style J fill:#E0E0E0,stroke:#9E9E9E",
    "name": "Development Iteration Process"
  },
  "other_important_workflows": [
    {
      "description": "Initializes a new software project by creating a project entity, establishing the .cowork directory structure, and generating an initial idea document. This process sets the foundation for all subsequent development iterations.",
      "flowchart_mermaid": "graph TD\n    A[Init Project] --> B[Create Project Entity]\n    B --> C[Initialize .cowork Directory Structure]\n    C --> D[Execute Idea Stage: Generate idea.md]\n    D --> E[Save Project to project.json]\n    E --> F[Save idea.md to Artifacts]\n    F --> G[End Initialization]\n    style A fill:#4CAF50,stroke:#388E3C\n    style G fill:#4CAF50,stroke:#388E3C\n    style B fill:#E0E0E0,stroke:#9E9E9E\n    style C fill:#E0E0E0,stroke:#9E9E9E\n    style D fill:#E3F2FD,stroke:#2196F3\n    style E fill:#E0E0E0,stroke:#9E9E9E\n    style F fill:#E8F5E9,stroke:#43A047",
      "name": "Project Initialization Process"
    },
    {
      "description": "Analyzes user-initiated modifications to an existing project, determining the scope of changes across requirements, design, plan, and code layers. Generates a structured ChangeRequest that guides subsequent development.",
      "flowchart_mermaid": "graph TD\n    A[Modify Project] --> B[Capture Natural Language Change Request]\n    B --> C[Invoke Change Triage Agent]\n    C --> D[Analyze Scope: PRD/Design/Plan/Code]\n    D --> E[Assess Risk Level & Affected Components]\n    E --> F[Save ChangeRequest to Storage]\n    F --> G[Create New Session from Base]\n    G --> H[Execute Modified Pipeline]\n    H --> I[End Modification Flow]\n    style A fill:#FF9800,stroke:#F57C00\n    style I fill:#FF9800,stroke:#F57C00\n    style B fill:#E0E0E0,stroke:#9E9E9E\n    style C fill:#E3F2FD,stroke:#2196F3\n    style D fill:#FFF3E0,stroke:#FF9800\n    style E fill:#FFF3E0,stroke:#FF9800\n    style F fill:#E0E0E0,stroke:#9E9E9E\n    style G fill:#E0E0E0,stroke:#9E9E9E\n    style H fill:#E3F2FD,stroke:#2196F3",
      "name": "Change Request Analysis Process"
    },
    {
      "description": "Retrieves relevant historical knowledge (decisions, patterns, experiences) from both project-level and session-level memory stores to provide context-aware AI assistance during development.",
      "flowchart_mermaid": "graph TD\n    A[LLM Agent Needs Context] --> B[Query Memory Index]\n    B --> C[Filter by Category & Scope]\n    C --> D[Retrieve Memory Items]\n    D --> E[Load Full Content]\n    E --> F[Inject into LLM Prompt]\n    F --> G[Generate Context-Aware Output]\n    G --> H[Update Memory Context Summary]\n    style A fill:#BBDEFB,stroke:#1976D2\n    style H fill:#BBDEFB,stroke:#1976D2\n    style B fill:#E3F2FD,stroke:#2196F3\n    style C fill:#E3F2FD,stroke:#2196F3\n    style D fill:#E3F2FD,stroke:#2196F3\n    style E fill:#E3F2FD,stroke:#2196F3\n    style F fill:#E3F2FD,stroke:#2196F3\n    style G fill:#E3F2FD,stroke:#2196F3",
      "name": "Memory Context Retrieval Process"
    },
    {
      "description": "Performs automated quality checks on generated code artifacts and generates comprehensive delivery documentation, ensuring completeness before finalizing an iteration.",
      "flowchart_mermaid": "graph TD\n    A[Start Delivery Stage] --> B[Load All Artifacts]\n    B --> C[Execute Check Stage: AI Quality Review]\n    C --> D[Generate Check Report]\n    D --> E[Generate Delivery Report]\n    E --> F[Copy Code Files to Project Root]\n    F --> G[Display Completion Status]\n    G --> H[End Delivery]\n    style A fill:#43A047,stroke:#2E7D32\n    style H fill:#43A047,stroke:#2E7D32\n    style B fill:#E8F5E9,stroke:#43A047\n    style C fill:#FFF3E0,stroke:#FF9800\n    style D fill:#E8F5E9,stroke:#43A047\n    style E fill:#E8F5E9,stroke:#43A047\n    style F fill:#E8F5E9,stroke:#43A047\n    style G fill:#E0E0E0,stroke:#9E9E9E",
      "name": "Quality Assurance and Delivery Process"
    }
  ]
}
```

### Code Insights Data
Code analysis results from preprocessing phase, including definitions of functions, classes, and modules.

```json
[
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "crates\\cowork-cli\\src\\main.rs",
      "functions": [
        "main",
        "cmd_iter",
        "cmd_list",
        "cmd_show",
        "cmd_continue",
        "cmd_init",
        "cmd_status",
        "cmd_delete",
        "truncate"
      ],
      "importance_score": 1.0,
      "interfaces": [
        "Commands::Iter",
        "Commands::List",
        "Commands::Show",
        "Commands::Continue",
        "Commands::Init",
        "Commands::Status",
        "Commands::Delete",
        "main",
        "cmd_iter",
        "cmd_list",
        "cmd_show",
        "cmd_continue",
        "cmd_init",
        "cmd_status",
        "cmd_delete",
        "truncate"
      ],
      "name": "main.rs",
      "source_summary": "// Cowork Forge - CLI Entry Point (Iteration Architecture)\n\nuse anyhow::Result;\nuse clap::{Parser, Subcommand};\nuse cowork_core::domain::IterationStatus;\nuse cowork_core::interaction::CliBackend;\nuse cowork_core::persistence::{IterationStore, ProjectStore};\nuse cowork_core::pipeline::IterationExecutor;\nuse cowork_core::event_bus::EventBus;\nuse std::sync::Arc;\nuse tracing::{info, error, warn};\n\n#[derive(Parser)]\n#[command(name = \"cowork\")]\n#[command(about = \"AI-powered software development system - Iteration Architecture\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n\n    /// Path to config file (default: config.toml)\n    #[arg(short, long, global = true)]\n    config: Option<String>,\n\n    /// Enable verbose logging\n    #[arg(short, long, global = true)]\n    verbose: bool,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Create and execute a new iteration\n    Iter {\n        /// Iteration title\n        title: String,\n\n        /// Detailed description of the iteration\n        #[arg(short, long)]\n        description: Option<String>,\n\n        /// Base iteration ID to inherit from (for evolution iterations)\n        #[arg(short, long)]\n        base: Option<String>,\n\n        /// Inheritance mode: none, full, or partial\n        #[arg(short, long, default_value = \"full\")]\n        inherit: String,\n    },\n\n    /// List all iterations\n    List {\n        /// Show all iterations including completed ones\n        #[arg(short, long)]\n        all: bool,\n    },\n\n    /// Show iteration details\n    Show {\n        /// Iteration ID (defaults to current iteration)\n        iteration_id: Option<String>,\n    },\n\n    /// Continue a paused iteration\n    Continue {\n        /// Iteration ID (defaults to current iteration)\n        iteration_id: Option<String>,\n    },\n\n    /// Initialize a new project\n    Init {\n        /// Project name\n        #[arg(short, long)]\n        name: Option<String>,\n    },\n\n    /// Show project status\n    Status,\n\n    /// Delete an iteration\n    Delete {\n        /// Iteration ID to delete\n        iteration_id: String,\n    },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    // Setup logging\n    let log_filter = if cli.verbose {\n        \"debug\".to_string()\n    } else {\n        \"info\".to_string()\n    };\n\n    tracing_subscriber::fmt()\n        .with_writer(std::io::stderr)\n        .with_env_filter(log_filter)\n        .init();\n\n    // Execute command\n    match cli.command {\n        Commands::Iter { title, description, base, inherit } => {\n            cmd_iter(title, description, base, inherit).await?\n        }\n        Commands::List { all } => cmd_list(all).await?,\n        Commands::Show { iteration_id } => cmd_show(iteration_id).await?,\n        Commands::Continue { iteration_id } => cmd_continue(iteration_id).await?,\n        Commands::Init { name } => cmd_init(name).await?,\n        Commands::Status => cmd_status().await?,\n        Commands::Delete { iteration_id } => cmd_delete(iteration_id).await?,\n    }\n\n    Ok(())\n}\n\n/// Create and execute a new iteration\nasync fn cmd_iter(\n    title: String,\n    description: Option<String>,\n    base: Option<String>,\n    inherit: String,\n) -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    // Check if project exists\n    let mut project = match project_store.load()? {\n        Some(p) => p,\n        None => {\n            error!(\"No project found. Run 'cowork init' first.\");\n            anyhow::bail!(\"Project not initialized\");\n        }\n    };\n\n    let description = description.unwrap_or_else(|| title.clone());\n\n    // Create interaction backend\n    let event_bus = Arc::new(EventBus::new());\n    let interaction = Arc::new(CliBackend::new(event_bus));\n\n    // Create executor\n    let executor = IterationExecutor::new(interaction);\n\n    // Create iteration based on whether it's genesis or evolution\n    let iteration = if let Some(base_id) = base {\n        // Evolution iteration\n        info!(\"Creating evolution iteration based on: {}\", base_id);\n\n        // Verify base iteration exists\n        if !iteration_store.exists(&base_id) {\n            error!(\"Base iteration '{}' not found\", base_id);\n            anyhow::bail!(\"Base iteration not found\");\n        }\n\n        // Parse inheritance mode\n        let inheritance = match inherit.as_str() {\n            \"none\" => cowork_core::domain::InheritanceMode::None,\n            \"partial\" => cowork_core::domain::InheritanceMode::Partial,\n            _ => cowork_core::domain::InheritanceMode::Full,\n        };\n\n        // Create evolution iteration\n        cowork_core::domain::Iteration::create_evolution(\n            &project,\n            title.clone(),\n            description.clone(),\n            base_id,\n            inheritance,\n        )\n    } else {\n        // Genesis iteration\n        info!(\"Creating genesis iteration\");\n        cowork_core::domain::Iteration::create_genesis(\n            &project,\n            title.clone(),\n            description.clone(),\n        )\n    };\n\n    // Save iteration\n    iteration_store.save(&iteration)?;\n    project_store.add_iteration(&mut project, iteration.to_summary())?;\n\n    println!(\"✨ Created iteration: {}\", iteration.id);\n    println!(\"   Title: {}\", iteration.title);\n    println!(\"   Number: {}\", iteration.number);\n    if iteration.base_iteration_id.is_some() {\n        println!(\"   Base: {:?}\", iteration.base_iteration_id);\n        println!(\"   Inheritance: {:?}\", iteration.inheritance);\n    }\n    println!(\"   Start Stage: {}\", iteration.determine_start_stage());\n    println!();\n\n    // Execute iteration\n    println!(\"🚀 Starting iteration execution...\");\n    println!();\n\n    match executor.execute(&mut project, &iteration.id).await {\n        Ok(_) => {\n            println!(\"\\n✅ Iteration '{}' completed successfully!\", iteration.title);\n            println!(\"   Iteration ID: {}\", iteration.id);\n            Ok(())\n        }\n        Err(e) => {\n            println!(\"\\n❌ Iteration failed: {}\", e);\n            Err(e)\n        }\n    }\n}\n\n/// List all iterations\nasync fn cmd_list(all: bool) -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    // Check if project exists\n    match project_store.load()? {\n        Some(project) => {\n            println!(\"📊 Project: {}\\n\", project.name);\n\n            let iterations = iteration_store.load_all()?;\n\n            if iterations.is_empty() {\n                println!(\"No iterations yet. Run 'cowork iter <title>' to create one.\");\n                return Ok(());\n            }\n\n            // Filter iterations if not showing all\n            let filtered: Vec<_> = if all {\n                iterations\n            } else {\n                iterations\n                    .into_iter()\n                    .filter(|i| matches!(i.status, IterationStatus::Running | IterationStatus::Paused))\n                    .collect()\n            };\n\n            if filtered.is_empty() && !all {\n                println!(\"No active iterations. Use --all to see completed iterations.\");\n                return Ok(());\n            }\n\n            // Print header\n            println!(\"{:<12} {:<30} {:<12} {:<15} {}\",\n                \"Number\", \"Title\", \"Status\", \"Current Stage\", \"ID\");\n            println!(\"{:-<100}\", \"\");\n\n            // Print iterations\n            for iter in filtered {\n                let status_str = format!(\"{:?}\", iter.status);\n                let status_colored = match iter.status {\n                    IterationStatus::Completed => format!(\"\\x1b[32m{}\\x1b[0m\", status_str), // Green\n                    IterationStatus::Running => format!(\"\\x1b[33m{}\\x1b[0m\", status_str),   // Yellow\n                    IterationStatus::Paused => format!(\"\\x1b[36m{}\\x1b[0m\", status_str),    // Cyan\n                    IterationStatus::Failed => format!(\"\\x1b[31m{}\\x1b[0m\", status_str),    // Red\n                    IterationStatus::Draft => status_str,\n                };\n\n                let current_stage = iter.current_stage.unwrap_or_else(|| \"-\".to_string());\n                let short_id = &iter.id[..20.min(iter.id.len())];\n\n                println!(\"{:<12} {:<30} {:<20} {:<15} {}\",\n                    iter.number,\n                    truncate(&iter.title, 28),\n                    status_colored,\n                    current_stage,\n                    short_id\n                );\n            }\n\n            if !all {\n                println!(\"\\nTip: Use --all to see completed iterations\");\n            }\n        }\n        None => {\n            println!(\"❌ No project found. Run 'cowork init' first.\");\n        }\n    }\n\n    Ok(())\n}\n\n/// Show iteration details\nasync fn cmd_show(iteration_id: Option<String>) -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    // Determine which iteration to show\n    let iteration_id = match iteration_id {\n        Some(id) => id,\n        None => {\n            // Use current iteration from project\n            match project_store.load()? {\n                Some(project) => {\n                    match project.current_iteration_id {\n                        Some(id) => id,\n                        None => {\n                            anyhow::bail!(\"No current iteration. Specify an iteration ID or run an iteration first.\");\n                        }\n                    }\n                }\n                None => {\n                    anyhow::bail!(\"No project found. Run 'cowork init' first.\");\n                }\n            }\n        }\n    };\n\n    // Load iteration\n    let iteration = iteration_store.load(&iteration_id)?;\n\n    println!(\"📋 Iteration Details\\n\");\n    println!(\"  ID:          {}\", iteration.id);\n    println!(\"  Number:      {}\", iteration.number);\n    println!(\"  Title:       {}\", iteration.title);\n    println!(\"  Description: {}\", iteration.description);\n    println!(\"  Status:      {:?}\", iteration.status);\n    println!(\"  Started:     {}\", iteration.started_at.format(\"%Y-%m-%d %H:%M:%S\"));\n\n    if let Some(completed_at) = iteration.completed_at {\n        println!(\"  Completed:   {}\", completed_at.format(\"%Y-%m-%d %H:%M:%S\"));\n    }\n\n    if let Some(ref base_id) = iteration.base_iteration_id {\n        println!(\"  Base:        {}\", base_id);\n        println!(\"  Inheritance: {:?}\", iteration.inheritance);\n    }\n\n    if let Some(ref stage) = iteration.current_stage {\n        println!(\"  Current:     {}\", stage);\n    }\n\n    if !iteration.completed_stages.is_empty() {\n        println!(\"  Completed:   {}\", iteration.completed_stages.join(\", \"));\n    }\n\n    // Show artifacts\n    println!(\"\\n  Artifacts:\");\n    if iteration.artifacts.idea.is_some() {\n        println!(\"    ✓ Idea\");\n    }\n    if iteration.artifacts.prd.is_some() {\n        println!(\"    ✓ PRD\");\n    }\n    if iteration.artifacts.design.is_some() {\n        println!(\"    ✓ Design\");\n    }\n    if iteration.artifacts.plan.is_some() {\n        println!(\"    ✓ Plan\");\n    }\n    if iteration.artifacts.delivery.is_some() {\n        println!(\"    ✓ Delivery\");\n    }\n\n    Ok(())\n}\n\n/// Continue a paused iteration\nasync fn cmd_continue(iteration_id: Option<String>) -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    // Determine which iteration to continue\n    let iteration_id = match iteration_id {\n        Some(id) => id,\n        None => {\n            // Find a paused iteration\n            let iterations = iteration_store.load_all()?;\n            let paused: Vec<_> = iterations\n                .into_iter()\n                .filter(|i| matches!(i.status, IterationStatus::Paused))\n                .collect();\n\n            match paused.len() {\n                0 => {\n                    anyhow::bail!(\"No paused iterations found.\");\n                }\n                1 => paused[0].id.clone(),\n                _ => {\n                    println!(\"Multiple paused iterations found. Please specify one:\");\n                    for iter in paused {\n                        println!(\"  - {} ({})\", iter.id, iter.title);\n                    }\n                    anyhow::bail!(\"Multiple paused iterations\");\n                }\n            }\n        }\n    };\n\n    // Load project and iteration\n    let mut project = match project_store.load()? {\n        Some(p) => p,\n        None => {\n            anyhow::bail!(\"No project found. Run 'cowork init' first.\");\n        }\n    };\n\n    let iteration = iteration_store.load(&iteration_id)?;\n\n    if iteration.status != IterationStatus::Paused {\n        anyhow::bail!(\"Iteration '{}' is not paused (status: {:?})\", iteration_id, iteration.status);\n    }\n\n    println!(\"🔄 Continuing iteration: {}\", iteration.title);\n    println!(\"   Current stage: {:?}\", iteration.current_stage);\n    println!();\n\n    // Create executor\n    let event_bus = Arc::new(EventBus::new());\n    let interaction = Arc::new(CliBackend::new(event_bus));\n    let executor = IterationExecutor::new(interaction);\n\n    match executor.continue_iteration(&mut project, &iteration_id).await {\n        Ok(_) => {\n            println!(\"\\n✅ Iteration completed!\");\n            Ok(())\n        }\n        Err(e) => {\n            println!(\"\\n❌ Iteration failed: {}\", e);\n            Err(e)\n        }\n    }\n}\n\n/// Initialize a new project\nasync fn cmd_init(name: Option<String>) -> Result<()> {\n    let project_store = ProjectStore::new();\n\n    if project_store.exists() {\n        let existing = project_store.load()?.unwrap();\n        warn!(\"Project '{}' already exists\", existing.name);\n        println!(\"⚠️  Project '{}' already exists\", existing.name);\n        println!(\"   Use 'cowork iter' to create iterations.\");\n        return Ok(());\n    }\n\n    // Get project name\n    let name = match name {\n        Some(n) => n,\n        None => {\n            // Try to infer from current directory\n            std::env::current_dir()?\n                .file_name()\n                .and_then(|n| n.to_str())\n                .map(|s| s.to_string())\n                .unwrap_or_else(|| \"my-project\".to_string())\n        }\n    };\n\n    // Create project\n    let project = project_store.create(&name)?;\n\n    println!(\"✅ Created project: {}\", project.name);\n    println!(\"   Project ID: {}\", project.id);\n    println!(\"   Working directory: .cowork-v2/\");\n    println!();\n    println!(\"Next steps:\");\n    println!(\"  1. Run 'cowork iter \\\"<title>\\\"' to create your first iteration\");\n    println!(\"  2. Or configure LLM settings in config.toml\");\n\n    Ok(())\n}\n\n/// Show project status\nasync fn cmd_status() -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    match project_store.load()? {\n        Some(project) => {\n            println!(\"📊 Project Status\\n\");\n            println!(\"  Name:        {}\", project.name);\n            println!(\"  ID:          {}\", project.id);\n            println!(\"  Created:     {}\", project.created_at.format(\"%Y-%m-%d %H:%M:%S\"));\n            println!(\"  Updated:     {}\", project.updated_at.format(\"%Y-%m-%d %H:%M:%S\"));\n\n            if let Some(ref current_id) = project.current_iteration_id {\n                println!(\"  Current:     {}\", current_id);\n            }\n\n            // Load iterations\n            let iterations = iteration_store.load_all()?;\n\n            let completed = iterations.iter()\n                .filter(|i| matches!(i.status, IterationStatus::Completed))\n                .count();\n            let running = iterations.iter()\n                .filter(|i| matches!(i.status, IterationStatus::Running))\n                .count();\n            let paused = iterations.iter()\n                .filter(|i| matches!(i.status, IterationStatus::Paused))\n                .count();\n            let failed = iterations.iter()\n                .filter(|i| matches!(i.status, IterationStatus::Failed))\n                .count();\n\n            println!(\"\\n  Iterations:\");\n            println!(\"    Total:      {}\", iterations.len());\n            println!(\"    Completed:  {}\", completed);\n            println!(\"    Running:    {}\", running);\n            println!(\"    Paused:     {}\", paused);\n            println!(\"    Failed:     {}\", failed);\n\n            // Show latest completed iteration\n            if let Some(latest) = project.get_latest_completed_iteration() {\n                println!(\"\\n  Latest Completed:\");\n                println!(\"    #{} - {}\", latest.number, latest.title);\n                println!(\"    Stages: {}\", latest.completed_stages.join(\", \"));\n            }\n        }\n        None => {\n            println!(\"❌ No project found in current directory.\");\n            println!(\"   Run 'cowork init' to create a new project.\");\n        }\n    }\n\n    Ok(())\n}\n\n/// Delete an iteration\nasync fn cmd_delete(iteration_id: String) -> Result<()> {\n    let project_store = ProjectStore::new();\n    let iteration_store = IterationStore::new();\n\n    // Verify iteration exists\n    if !iteration_store.exists(&iteration_id) {\n        anyhow::bail!(\"Iteration '{}' not found\", iteration_id);\n    }\n\n    // Load iteration to show details\n    let iteration = iteration_store.load(&iteration_id)?;\n\n    println!(\"⚠️  You are about to delete iteration:\");\n    println!(\"   #{} - {}\", iteration.number, iteration.title);\n    println!(\"   ID: {}\", iteration_id);\n    println!();\n\n    // Confirm deletion\n    print!(\"Are you sure? [y/N]: \");\n    std::io::Write::flush(&mut std::io::stdout())?;\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input)?;\n\n    if input.trim().to_lowercase() != \"y\" {\n        println!(\"Deletion cancelled.\");\n        return Ok(());\n    }\n\n    // Delete iteration\n    iteration_store.delete(&iteration_id)?;\n\n    // Update project (remove from iterations list)\n    if let Ok(Some(mut project)) = project_store.load() {\n        project.iterations.retain(|i| i.id != iteration_id);\n        project_store.save(&project)?;\n    }\n\n    println!(\"✅ Iteration '{}' deleted.\", iteration_id);\n\n    Ok(())\n}\n\n/// Helper function to truncate string\nfn truncate(s: &str, max_len: usize) -> String {\n    if s.len() <= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", &s[..max_len - 3])\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 47.0,
      "lines_of_code": 572,
      "number_of_classes": 1,
      "number_of_functions": 9
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 2,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "clap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 47,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 10,
        "name": "tracing",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 57,
        "name": "tracing_subscriber",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "cowork_core::domain::IterationStatus",
        "path": "cowork_core/domain",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 5,
        "name": "cowork_core::interaction::CliBackend",
        "path": "cowork_core/interaction",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 6,
        "name": "cowork_core::persistence",
        "path": "cowork_core/persistence",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 7,
        "name": "cowork_core::pipeline::IterationExecutor",
        "path": "cowork_core/pipeline",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 8,
        "name": "cowork_core::event_bus::EventBus",
        "path": "cowork_core/event_bus",
        "version": null
      }
    ],
    "detailed_description": "This is the main entry point for the Cowork Forge CLI application - an AI-powered software development system based on iteration architecture. The component provides a command-line interface for managing software development projects through an iterative workflow. It handles command parsing using clap, sets up logging, and routes commands to appropriate handler functions. The system supports creating genesis or evolution iterations, listing iterations, showing details, continuing paused iterations, initializing projects, displaying project status, and deleting iterations. Each command handler loads necessary persistence stores (ProjectStore, IterationStore), performs business operations, and displays formatted output to the user. The component orchestrates the interaction between user commands, domain models (Iteration, Project), and execution components (IterationExecutor, CliBackend, EventBus).",
    "interfaces": [
      {
        "description": "Async entry point that parses CLI arguments, initializes logging, and routes commands to handlers",
        "interface_type": "function",
        "name": "main",
        "parameters": [],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Creates and executes a new iteration, supporting both genesis and evolution modes with inheritance",
        "interface_type": "function",
        "name": "cmd_iter",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "description",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "base",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "inherit",
            "param_type": "String"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Lists all iterations with optional filtering to show only active iterations",
        "interface_type": "function",
        "name": "cmd_list",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "all",
            "param_type": "bool"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Displays detailed information about a specific iteration, defaulting to the current iteration",
        "interface_type": "function",
        "name": "cmd_show",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "iteration_id",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Resumes execution of a paused iteration, with automatic selection if only one is paused",
        "interface_type": "function",
        "name": "cmd_continue",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "iteration_id",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Initializes a new project with name inference from current directory if not provided",
        "interface_type": "function",
        "name": "cmd_init",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "name",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Displays comprehensive project status including iteration statistics and latest completed iteration",
        "interface_type": "function",
        "name": "cmd_status",
        "parameters": [],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "Deletes an iteration after user confirmation and updates project state",
        "interface_type": "function",
        "name": "cmd_delete",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "private"
      },
      {
        "description": "CLI subcommand enumeration defining all available commands: Iter, List, Show, Continue, Init, Status, Delete",
        "interface_type": "enum",
        "name": "Commands",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Parse and dispatch CLI commands using clap framework with subcommand routing",
      "Orchestrate iteration lifecycle operations including creation, execution, continuation, and deletion",
      "Manage project initialization and status reporting with persistence through ProjectStore and IterationStore",
      "Coordinate domain logic execution through IterationExecutor with proper backend and event bus setup",
      "Provide user interaction through formatted console output, status messages, and confirmation prompts"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\domain\\iteration.rs",
      "functions": [
        "create_genesis",
        "create_evolution",
        "start",
        "pause",
        "resume",
        "complete",
        "fail",
        "set_stage",
        "complete_stage",
        "determine_start_stage",
        "to_summary",
        "get",
        "set"
      ],
      "importance_score": 1.0,
      "interfaces": [
        "create_genesis",
        "create_evolution",
        "start",
        "pause",
        "resume",
        "complete",
        "fail",
        "set_stage",
        "complete_stage",
        "determine_start_stage",
        "to_summary",
        "Artifacts::get",
        "Artifacts::set",
        "InheritanceMode",
        "ChangeScope",
        "Artifacts",
        "Iteration",
        "Default for InheritanceMode",
        "Default for Artifacts",
        "analyze_change_scope"
      ],
      "name": "iteration.rs",
      "source_summary": "use chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse super::{IterationStatus, Project};\r\n\r\n/// Iteration - Core entity representing a single development cycle\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Iteration {\r\n    pub id: String,\r\n    pub number: u32,\r\n    pub title: String,\r\n    pub description: String,\r\n\r\n    // Inheritance\r\n    pub base_iteration_id: Option<String>,\r\n    pub inheritance: InheritanceMode,\r\n\r\n    // Execution state\r\n    pub status: IterationStatus,\r\n    pub started_at: DateTime<Utc>,\r\n    pub completed_at: Option<DateTime<Utc>>,\r\n    pub current_stage: Option<String>,\r\n    pub completed_stages: Vec<String>,\r\n\r\n    // Artifacts\r\n    pub artifacts: Artifacts,\r\n}\r\n\r\nimpl Iteration {\r\n    pub fn create_genesis(project: &Project, title: String, description: String) -> Self {\r\n        let now = Utc::now();\r\n        Self {\r\n            id: format!(\"iter-{}-{}\", project.next_iteration_number(), now.timestamp()),\r\n            number: project.next_iteration_number(),\r\n            title,\r\n            description,\r\n            base_iteration_id: None,\r\n            inheritance: InheritanceMode::None,\r\n            status: IterationStatus::Draft,\r\n            started_at: now,\r\n            completed_at: None,\r\n            current_stage: None,\r\n            completed_stages: Vec::new(),\r\n            artifacts: Artifacts::default(),\r\n        }\r\n    }\r\n\r\n    pub fn create_evolution(\r\n        project: &Project,\r\n        title: String,\r\n        description: String,\r\n        base_iteration_id: String,\r\n        inheritance: InheritanceMode,\r\n    ) -> Self {\r\n        let now = Utc::now();\r\n        Self {\r\n            id: format!(\"iter-{}-{}\", project.next_iteration_number(), now.timestamp()),\r\n            number: project.next_iteration_number(),\r\n            title,\r\n            description,\r\n            base_iteration_id: Some(base_iteration_id),\r\n            inheritance,\r\n            status: IterationStatus::Draft,\r\n            started_at: now,\r\n            completed_at: None,\r\n            current_stage: None,\r\n            completed_stages: Vec::new(),\r\n            artifacts: Artifacts::default(),\r\n        }\r\n    }\r\n\r\n    pub fn start(&mut self) {\r\n        self.status = IterationStatus::Running;\r\n        self.started_at = Utc::now();\r\n    }\r\n\r\n    pub fn pause(&mut self) {\r\n        self.status = IterationStatus::Paused;\r\n    }\r\n\r\n    pub fn resume(&mut self) {\r\n        self.status = IterationStatus::Running;\r\n    }\r\n\r\n    pub fn complete(&mut self) {\r\n        self.status = IterationStatus::Completed;\r\n        self.completed_at = Some(Utc::now());\r\n        self.current_stage = None;\r\n    }\r\n\r\n    pub fn fail(&mut self) {\r\n        self.status = IterationStatus::Failed;\r\n        self.current_stage = None;\r\n    }\r\n\r\n    pub fn set_stage(&mut self, stage: impl Into<String>) {\r\n        self.current_stage = Some(stage.into());\r\n    }\r\n\r\n    pub fn complete_stage(&mut self, stage: impl Into<String>, artifact_path: Option<String>) {\r\n        let stage_name = stage.into();\r\n        self.completed_stages.push(stage_name.clone());\r\n\r\n        // Update artifact\r\n        let path = artifact_path.unwrap_or_default();\r\n        match stage_name.as_str() {\r\n            \"idea\" => self.artifacts.idea = Some(path),\r\n            \"prd\" => self.artifacts.prd = Some(path),\r\n            \"design\" => self.artifacts.design = Some(path),\r\n            \"plan\" => self.artifacts.plan = Some(path),\r\n            \"delivery\" => self.artifacts.delivery = Some(path),\r\n            _ => {}\r\n        }\r\n    }\r\n\r\n    /// Determine the starting stage based on inheritance mode\r\n    pub fn determine_start_stage(&self) -> String {\r\n        match self.inheritance {\r\n            InheritanceMode::None => \"idea\".to_string(),\r\n            InheritanceMode::Full | InheritanceMode::Partial => {\r\n                // Analyze description to determine scope\r\n                analyze_change_scope(&self.description)\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn to_summary(&self) -> super::IterationSummary {\r\n        super::IterationSummary {\r\n            id: self.id.clone(),\r\n            number: self.number,\r\n            title: self.title.clone(),\r\n            status: self.status,\r\n            completed_stages: self.completed_stages.clone(),\r\n            created_at: self.started_at,\r\n        }\r\n    }\r\n}\r\n\r\n/// Inheritance mode for evolution iterations\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum InheritanceMode {\r\n    None,     // Genesis only - fresh start\r\n    Full,     // Inherit all code from base iteration\r\n    Partial,  // Inherit only artifact definitions\r\n}\r\n\r\nimpl Default for InheritanceMode {\r\n    fn default() -> Self {\r\n        InheritanceMode::Full\r\n    }\r\n}\r\n\r\n/// Change scope for determining start stage\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\r\npub enum ChangeScope {\r\n    Code,         // Start from plan\r\n    Design,       // Start from design\r\n    Requirement,  // Start from prd\r\n    Architecture, // Start from idea\r\n}\r\n\r\n/// Analyze change description to determine scope\r\nfn analyze_change_scope(description: &str) -> String {\r\n    let desc_lower = description.to_lowercase();\r\n\r\n    // Keywords indicating architecture changes\r\n    let arch_keywords = [\"架构\", \"architecture\", \"重构\", \"rewrite\", \"重新设计\", \"redesign\"];\r\n    for kw in &arch_keywords {\r\n        if desc_lower.contains(kw) {\r\n            return \"idea\".to_string();\r\n        }\r\n    }\r\n\r\n    // Keywords indicating requirement changes\r\n    let req_keywords = [\"需求\", \"requirement\", \"功能\", \"feature\", \"添加\", \"add\"];\r\n    for kw in &req_keywords {\r\n        if desc_lower.contains(kw) {\r\n            return \"prd\".to_string();\r\n        }\r\n    }\r\n\r\n    // Keywords indicating design changes\r\n    let design_keywords = [\"设计\", \"design\", \"数据库\", \"database\", \"接口\", \"api\"];\r\n    for kw in &design_keywords {\r\n        if desc_lower.contains(kw) {\r\n            return \"design\".to_string();\r\n        }\r\n    }\r\n\r\n    // Default: code changes only\r\n    \"plan\".to_string()\r\n}\r\n\r\n/// Artifacts produced by an iteration\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct Artifacts {\r\n    pub idea: Option<String>,\r\n    pub prd: Option<String>,\r\n    pub design: Option<String>,\r\n    pub plan: Option<String>,\r\n    pub delivery: Option<String>,\r\n}\r\n\r\nimpl Artifacts {\r\n    pub fn get(&self, stage: &str) -> Option<&String> {\r\n        match stage {\r\n            \"idea\" => self.idea.as_ref(),\r\n            \"prd\" => self.prd.as_ref(),\r\n            \"design\" => self.design.as_ref(),\r\n            \"plan\" => self.plan.as_ref(),\r\n            \"delivery\" => self.delivery.as_ref(),\r\n            _ => None,\r\n        }\r\n    }\r\n\r\n    pub fn set(&mut self, stage: &str, path: String) {\r\n        match stage {\r\n            \"idea\" => self.idea = Some(path),\r\n            \"prd\" => self.prd = Some(path),\r\n            \"design\" => self.design = Some(path),\r\n            \"plan\" => self.plan = Some(path),\r\n            \"delivery\" => self.delivery = Some(path),\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 14.0,
      "lines_of_code": 227,
      "number_of_classes": 3,
      "number_of_functions": 13
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": "chrono",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": "serde",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "super::(IterationStatus, Project)",
        "path": "super",
        "version": null
      }
    ],
    "detailed_description": "The iteration.rs component implements the core domain entity representing a single development cycle in a collaborative development system. It provides comprehensive functionality for managing the complete lifecycle of development iterations, from creation to completion, with support for both genesis (fresh) iterations and evolution iterations that inherit from previous iterations. The component tracks execution states through a five-stage development process (idea → prd → design → plan → delivery), manages artifacts produced at each stage, and includes intelligent change scope analysis that automatically determines the appropriate starting stage based on semantic analysis of the change description keywords. The architecture supports three inheritance modes (None, Full, Partial) to handle different scenarios of code and artifact inheritance between iterations.",
    "interfaces": [
      {
        "description": "Factory method to create a fresh genesis iteration without inheritance",
        "interface_type": "static_method",
        "name": "create_genesis",
        "parameters": [
          {
            "description": "Reference to the parent project",
            "is_optional": false,
            "name": "project",
            "param_type": "&Project"
          },
          {
            "description": "Iteration title",
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": "Iteration description",
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Factory method to create an evolution iteration that inherits from a base iteration",
        "interface_type": "static_method",
        "name": "create_evolution",
        "parameters": [
          {
            "description": "Reference to the parent project",
            "is_optional": false,
            "name": "project",
            "param_type": "&Project"
          },
          {
            "description": "Iteration title",
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": "Iteration description",
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": "ID of the base iteration to inherit from",
            "is_optional": false,
            "name": "base_iteration_id",
            "param_type": "String"
          },
          {
            "description": "Mode of inheritance",
            "is_optional": false,
            "name": "inheritance",
            "param_type": "InheritanceMode"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Transitions iteration status to Running and records start timestamp",
        "interface_type": "method",
        "name": "start",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Transitions iteration status to Paused",
        "interface_type": "method",
        "name": "pause",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Transitions iteration status back to Running",
        "interface_type": "method",
        "name": "resume",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Transitions iteration status to Completed, records completion timestamp, and clears current stage",
        "interface_type": "method",
        "name": "complete",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Transitions iteration status to Failed and clears current stage",
        "interface_type": "method",
        "name": "fail",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Sets the current development stage",
        "interface_type": "method",
        "name": "set_stage",
        "parameters": [
          {
            "description": "Stage name to set as current",
            "is_optional": false,
            "name": "stage",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Marks a stage as complete and updates the corresponding artifact path based on stage name",
        "interface_type": "method",
        "name": "complete_stage",
        "parameters": [
          {
            "description": "Stage name being completed",
            "is_optional": false,
            "name": "stage",
            "param_type": "impl Into<String>"
          },
          {
            "description": "Optional file path for the stage artifact",
            "is_optional": true,
            "name": "artifact_path",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Analyzes inheritance mode and description to determine the appropriate starting stage (idea/prd/design/plan)",
        "interface_type": "method",
        "name": "determine_start_stage",
        "parameters": [],
        "return_type": "String",
        "visibility": "public"
      },
      {
        "description": "Converts iteration to a lightweight summary format for display or listing",
        "interface_type": "method",
        "name": "to_summary",
        "parameters": [],
        "return_type": "IterationSummary",
        "visibility": "public"
      },
      {
        "description": "Retrieves the artifact path for a specific stage",
        "interface_type": "method",
        "name": "Artifacts::get",
        "parameters": [
          {
            "description": "Stage name to retrieve artifact for",
            "is_optional": false,
            "name": "stage",
            "param_type": "&str"
          }
        ],
        "return_type": "Option<&String>",
        "visibility": "public"
      },
      {
        "description": "Sets the artifact path for a specific stage",
        "interface_type": "method",
        "name": "Artifacts::set",
        "parameters": [
          {
            "description": "Stage name to set artifact for",
            "is_optional": false,
            "name": "stage",
            "param_type": "&str"
          },
          {
            "description": "File path for the artifact",
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Enumeration defining inheritance modes: None (genesis only), Full (inherit all code), Partial (inherit artifact definitions only)",
        "interface_type": "enum",
        "name": "InheritanceMode",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Enumeration defining change scope types: Code, Design, Requirement, Architecture for determining starting stages",
        "interface_type": "enum",
        "name": "ChangeScope",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Structure holding optional file paths for each development stage artifact (idea, prd, design, plan, delivery)",
        "interface_type": "struct",
        "name": "Artifacts",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Core domain entity representing a complete development cycle with state tracking, inheritance support, and artifact management",
        "interface_type": "struct",
        "name": "Iteration",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Iteration Lifecycle Management: Managing state transitions (Draft → Running → Paused → Completed/Failed) and tracking execution timestamps throughout the development cycle",
      "Artifact Tracking and Management: Recording, storing, and retrieving deliverable artifacts (idea, prd, design, plan, delivery) produced at each development stage with path references",
      "Inheritance Mode Support: Supporting different modes of inheriting code and artifacts from base iterations (None for genesis, Full for complete inheritance, Partial for selective inheritance)",
      "Stage Progress Tracking: Managing multi-stage development workflow with current stage tracking, completed stages history, and stage-based artifact linkage",
      "Change Scope Analysis: Intelligently determining appropriate starting stage based on semantic keyword analysis of change description (architecture/requirement/design/code changes)"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": "Domain model defining memory structures for managing project knowledge, decisions, patterns, and iteration-level insights in an AI cowork system.",
      "file_path": "crates\\cowork-core\\src\\domain\\memory.rs",
      "functions": [
        "ProjectMemory::new",
        "ProjectMemory::add_decision",
        "ProjectMemory::add_pattern",
        "ProjectMemory::query_decisions",
        "ProjectMemory::query_patterns",
        "Decision::new",
        "Pattern::new",
        "IterationMemory::new",
        "IterationMemory::add_insight",
        "IterationMemory::add_issue",
        "IterationMemory::add_learning",
        "MemoryQueryResult::is_empty",
        "MemoryQueryResult::merge",
        "MemoryQueryResult::to_context_string"
      ],
      "importance_score": 1.0,
      "interfaces": [
        "ProjectMemory",
        "Decision",
        "Pattern",
        "ProjectContext",
        "Dependency",
        "IterationMemory",
        "Insight",
        "Issue",
        "Learning",
        "Importance",
        "MemoryQuery",
        "MemoryScope",
        "MemoryQueryType",
        "MemoryQueryResult"
      ],
      "name": "memory.rs",
      "source_summary": "use chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Project-level memory (across iterations)\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct ProjectMemory {\r\n    pub decisions: Vec<Decision>,\r\n    pub patterns: Vec<Pattern>,\r\n    pub context: ProjectContext,\r\n}\r\n\r\nimpl ProjectMemory {\r\n    pub fn new() -> Self {\r\n        Self::default()\r\n    }\r\n\r\n    pub fn add_decision(&mut self, decision: Decision) {\r\n        self.decisions.push(decision);\r\n    }\r\n\r\n    pub fn add_pattern(&mut self, pattern: Pattern) {\r\n        self.patterns.push(pattern);\r\n    }\r\n\r\n    /// Query decisions by keyword\r\n    pub fn query_decisions(&self, keyword: &str) -> Vec<&Decision> {\r\n        let keyword_lower = keyword.to_lowercase();\r\n        self.decisions\r\n            .iter()\r\n            .filter(|d| {\r\n                d.title.to_lowercase().contains(&keyword_lower)\r\n                    || d.context.to_lowercase().contains(&keyword_lower)\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    /// Query patterns by tag\r\n    pub fn query_patterns(&self, tag: &str) -> Vec<&Pattern> {\r\n        let tag_lower = tag.to_lowercase();\r\n        self.patterns\r\n            .iter()\r\n            .filter(|p| p.tags.iter().any(|t| t.to_lowercase() == tag_lower))\r\n            .collect()\r\n    }\r\n}\r\n\r\n/// Decision - Key project decision\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Decision {\r\n    pub id: String,\r\n    pub title: String,\r\n    pub context: String,\r\n    pub decision: String,\r\n    pub consequences: Vec<String>,\r\n    pub iteration_id: String,\r\n    pub created_at: DateTime<Utc>,\r\n}\r\n\r\nimpl Decision {\r\n    pub fn new(\r\n        title: impl Into<String>,\r\n        context: impl Into<String>,\r\n        decision: impl Into<String>,\r\n        iteration_id: impl Into<String>,\r\n    ) -> Self {\r\n        let now = Utc::now();\r\n        let iteration_id = iteration_id.into();\r\n        Self {\r\n            id: format!(\"dec-{}-{}\", iteration_id, now.timestamp()),\r\n            title: title.into(),\r\n            context: context.into(),\r\n            decision: decision.into(),\r\n            consequences: Vec::new(),\r\n            iteration_id,\r\n            created_at: now,\r\n        }\r\n    }\r\n}\r\n\r\n/// Pattern - Reusable pattern or best practice\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Pattern {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub description: String,\r\n    pub usage: Vec<String>,\r\n    pub tags: Vec<String>,\r\n    pub code_example: Option<String>,\r\n    pub iteration_id: String,\r\n    pub created_at: DateTime<Utc>,\r\n}\r\n\r\nimpl Pattern {\r\n    pub fn new(\r\n        name: impl Into<String>,\r\n        description: impl Into<String>,\r\n        iteration_id: impl Into<String>,\r\n    ) -> Self {\r\n        let now = Utc::now();\r\n        let iteration_id = iteration_id.into();\r\n        Self {\r\n            id: format!(\"pat-{}-{}\", iteration_id, now.timestamp()),\r\n            name: name.into(),\r\n            description: description.into(),\r\n            usage: Vec::new(),\r\n            tags: Vec::new(),\r\n            code_example: None,\r\n            iteration_id,\r\n            created_at: now,\r\n        }\r\n    }\r\n}\r\n\r\n/// Project context - Technical context\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct ProjectContext {\r\n    pub tech_stack: Vec<String>,\r\n    pub architecture_style: Option<String>,\r\n    pub key_dependencies: Vec<Dependency>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Dependency {\r\n    pub name: String,\r\n    pub version: String,\r\n    pub purpose: String,\r\n}\r\n\r\n/// Iteration-level memory (current iteration insights)\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct IterationMemory {\r\n    pub iteration_id: String,\r\n    pub insights: Vec<Insight>,\r\n    pub issues: Vec<Issue>,\r\n    pub learnings: Vec<Learning>,\r\n}\r\n\r\nimpl IterationMemory {\r\n    pub fn new(iteration_id: impl Into<String>) -> Self {\r\n        Self {\r\n            iteration_id: iteration_id.into(),\r\n            insights: Vec::new(),\r\n            issues: Vec::new(),\r\n            learnings: Vec::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add_insight(&mut self, stage: impl Into<String>, content: impl Into<String>) {\r\n        self.insights.push(Insight {\r\n            stage: stage.into(),\r\n            content: content.into(),\r\n            importance: Importance::Important,\r\n            created_at: Utc::now(),\r\n        });\r\n    }\r\n\r\n    pub fn add_issue(&mut self, stage: impl Into<String>, content: impl Into<String>) {\r\n        self.issues.push(Issue {\r\n            stage: stage.into(),\r\n            content: content.into(),\r\n            resolved: false,\r\n            created_at: Utc::now(),\r\n            resolved_at: None,\r\n        });\r\n    }\r\n\r\n    pub fn add_learning(&mut self, content: impl Into<String>) {\r\n        self.learnings.push(Learning {\r\n            content: content.into(),\r\n            created_at: Utc::now(),\r\n        });\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Insight {\r\n    pub stage: String,\r\n    pub content: String,\r\n    pub importance: Importance,\r\n    pub created_at: DateTime<Utc>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Issue {\r\n    pub stage: String,\r\n    pub content: String,\r\n    pub resolved: bool,\r\n    pub created_at: DateTime<Utc>,\r\n    pub resolved_at: Option<DateTime<Utc>>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Learning {\r\n    pub content: String,\r\n    pub created_at: DateTime<Utc>,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum Importance {\r\n    Critical,\r\n    Important,\r\n    Normal,\r\n}\r\n\r\n/// Memory query request\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct MemoryQuery {\r\n    pub scope: MemoryScope,\r\n    pub query_type: MemoryQueryType,\r\n    pub keywords: Vec<String>,\r\n    pub limit: Option<usize>,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum MemoryScope {\r\n    Project,      // Only project-level\r\n    Iteration,    // Only current iteration\r\n    Smart,        // Smart merge (project + current iteration)\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum MemoryQueryType {\r\n    Decisions,\r\n    Patterns,\r\n    Insights,\r\n    All,\r\n}\r\n\r\n/// Memory query result\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct MemoryQueryResult {\r\n    pub decisions: Vec<Decision>,\r\n    pub patterns: Vec<Pattern>,\r\n    pub insights: Vec<Insight>,\r\n}\r\n\r\nimpl MemoryQueryResult {\r\n    pub fn is_empty(&self) -> bool {\r\n        self.decisions.is_empty() && self.patterns.is_empty() && self.insights.is_empty()\r\n    }\r\n\r\n    pub fn merge(&mut self, other: MemoryQueryResult) {\r\n        self.decisions.extend(other.decisions);\r\n        self.patterns.extend(other.patterns);\r\n        self.insights.extend(other.insights);\r\n    }\r\n\r\n    pub fn to_context_string(&self) -> String {\r\n        let mut parts = Vec::new();\r\n\r\n        if !self.decisions.is_empty() {\r\n            parts.push(\"## Key Decisions\\n\".to_string());\r\n            for d in &self.decisions {\r\n                parts.push(format!(\"- {}: {}\", d.title, d.decision));\r\n            }\r\n        }\r\n\r\n        if !self.patterns.is_empty() {\r\n            parts.push(\"\\n## Patterns\\n\".to_string());\r\n            for p in &self.patterns {\r\n                parts.push(format!(\"- {}: {}\", p.name, p.description));\r\n            }\r\n        }\r\n\r\n        if !self.insights.is_empty() {\r\n            parts.push(\"\\n## Insights\\n\".to_string());\r\n            for i in &self.insights {\r\n                parts.push(format!(\"- [{}] {}\", i.stage, i.content));\r\n            }\r\n        }\r\n\r\n        parts.join(\"\\n\")\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 7.0,
      "lines_of_code": 277,
      "number_of_classes": 11,
      "number_of_functions": 15
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The memory.rs component is a foundational domain model that implements a hierarchical memory system for an AI cowork/assistant platform. It provides two levels of memory management: project-level memory that persists across iterations (decisions, patterns, technical context) and iteration-level memory that captures ephemeral insights, issues, and learnings during a specific work session.\n\nThe component is designed to support AI agents in maintaining context awareness and learning from past interactions. ProjectMemory serves as long-term storage, accumulating architectural decisions, reusable patterns, and technical stack information. IterationMemory functions as a working memory buffer, collecting real-time insights and tracking resolved/unresolved issues during development cycles.\n\nKey architectural patterns include:\n1. Separation of concerns between persistent (project) and transient (iteration) memory\n2. Builder pattern via `new()` methods for object construction with automatic timestamp and ID generation\n3. Query capabilities with keyword/tag-based filtering for decision and pattern retrieval\n4. Serialization support for persistence and API communication\n5. Context formatting for AI prompt generation (to_context_string)\n\nThe design enables intelligent memory queries with flexible scopes (project-only, iteration-only, or smart merge) and types (decisions, patterns, insights, or all), supporting context-aware AI interactions that can leverage both historical and current session knowledge.",
    "interfaces": [
      {
        "description": "Project-level memory storage across iterations",
        "interface_type": "struct",
        "name": "ProjectMemory",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "decisions",
            "param_type": "Vec<Decision>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "patterns",
            "param_type": "Vec<Pattern>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "context",
            "param_type": "ProjectContext"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Create new empty ProjectMemory",
        "interface_type": "method",
        "name": "ProjectMemory::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Add a decision to project memory",
        "interface_type": "method",
        "name": "ProjectMemory::add_decision",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "decision",
            "param_type": "Decision"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Add a pattern to project memory",
        "interface_type": "method",
        "name": "ProjectMemory::add_pattern",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "pattern",
            "param_type": "Pattern"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Query decisions by keyword (case-insensitive search in title and context)",
        "interface_type": "method",
        "name": "ProjectMemory::query_decisions",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "keyword",
            "param_type": "&str"
          }
        ],
        "return_type": "Vec<&Decision>",
        "visibility": "public"
      },
      {
        "description": "Query patterns by tag (case-insensitive matching)",
        "interface_type": "method",
        "name": "ProjectMemory::query_patterns",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "tag",
            "param_type": "&str"
          }
        ],
        "return_type": "Vec<&Pattern>",
        "visibility": "public"
      },
      {
        "description": "Key project decision with metadata",
        "interface_type": "struct",
        "name": "Decision",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "context",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "decision",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "consequences",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Create new Decision with auto-generated ID and timestamp",
        "interface_type": "method",
        "name": "Decision::new",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "title",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "context",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "decision",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Reusable pattern or best practice",
        "interface_type": "struct",
        "name": "Pattern",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "usage",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "tags",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "code_example",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Create new Pattern with auto-generated ID and timestamp",
        "interface_type": "method",
        "name": "Pattern::new",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Technical context information of the project",
        "interface_type": "struct",
        "name": "ProjectContext",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "tech_stack",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "architecture_style",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "key_dependencies",
            "param_type": "Vec<Dependency>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Project dependency with version and purpose",
        "interface_type": "struct",
        "name": "Dependency",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "version",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "purpose",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Iteration-level memory for current session insights",
        "interface_type": "struct",
        "name": "IterationMemory",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "insights",
            "param_type": "Vec<Insight>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "issues",
            "param_type": "Vec<Issue>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "learnings",
            "param_type": "Vec<Learning>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Create new IterationMemory for specified iteration",
        "interface_type": "method",
        "name": "IterationMemory::new",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Add insight to iteration memory with Important importance level",
        "interface_type": "method",
        "name": "IterationMemory::add_insight",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "stage",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Add unresolved issue to iteration memory",
        "interface_type": "method",
        "name": "IterationMemory::add_issue",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "stage",
            "param_type": "impl Into<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Add learning to iteration memory",
        "interface_type": "method",
        "name": "IterationMemory::add_learning",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Insight captured during iteration",
        "interface_type": "struct",
        "name": "Insight",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "stage",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "importance",
            "param_type": "Importance"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Issue encountered during iteration with resolution tracking",
        "interface_type": "struct",
        "name": "Issue",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "stage",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "resolved",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "resolved_at",
            "param_type": "Option<DateTime<Utc>>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Learning from iteration",
        "interface_type": "struct",
        "name": "Learning",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Importance level enum with Critical, Important, and Normal variants (snake_case serialization)",
        "interface_type": "enum",
        "name": "Importance",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Memory query request structure",
        "interface_type": "struct",
        "name": "MemoryQuery",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "scope",
            "param_type": "MemoryScope"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "query_type",
            "param_type": "MemoryQueryType"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "keywords",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "limit",
            "param_type": "Option<usize>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Query scope enum with Project, Iteration, and Smart variants (snake_case serialization)",
        "interface_type": "enum",
        "name": "MemoryScope",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Query type enum with Decisions, Patterns, Insights, and All variants (snake_case serialization)",
        "interface_type": "enum",
        "name": "MemoryQueryType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Memory query result containing decisions, patterns, and insights",
        "interface_type": "struct",
        "name": "MemoryQueryResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "decisions",
            "param_type": "Vec<Decision>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "patterns",
            "param_type": "Vec<Pattern>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "insights",
            "param_type": "Vec<Insight>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Check if query result contains no items",
        "interface_type": "method",
        "name": "MemoryQueryResult::is_empty",
        "parameters": [],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Merge another MemoryQueryResult into this one",
        "interface_type": "method",
        "name": "MemoryQueryResult::merge",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "other",
            "param_type": "MemoryQueryResult"
          }
        ],
        "return_type": "null",
        "visibility": "public"
      },
      {
        "description": "Convert query result to formatted markdown string for AI context",
        "interface_type": "method",
        "name": "MemoryQueryResult::to_context_string",
        "parameters": [],
        "return_type": "String",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define and manage project-level persistent memory structures including architectural decisions, reusable patterns, and technical context information",
      "Define and manage iteration-level transient memory structures for capturing insights, tracking issues, and recording learnings during development sessions",
      "Provide query and search capabilities for retrieving decisions by keyword and patterns by tags from memory stores",
      "Generate formatted context strings from memory data for AI prompt engineering and context injection",
      "Implement data serialization/deserialization support for memory persistence and inter-component communication"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": "Core domain model defining software project entities and iteration management structures",
      "file_path": "crates\\cowork-core\\src\\domain\\project.rs",
      "functions": [
        "Project::new",
        "Project::add_iteration",
        "Project::set_current_iteration",
        "Project::get_latest_completed_iteration",
        "Project::next_iteration_number",
        "IterationStatus::fmt"
      ],
      "importance_score": 1.0,
      "interfaces": [
        "new(name: impl Into<String>) -> Self",
        "add_iteration(&mut self, summary: IterationSummary)",
        "set_current_iteration(&mut self, iteration_id: String)",
        "get_latest_completed_iteration(&self) -> Option<&IterationSummary>",
        "next_iteration_number(&self) -> u32",
        "std::fmt::Display for IterationStatus"
      ],
      "name": "project.rs",
      "source_summary": "use chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Project - Root entity representing a software project\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Project {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub created_at: DateTime<Utc>,\r\n    pub updated_at: DateTime<Utc>,\r\n    pub metadata: ProjectMetadata,\r\n    pub current_iteration_id: Option<String>,\r\n    pub iterations: Vec<IterationSummary>,\r\n}\r\n\r\nimpl Project {\r\n    pub fn new(name: impl Into<String>) -> Self {\r\n        let now = Utc::now();\r\n        Self {\r\n            id: format!(\"proj-{}\", now.timestamp()),\r\n            name: name.into(),\r\n            created_at: now,\r\n            updated_at: now,\r\n            metadata: ProjectMetadata::default(),\r\n            current_iteration_id: None,\r\n            iterations: Vec::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add_iteration(&mut self, summary: IterationSummary) {\r\n        self.iterations.push(summary);\r\n        self.updated_at = Utc::now();\r\n    }\r\n\r\n    pub fn set_current_iteration(&mut self, iteration_id: String) {\r\n        self.current_iteration_id = Some(iteration_id);\r\n        self.updated_at = Utc::now();\r\n    }\r\n\r\n    pub fn get_latest_completed_iteration(&self) -> Option<&IterationSummary> {\r\n        self.iterations\r\n            .iter()\r\n            .filter(|i| i.status == IterationStatus::Completed)\r\n            .max_by_key(|i| i.number)\r\n    }\r\n\r\n    pub fn next_iteration_number(&self) -> u32 {\r\n        self.iterations.len() as u32 + 1\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct ProjectMetadata {\r\n    pub tech_stack: Vec<String>,\r\n    pub project_type: String,\r\n    pub language: String,\r\n}\r\n\r\n/// Summary of an iteration for listing\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct IterationSummary {\r\n    pub id: String,\r\n    pub number: u32,\r\n    pub title: String,\r\n    pub status: IterationStatus,\r\n    pub completed_stages: Vec<String>,\r\n    pub created_at: DateTime<Utc>,\r\n}\r\n\r\n/// Iteration status\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum IterationStatus {\r\n    Draft,\r\n    Running,\r\n    Paused,\r\n    Completed,\r\n    Failed,\r\n}\r\n\r\nimpl std::fmt::Display for IterationStatus {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            IterationStatus::Draft => write!(f, \"draft\"),\r\n            IterationStatus::Running => write!(f, \"running\"),\r\n            IterationStatus::Paused => write!(f, \"paused\"),\r\n            IterationStatus::Completed => write!(f, \"completed\"),\r\n            IterationStatus::Failed => write!(f, \"failed\"),\r\n        }\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 4.0,
      "lines_of_code": 91,
      "number_of_classes": 4,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 1,
        "name": "chrono",
        "path": "chrono::{DateTime, Utc}",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 2,
        "name": "serde",
        "path": "serde::{Deserialize, Serialize}",
        "version": null
      }
    ],
    "detailed_description": "## Detailed Functional Description\n\nThis component (`project.rs`) serves as the foundational domain model for managing software projects within the cowork-core system. It implements an Entity-based architecture pattern typical of Domain-Driven Design (DDD), encapsulating both the data structure and core business behaviors related to project lifecycle management.\n\n### Core Functionality:\n\n**Project Entity** - The root aggregate that represents a complete software project with the following capabilities:\n- Automatic ID generation based on timestamp (`proj-{timestamp}`)\n- Timestamp tracking for creation and last modification\n- Management of project metadata (tech stack, project type, programming language)\n- Iteration lifecycle management with support for multiple iterations\n- Current iteration tracking to identify the active work phase\n\n**Iteration Tracking System** - Provides comprehensive iteration management:\n- Adds iteration summaries to the project's iteration collection\n- Maintains a reference to the currently active iteration\n- Retrieves the latest completed iteration for historical analysis\n- Automatically calculates the next iteration number based on existing iterations\n\n**Status Management** - Implements a state machine for iteration progression with five distinct states:\n- Draft: Initial planning phase\n- Running: Active development\n- Paused: Temporarily suspended\n- Completed: Successfully finished\n- Failed: Terminated due to errors or issues\n\n### Business Logic Implementation:\n\nThe component implements several important business rules:\n1. **Immutable ID Generation**: Project IDs are generated once during creation and cannot be modified\n2. **Automatic Timestamp Updates**: All mutation operations automatically update the `updated_at` timestamp\n3. **Iteration Numbering**: Uses a simple incrementing strategy (count-based) for iteration numbering\n4. **Status-Based Filtering**: The `get_latest_completed_iteration` method applies business logic to filter and sort iterations based on completion status and iteration number\n\n### Data Persistence Support:\n\nThrough the `Serialize` and `Deserialize` traits from serde, the component supports seamless serialization/deserialization for:\n- Database persistence (likely PostgreSQL or similar)\n- API responses and requests\n- Configuration file storage\n- Inter-service communication in distributed systems\n\nThe component acts as a pure domain model with minimal dependencies, focusing solely on business rules and entity relationships rather than infrastructure concerns.",
    "interfaces": [
      {
        "description": "Factory method that creates a new Project instance with auto-generated ID, current timestamps, empty iterations, and default metadata",
        "interface_type": "constructor",
        "name": "Project::new",
        "parameters": [
          {
            "description": "The display name for the new project",
            "is_optional": false,
            "name": "name",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Adds an iteration summary to the project and automatically updates the updated_at timestamp",
        "interface_type": "mutator",
        "name": "Project::add_iteration",
        "parameters": [
          {
            "description": "The iteration summary to add to the project's iteration collection",
            "is_optional": false,
            "name": "summary",
            "param_type": "IterationSummary"
          }
        ],
        "return_type": "void",
        "visibility": "public"
      },
      {
        "description": "Updates the current_iteration_id field and automatically updates the updated_at timestamp",
        "interface_type": "mutator",
        "name": "Project::set_current_iteration",
        "parameters": [
          {
            "description": "The ID of the iteration to set as current",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          }
        ],
        "return_type": "void",
        "visibility": "public"
      },
      {
        "description": "Filters iterations to find only those with Completed status and returns the one with the highest iteration number, or None if no completed iterations exist",
        "interface_type": "accessor",
        "name": "Project::get_latest_completed_iteration",
        "parameters": [],
        "return_type": "Option<&IterationSummary>",
        "visibility": "public"
      },
      {
        "description": "Calculates and returns the next iteration number based on the current count of iterations (current count + 1)",
        "interface_type": "accessor",
        "name": "Project::next_iteration_number",
        "parameters": [],
        "return_type": "u32",
        "visibility": "public"
      },
      {
        "description": "Implements string formatting for IterationStatus enum, returning lowercase snake_case representations (draft, running, paused, completed, failed)",
        "interface_type": "trait_implementation",
        "name": "std::fmt::Display for IterationStatus",
        "parameters": [
          {
            "description": "Formatter for output",
            "is_optional": false,
            "name": "f",
            "param_type": "&mut std::fmt::Formatter<'_>"
          }
        ],
        "return_type": "std::fmt::Result",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Project lifecycle management - Creating, modifying, and tracking project entities with automatic timestamp updates and ID generation",
      "Iteration tracking and state management - Managing iteration collections, current iteration selection, and status-based filtering of iterations",
      "Project metadata encapsulation - Storing and organizing project-specific information including tech stack, project type, and programming language",
      "Business rule enforcement - Implementing iteration numbering logic, status transitions, and completed iteration retrieval logic",
      "Serialization support - Providing data persistence and API integration capabilities through serde trait implementations"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": "Main entry point for the React-based GUI application that initializes the application and configures the global theme system.",
      "file_path": "crates\\cowork-gui\\src\\main.jsx",
      "functions": [],
      "importance_score": 1.0,
      "interfaces": [],
      "name": "main.jsx",
      "source_summary": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { ConfigProvider, theme } from 'antd';\nimport App from './App.jsx';\nimport './styles.css';\n\n// 清新浅色主题配置\nconst lightTheme = {\n  algorithm: theme.defaultAlgorithm,\n  token: {\n    // 主色调 - 清新的蓝色\n    colorPrimary: '#2563eb',\n    colorPrimaryHover: '#1d4ed8',\n    colorPrimaryActive: '#1e40af',\n    \n    // 背景色 - 纯净白色系\n    colorBgBase: '#ffffff',\n    colorBgContainer: '#f8fafc',\n    colorBgElevated: '#f1f5f9',\n    colorBgLayout: '#f8fafc',\n    \n    // 边框颜色\n    colorBorder: '#e2e8f0',\n    colorBorderSecondary: '#f1f5f9',\n    \n    // 文字颜色\n    colorText: '#1e293b',\n    colorTextSecondary: '#64748b',\n    colorTextTertiary: '#94a3b8',\n    \n    // 圆角\n    borderRadius: 8,\n    borderRadiusLG: 12,\n    borderRadiusSM: 6,\n    \n    // 阴影\n    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05)',\n    boxShadowSecondary: '0 4px 12px rgba(0, 0, 0, 0.08)',\n    \n    // 字体\n    fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif',\n    \n    // 间距\n    padding: 16,\n    paddingLG: 24,\n    paddingSM: 12,\n  },\n  components: {\n    Layout: {\n      headerBg: '#ffffff',\n      siderBg: '#f8fafc',\n      bodyBg: '#ffffff',\n    },\n    Menu: {\n      itemBg: 'transparent',\n      itemSelectedBg: '#dbeafe',\n      itemColor: '#64748b',\n      itemSelectedColor: '#2563eb',\n      itemHoverBg: '#f1f5f9',\n      itemHoverColor: '#1e293b',\n    },\n    Button: {\n      borderRadius: 8,\n      boxShadow: '0 1px 2px rgba(0, 0, 0, 0.05)',\n    },\n    Input: {\n      borderRadius: 10,\n      activeShadow: '0 0 0 3px rgba(37, 99, 235, 0.1)',\n    },\n    Card: {\n      borderRadius: 12,\n      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.05)',\n    },\n    Tabs: {\n      cardBg: '#f8fafc',\n      itemColor: '#64748b',\n      itemSelectedColor: '#2563eb',\n    },\n    Tag: {\n      borderRadius: 6,\n    },\n    Alert: {\n      borderRadius: 10,\n    },\n    Modal: {\n      borderRadius: 16,\n    },\n    Dropdown: {\n      borderRadius: 12,\n    },\n  },\n};\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <ConfigProvider theme={lightTheme}>\n    <App />\n  </ConfigProvider>\n);\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 98,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "react-dom",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "component",
        "is_external": false,
        "line_number": 4,
        "name": "./App.jsx",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "stylesheet",
        "is_external": false,
        "line_number": 5,
        "name": "./styles.css",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Component Functional Description\n\nThe main.jsx component serves as the application entry point for a React-based GUI application built with Ant Design. Its primary function is to bootstrap the application and establish the global visual design system.\n\n### Core Functionality:\n\n1. **Application Bootstrap**: Initializes the React application using the modern ReactDOM.createRoot() API, which is the recommended approach for React 18+ applications.\n\n2. **Theme Configuration**: Defines and applies a comprehensive light/fresh theme configuration that encompasses:\n   - **Color System**: Primary colors using a fresh blue palette (#2563eb base), background colors with a pure white foundation, border colors, and text colors across three hierarchy levels (primary, secondary, tertiary)\n   - **Design Tokens**: Border radius values (8px default, 12px large, 6px small), box shadow configurations, font family specification, and spacing system (12px, 16px, 24px)\n   - **Component-Specific Styling**: Custom theme overrides for 10 Ant Design components (Layout, Menu, Button, Input, Card, Tabs, Tag, Alert, Modal, Dropdown) with tailored color schemes, backgrounds, and interactive states\n\n3. **Style Integration**: Imports and applies global styles through the styles.css file, working in conjunction with the ConfigProvider to create a cohesive visual system.\n\n4. **Component Rendering**: Wraps the main App component within the ConfigProvider context, ensuring all child components inherit the configured theme.\n\n### Design Philosophy:\nThe theme follows a \"fresh and clean\" design philosophy with:\n- Light color palette focused on blue (#2563eb) as the primary accent\n- White-based backgrounds with subtle gray variations for depth\n- Soft shadows and rounded corners for a modern, friendly aesthetic\n- Clear visual hierarchy through the three-tier text color system\n- Consistent spacing and sizing scale across all components",
    "interfaces": [],
    "responsibilities": [
      "Application initialization and bootstrapping by creating the React root and rendering the main App component",
      "Global theme system configuration and management, defining the comprehensive light theme with color palettes, typography, spacing, and component-specific styling",
      "Visual design system establishment by providing design tokens and aesthetic guidelines that propagate throughout the entire application",
      "Dependency orchestration by importing and configuring React, ReactDOM, and Ant Design libraries with proper integration",
      "Style coordination by combining global CSS imports with component-level theming for a unified user experience"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\llm\\config.rs",
      "functions": [
        "from_file",
        "from_env",
        "create_llm_client",
        "test_config_parse"
      ],
      "importance_score": 0.9,
      "interfaces": [
        "LlmConfig struct",
        "ModelConfig struct",
        "ModelConfig::from_file(&str) -> Result<Self>",
        "ModelConfig::from_env() -> Result<Self>",
        "create_llm_client(&LlmConfig) -> Result<Arc<dyn Llm>>",
        "std::fmt::Debug trait for structs",
        "serde::Serialize/Deserialize traits"
      ],
      "name": "config.rs",
      "source_summary": "// LLM configuration using adk-rust's OpenAI client\nuse anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse adk_model::openai::{OpenAIClient, OpenAIConfig};\nuse adk_core::Llm;\n\n/// Configuration for LLM from config.toml\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LlmConfig {\n    pub api_base_url: String,\n    pub api_key: String,\n    pub model_name: String,\n}\n\n/// Configuration for the entire model setup\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ModelConfig {\n    pub llm: LlmConfig,\n}\n\nimpl ModelConfig {\n    /// Load from TOML file\n    pub fn from_file(path: &str) -> Result<Self> {\n        let content = std::fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read config file: {}\", path))?;\n        let config: Self = toml::from_str(&content)\n            .with_context(|| \"Failed to parse config.toml\")?;\n        Ok(config)\n    }\n\n    /// Load from environment variables (fallback)\n    pub fn from_env() -> Result<Self> {\n        Ok(Self {\n            llm: LlmConfig {\n                api_base_url: std::env::var(\"LLM_API_BASE_URL\")\n                    .with_context(|| \"LLM_API_BASE_URL not set\")?,\n                api_key: std::env::var(\"LLM_API_KEY\")\n                    .with_context(|| \"LLM_API_KEY not set\")?,\n                model_name: std::env::var(\"LLM_MODEL_NAME\")\n                    .with_context(|| \"LLM_MODEL_NAME not set\")?,\n            },\n        })\n    }\n}\n\n/// Create an LLM client using adk-rust's OpenAI client with custom base URL\n/// \n/// This uses the built-in OpenAIClient from adk-model and configures it\n/// to point to a custom OpenAI-compatible endpoint.\n/// \n/// **Rate Limiting**: Automatically wraps the client with:\n/// 1. Global semaphore to limit concurrent requests (max 1 at a time)\n/// 2. Per-request delay (2 seconds) to ensure <30 calls per minute\npub fn create_llm_client(config: &LlmConfig) -> Result<Arc<dyn Llm>> {\n    use crate::llm::rate_limiter::RateLimitedLlm;\n\n    // Initialize global rate limiter (max 1 concurrent request)\n    // This ensures no more than 1 request is sent at any given time\n    crate::llm::rate_limiter::init_global_rate_limiter(1);\n\n    // Create OpenAI config with custom base URL using OpenAIConfig::compatible\n    let openai_config = OpenAIConfig::compatible(\n        &config.api_key,\n        &config.api_base_url,\n        &config.model_name,\n    );\n\n    // Create the OpenAI client\n    let client = OpenAIClient::new(openai_config)\n        .with_context(|| \"Failed to create OpenAI client\")?;\n\n    // Wrap with rate limiter (2-second delay + global semaphore)\n    let rate_limited_client = RateLimitedLlm::with_default_delay(Arc::new(client));\n\n    Ok(Arc::new(rate_limited_client))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_config_parse() {\n        let toml_content = r#\"\n[llm]\napi_base_url = \"http://localhost:8000/v1\"\napi_key = \"test-key\"\nmodel_name = \"gpt-4\"\n        \"#;\n\n        let config: ModelConfig = toml::from_str(toml_content).unwrap();\n        assert_eq!(config.llm.api_base_url, \"http://localhost:8000/v1\");\n        assert_eq!(config.llm.api_key, \"test-key\");\n        assert_eq!(config.llm.model_name, \"gpt-4\");\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 3.0,
      "lines_of_code": 97,
      "number_of_classes": 2,
      "number_of_functions": 4
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 2,
        "name": "anyhow",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "serde",
        "path": "serde",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 5,
        "name": "adk_model::openai::OpenAIClient",
        "path": "adk_model::openai",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 5,
        "name": "adk_model::openai::OpenAIConfig",
        "path": "adk_model::openai",
        "version": null
      },
      {
        "dependency_type": "trait",
        "is_external": true,
        "line_number": 6,
        "name": "adk_core::Llm",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 38,
        "name": "toml",
        "path": "toml",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": false,
        "line_number": 60,
        "name": "crate::llm::rate_limiter::RateLimitedLlm",
        "path": "crate::llm::rate_limiter",
        "version": null
      }
    ],
    "detailed_description": "This configuration module is responsible for managing LLM (Large Language Model) client configuration and initialization within the cowork-core system. It provides a flexible configuration system that supports loading LLM settings from TOML configuration files or environment variables, and creates rate-limited LLM client instances.\n\nThe module defines two primary configuration structures: LlmConfig stores the core LLM connection parameters (api_base_url, api_key, model_name), while ModelConfig wraps LlmConfig and provides convenient loading methods. The create_llm_client function is the main factory method that initializes an OpenAI-compatible client with automatic rate limiting to prevent API throttling.\n\nA key architectural decision is the integration of a global rate limiter that restricts concurrent requests to a maximum of 1 and enforces a 2-second delay between requests, ensuring the system stays within typical API rate limits (e.g., <30 calls per minute). The client creation leverages adk-rust's OpenAIClient configured with a custom base URL, enabling support for OpenAI-compatible endpoints.\n\nThe module follows Rust best practices with proper error handling using anyhow::Result, comprehensive documentation, and includes unit tests for configuration parsing.",
    "interfaces": [
      {
        "description": "Configuration structure holding LLM API connection parameters with public fields for direct access and Serialize/Deserialize support for TOML parsing",
        "interface_type": "data_struct",
        "name": "LlmConfig struct",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Static method that reads and parses a TOML configuration file, returning a ModelConfig instance or error with context",
        "interface_type": "static_method",
        "name": "ModelConfig::from_file",
        "parameters": [
          {
            "description": "File path to the TOML configuration file",
            "is_optional": false,
            "name": "path",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Self>",
        "visibility": "public"
      },
      {
        "description": "Static method that loads LLM configuration from environment variables (LLM_API_BASE_URL, LLM_API_KEY, LLM_MODEL_NAME) providing deployment flexibility",
        "interface_type": "static_method",
        "name": "ModelConfig::from_env",
        "parameters": [],
        "return_type": "Result<Self>",
        "visibility": "public"
      },
      {
        "description": "Factory function that creates a rate-limited LLM client with OpenAI-compatible endpoint support and global rate limiter initialization",
        "interface_type": "function",
        "name": "create_llm_client",
        "parameters": [
          {
            "description": "Reference to LlmConfig containing API settings",
            "is_optional": false,
            "name": "config",
            "param_type": "&LlmConfig"
          }
        ],
        "return_type": "Result<Arc<dyn Llm>>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Configuration management for LLM client parameters (API URL, key, model name)",
      "Loading and parsing configuration from TOML files with proper error handling",
      "Fallback configuration loading from environment variables for deployment flexibility",
      "LLM client instantiation with OpenAI-compatible API wrapper",
      "Rate limiting enforcement to prevent API throttling and manage request concurrency"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "A resilient agent wrapper implementing Human-in-the-Loop (HITL) capabilities for intelligent agent execution with error recovery, interactive user prompts, and retry mechanisms.",
      "file_path": "crates\\cowork-core\\src\\agents\\hitl.rs",
      "functions": [
        "ResilientAgent::new",
        "ResilientAgent::handle_error",
        "ResilientStream::new",
        "ResilientStream::start_retry",
        "ResilientStream::poll_next"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Agent",
        "Stream"
      ],
      "name": "hitl.rs",
      "source_summary": "use adk_core::{Agent, Event, AdkError, InvocationContext};\nuse crate::interaction::{InteractiveBackend, InputOption, InputResponse, MessageLevel};\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::pin::Pin;\nuse std::task::{Context as TaskContext, Poll};\nuse futures::{Stream, Future};\n\ntype AgentOutput = Pin<Box<dyn Stream<Item = Result<Event, AdkError>> + Send>>;\n\npub struct ResilientAgent {\n    inner: Arc<dyn Agent>,\n    subs: Vec<Arc<dyn Agent>>,\n    retry_count: Arc<AtomicU32>,\n    interaction: Arc<dyn InteractiveBackend>,\n}\n\nimpl ResilientAgent {\n    const MAX_RETRY_ATTEMPTS: u32 = 3;\n    \n    pub fn new(inner: Arc<dyn Agent>, interaction: Arc<dyn InteractiveBackend>) -> Self {\n        Self {\n            inner: inner.clone(),\n            subs: vec![inner],\n            retry_count: Arc::new(AtomicU32::new(0)),\n            interaction,\n        }\n    }\n    \n    // Helper for immediate errors (recursion in async fn)\n    async fn handle_error(&self, context: Arc<dyn InvocationContext>, e: AdkError) -> Result<AgentOutput, AdkError> {\n        let current_retry = self.retry_count.fetch_add(1, Ordering::SeqCst);\n        \n        // Check if max retry attempts reached\n        if current_retry >= Self::MAX_RETRY_ATTEMPTS {\n            self.interaction.show_message(\n                MessageLevel::Error,\n                format!(\"Maximum retry attempts ({}) reached for agent '{}'\", Self::MAX_RETRY_ATTEMPTS, self.name())\n            ).await;\n            self.retry_count.store(0, Ordering::SeqCst);\n            return Err(AdkError::Tool(format!(\n                \"Agent '{}' failed after {} retry attempts\", \n                self.name(), \n                Self::MAX_RETRY_ATTEMPTS\n            )));\n        }\n        \n        self.interaction.show_message(\n            MessageLevel::Warning,\n            format!(\"Agent '{}' encountered error: {}\", self.name(), e)\n        ).await;\n        \n        let options = vec![\n            InputOption {\n                id: \"retry\".to_string(),\n                label: \"Retry (reset counter)\".to_string(),\n                description: Some(\"Retry the agent execution\".to_string()),\n            },\n            InputOption {\n                id: \"guidance\".to_string(),\n                label: \"Provide Guidance & Retry\".to_string(),\n                description: Some(\"Provide feedback to guide the agent\".to_string()),\n            },\n            InputOption {\n                id: \"abort\".to_string(),\n                label: \"Abort\".to_string(),\n                description: Some(\"Stop the execution\".to_string()),\n            },\n        ];\n        \n        let response = self.interaction.request_input(\n            \"How would you like to proceed?\",\n            options,\n            None\n        ).await.map_err(|e| AdkError::Tool(format!(\"Input error: {}\", e)))?;\n\n        match response {\n            InputResponse::Selection(id) => match id.as_str() {\n                \"retry\" => {\n                    self.interaction.show_message(MessageLevel::Info, \"🔄 Retrying agent execution...\".to_string()).await;\n                    return self.run(context).await;\n                },\n                \"guidance\" => {\n                    // In the future, we could inject guidance into context\n                    self.interaction.show_message(MessageLevel::Info, \"🔄 Retrying with new guidance...\".to_string()).await;\n                    return self.run(context).await;\n                },\n                \"abort\" => {\n                    self.retry_count.store(0, Ordering::SeqCst);\n                    return Err(e);\n                },\n                _ => Err(e),\n            },\n            InputResponse::Cancel => {\n                self.retry_count.store(0, Ordering::SeqCst);\n                Err(e)\n            },\n            _ => Err(e),\n        }\n    }\n}\n\n#[async_trait]\nimpl Agent for ResilientAgent {\n    fn name(&self) -> &str {\n        self.inner.name()\n    }\n\n    fn description(&self) -> &str {\n        self.inner.description()\n    }\n\n    fn sub_agents(&self) -> &[Arc<dyn Agent>] {\n        &self.subs\n    }\n\n    async fn run(&self, context: Arc<dyn InvocationContext>) -> Result<AgentOutput, AdkError> {\n        // Initial run\n        match self.inner.run(context.clone()).await {\n            Ok(stream) => {\n                // Success - reset retry counter\n                self.retry_count.store(0, Ordering::SeqCst);\n                // Wrap the stream to handle errors during iteration\n                Ok(Box::pin(ResilientStream::new(\n                    self.inner.clone(),\n                    context,\n                    stream,\n                    self.retry_count.clone(),\n                    self.interaction.clone(),\n                )))\n            },\n            Err(e) => {\n                // Handle immediate errors\n                let err_msg = e.to_string();\n                if err_msg.contains(\"Max iterations\") {\n                     return self.handle_error(context, e).await;\n                }\n                Err(e)\n            }\n        }\n    }\n}\n\n// ============================================================================\n// ResilientStream Implementation\n// ============================================================================\n\nenum StreamState {\n    Streaming(AgentOutput),\n    Retrying(Pin<Box<dyn Future<Output = Result<AgentOutput, AdkError>> + Send>>),\n}\n\nstruct ResilientStream {\n    inner_agent: Arc<dyn Agent>,\n    context: Arc<dyn InvocationContext>,\n    state: StreamState,\n    #[allow(dead_code)]\n    agent_name: String,\n    #[allow(dead_code)]\n    retry_count: Arc<AtomicU32>,\n    interaction: Arc<dyn InteractiveBackend>,\n}\n\nimpl ResilientStream {\n    fn new(\n        inner_agent: Arc<dyn Agent>,\n        context: Arc<dyn InvocationContext>,\n        stream: AgentOutput,\n        retry_count: Arc<AtomicU32>,\n        interaction: Arc<dyn InteractiveBackend>,\n    ) -> Self {\n        let _agent_name = inner_agent.name().to_string();\n        Self {\n            inner_agent,\n            context,\n            state: StreamState::Streaming(stream),\n            agent_name: _agent_name,\n            retry_count,\n            interaction,\n        }\n    }\n\n    fn start_retry(&mut self) {\n        let agent = self.inner_agent.clone();\n        let ctx = self.context.clone();\n        let fut = Box::pin(async move {\n            agent.run(ctx).await\n        });\n        self.state = StreamState::Retrying(fut);\n    }\n}\n\nimpl Stream for ResilientStream {\n    type Item = Result<Event, AdkError>;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut TaskContext<'_>) -> Poll<Option<Self::Item>> {\n        loop {\n            match &mut self.state {\n                StreamState::Streaming(stream) => {\n                    match stream.as_mut().poll_next(cx) {\n                        Poll::Ready(Some(Err(e))) => {\n                            let err_msg = e.to_string();\n                            if err_msg.contains(\"Max iterations\") {\n                                // Async interaction is not possible during stream polling\n                                // We'll need to show message and offer retry options\n                                // For now, use blocking approach (CLI backend handles this synchronously)\n                                \n                                let options = vec![\n                                    InputOption {\n                                        id: \"retry\".to_string(),\n                                        label: \"Retry (reset counter)\".to_string(),\n                                        description: Some(\"Retry the agent execution\".to_string()),\n                                    },\n                                    InputOption {\n                                        id: \"guidance\".to_string(),\n                                        label: \"Provide Guidance & Retry\".to_string(),\n                                        description: Some(\"Provide feedback to guide the agent\".to_string()),\n                                    },\n                                    InputOption {\n                                        id: \"abort\".to_string(),\n                                        label: \"Abort\".to_string(),\n                                        description: Some(\"Stop the execution\".to_string()),\n                                    },\n                                ];\n\n                                // This will block for CLI, but for GUI it needs to be handled differently\n                                // For now, we'll use tokio::task::block_in_place to allow async during blocking\n                                let interaction_clone = self.interaction.clone();\n                                let response = tokio::task::block_in_place(|| {\n                                    tokio::runtime::Handle::current().block_on(async {\n                                        interaction_clone.request_input(\n                                            \"How would you like to proceed?\",\n                                            options,\n                                            None\n                                        ).await\n                                    })\n                                }).map_err(|e| AdkError::Tool(format!(\"Input error: {}\", e)))?;\n\n                                match response {\n                                    InputResponse::Selection(id) => match id.as_str() {\n                                        \"retry\" | \"guidance\" => {\n                                            self.start_retry();\n                                            continue;\n                                        },\n                                        \"abort\" => return Poll::Ready(Some(Err(e))),\n                                        _ => return Poll::Ready(Some(Err(e))),\n                                    },\n                                    _ => return Poll::Ready(Some(Err(e))),\n                                }\n                            }\n                            return Poll::Ready(Some(Err(e)));\n                        },\n                        Poll::Ready(other) => return Poll::Ready(other),\n                        Poll::Pending => return Poll::Pending,\n                    }\n                },\n                StreamState::Retrying(fut) => {\n                    match fut.as_mut().poll(cx) {\n                        Poll::Ready(Ok(new_stream)) => {\n                            self.state = StreamState::Streaming(new_stream);\n                            continue;\n                        },\n                        Poll::Ready(Err(e)) => {\n                            return Poll::Ready(Some(Err(e)));\n                        },\n                        Poll::Pending => return Poll::Pending,\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 273,
      "number_of_classes": 2,
      "number_of_functions": 5
    },
    "dependencies": [
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 1,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 2,
        "name": "crate::interaction",
        "path": "crate::interaction",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 3,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 4,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 5,
        "name": "std::sync::atomic::AtomicU32",
        "path": "std::sync::atomic",
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 6,
        "name": "std::pin::Pin",
        "path": "std::pin",
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 6,
        "name": "std::task",
        "path": "std::task",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 7,
        "name": "futures",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Detailed Functional Description\n\nThe `hitl.rs` component implements a **ResilientAgent** wrapper that provides Human-in-the-Loop (HITL) capabilities for intelligent agents in the cowork system. The component acts as a middleware layer that wraps any agent implementing the `Agent` trait, adding resilience through error handling, automatic retry mechanisms, and interactive human intervention capabilities.\n\n### Core Functionality:\n\n1. **Agent Execution Wrapping**: The component wraps an inner agent and delegates all trait method calls while adding error interception and recovery logic.\n\n2. **Error Handling Pipeline**: When an agent encounters errors (particularly \"Max iterations\" errors), the component intercepts them and presents interactive options to the user:\n   - **Retry**: Reset the retry counter and re-execute the agent\n   - **Provide Guidance & Retry**: Allow human guidance injection before retrying (currently placeholder for future functionality)\n   - **Abort**: Stop execution and propagate the error\n\n3. **Retry Management**: Implements a bounded retry mechanism with:\n   - Maximum of 3 retry attempts (configurable via `MAX_RETRY_ATTEMPTS` constant)\n   - Thread-safe retry counter using `Arc<AtomicU32>`\n   - Automatic counter reset on successful execution or explicit abort\n\n4. **Resilient Stream Processing**: The `ResilientStream` wrapper enhances the agent's event stream with:\n   - Error detection during streaming\n   - Interactive recovery options when stream errors occur\n   - State machine managing streaming vs. retrying states\n   - Synchronous blocking support for CLI backends during stream polling\n\n5. **Async/Await Architecture**: Fully asynchronous implementation using Rust's async ecosystem with proper pinning, context management, and task polling.\n\n### Business Logic Flow:\n\n- **Initial Run**: Execute the wrapped agent with the provided context\n- **Success Path**: Reset retry counter and wrap the output stream in a ResilientStream\n- **Error Path**: Check retry count, present options to user, and either retry with updated counter or abort\n- **Streaming Phase**: Monitor stream events, intercept errors, offer recovery options, and manage state transitions between streaming and retrying",
    "interfaces": [
      {
        "description": "Core agent trait from adk_core that defines the contract for agent implementations including name(), description(), sub_agents(), and run() methods",
        "interface_type": "trait",
        "name": "Agent",
        "parameters": [
          {
            "description": "Execution context for the agent run operation",
            "is_optional": false,
            "name": "context",
            "param_type": "Arc<dyn InvocationContext>"
          }
        ],
        "return_type": "Result<AgentOutput, AdkError>",
        "visibility": "public"
      },
      {
        "description": "Futures Stream trait implemented by ResilientStream to provide asynchronous iteration over agent events with error handling",
        "interface_type": "trait",
        "name": "Stream",
        "parameters": [
          {
            "description": "Task context for async polling",
            "is_optional": false,
            "name": "cx",
            "param_type": "&mut TaskContext<'_>"
          },
          {
            "description": "Pinned reference to self for polling",
            "is_optional": false,
            "name": "self",
            "param_type": "Pin<&mut Self>"
          }
        ],
        "return_type": "Poll<Option<Self::Item>>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Error Recovery and Retry Management - Intercepts agent errors, manages bounded retry attempts (max 3), tracks retry count using thread-safe atomic operations, and orchestrates recovery workflows",
      "Human-in-the-Loop Interaction - Presents interactive options to users when agents fail, handles user responses (retry, guidance, abort), and manages communication through the InteractiveBackend",
      "Resilient Stream Processing - Wraps agent output streams with error handling capabilities, manages state transitions between streaming and retrying phases, and provides synchronous blocking support for CLI interactions during stream polling",
      "Agent Execution Orchestration - Manages the complete lifecycle of wrapped agent execution, delegates trait method calls, and ensures proper resource cleanup and counter reset on success/failure"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Intelligent iteration scheduling agent that analyzes user intent and auto-schedules Modify mode for completed projects",
      "file_path": "crates\\cowork-core\\src\\agents\\iterative_assistant.rs",
      "functions": [
        "new",
        "analyze_user_intent",
        "generate_modify_suggestion",
        "generate_clarification_questions"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "LlmProvider",
        "IterativeAssistant",
        "IterationType",
        "SuggestedAction",
        "IterationIntent",
        "ModifySuggestion",
        "RiskAssessment",
        "SessionStatus",
        "ProjectContext",
        "SessionInfo",
        "ChatResponse"
      ],
      "name": "iterative_assistant.rs",
      "source_summary": "// Iterative Assistant Agent - Intelligent iteration scheduling\n// Analyzes user intent and auto-schedules Modify mode for completed projects\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\n// ============================================================================\n// Data Structures\n// ============================================================================\n\n/// Iteration intent types\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum IterationType {\n    ContinueDevelopment,\n    StartNewFeature,\n    FixBug,\n    Refactor,\n    NewProject,\n    Clarification,\n}\n\n/// Suggested action\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"snake_case\")]\npub enum SuggestedAction {\n    Modify,\n    Resume,\n    New,\n    AskClarification,\n    Ignore,\n}\n\n/// Iteration intent result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IterationIntent {\n    pub intent_type: IterationType,\n    pub confidence: f64,\n    pub reasoning: String,\n    pub suggested_action: SuggestedAction,\n    pub related_features: Vec<String>,\n}\n\n/// Modify suggestion\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ModifySuggestion {\n    pub modification_type: String,\n    pub title: String,\n    pub affected_modules: Vec<String>,\n    pub implementation_plan: Vec<String>,\n    pub risk_assessment: RiskAssessment,\n    pub estimated_effort: String,\n    pub confidence: f64,\n}\n\n/// Risk assessment\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RiskAssessment {\n    pub risk_level: String,\n    pub risks: Vec<String>,\n    pub mitigation_strategies: Vec<String>,\n}\n\n/// Session status\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionStatus {\n    pub status: String,\n    pub session_type: String,\n    pub created_at: String,\n}\n\n/// Project context\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectContext {\n    pub project_name: String,\n    pub sessions: Vec<SessionInfo>,\n    pub technology_stack: Vec<String>,\n}\n\n/// Session info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionInfo {\n    pub session_id: String,\n    pub description: String,\n    pub status: String,\n    pub created_at: String,\n}\n\n/// Chat response type\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", content = \"data\")]\npub enum ChatResponse {\n    DirectProcessing,\n    AwaitConfirmation {\n        action_type: String,\n        data: ModifySuggestion,\n    },\n    AwaitClarification {\n        intent: IterationIntent,\n        questions: Vec<String>,\n    },\n    SuggestResume {\n        session_id: String,\n    },\n}\n\n// ============================================================================\n// Iterative Assistant\n// ============================================================================\n\npub struct IterativeAssistant {\n    llm: Arc<dyn LlmProvider>,\n}\n\npub trait LlmProvider: Send + Sync {\n    fn generate(&self, prompt: &str) -> Result<String>;\n}\n\nimpl IterativeAssistant {\n    pub fn new(llm: Arc<dyn LlmProvider>) -> Self {\n        Self { llm }\n    }\n    \n    /// Analyze user intent\n    pub async fn analyze_user_intent(\n        &self,\n        user_input: &str,\n        current_session_status: &SessionStatus,\n        project_context: &ProjectContext,\n    ) -> Result<IterationIntent> {\n        let project_context_json = serde_json::to_string_pretty(project_context)?;\n        \n        let prompt = format!(\n            r#\"你是一个项目迭代助手，负责分析用户的意图并决定下一步行动。\n\n当前状态:\n- Session 状态: {}\n- Session 类型: {}\n- 创建时间: {}\n\n项目上下文:\n{}\n\n用户输入: {}\n\n请分析用户的意图，从以下选项中选择最合适的一个:\n\n1. ContinueDevelopment - 继续开发当前项目（用户想要继续完善项目）\n2. StartNewFeature - 开发新功能（用户想要添加新功能）\n3. FixBug - 修复问题（用户报告了 bug）\n4. Refactor - 重构代码（用户想要重构）\n5. NewProject - 创建全新项目（用户想要开始新项目）\n6. Clarification - 需要更多信息（用户意图不明确）\n\n请以 JSON 格式返回你的分析结果:\n{{\n  \"intent_type\": \"ContinueDevelopment\",\n  \"confidence\": 0.9,\n  \"reasoning\": \"用户说'继续优化首页性能'，这表明用户想要继续改进当前项目\",\n  \"suggested_action\": \"modify\",\n  \"related_features\": [\"首页\", \"性能优化\"]\n}}\n\n注意：\n- intent_type 必须是上面列出的6种之一\n- confidence 是0到1之间的浮点数\n- suggested_action 可以是 \"modify\", \"resume\", \"new\", \"ask_clarification\", \"ignore\"\n- reasoning 简洁解释你的判断\n- related_features 列出相关的功能或模块\n\"#,\n            current_session_status.status,\n            current_session_status.session_type,\n            current_session_status.created_at,\n            project_context_json,\n            user_input\n        );\n        \n        let response = self.llm.generate(&prompt)?;\n        \n        // Parse LLM response\n        let intent: IterationIntent = serde_json::from_str(&response)\n            .map_err(|e| anyhow::anyhow!(\"Failed to parse intent response: {}. Response was: {}\", e, response))?;\n        \n        Ok(intent)\n    }\n    \n    /// Generate modify suggestion\n    pub async fn generate_modify_suggestion(\n        &self,\n        project_context: &ProjectContext,\n        user_input: &str,\n    ) -> Result<ModifySuggestion> {\n        let project_context_json = serde_json::to_string_pretty(project_context)?;\n        \n        let prompt = format!(\n            r#\"用户请求对项目进行修改。\n\n项目上下文:\n{}\n\n用户输入: {}\n\n请分析这个修改请求，并提供详细的修改建议，包括:\n\n1. 修改类型识别（feature_addition, feature_modification, bug_fix, refactor）\n2. 受影响模块分析\n3. 实施计划（分步骤）\n4. 风险评估\n\n请以 JSON 格式返回:\n{{\n  \"modification_type\": \"feature_addition\",\n  \"title\": \"添加用户评论功能\",\n  \"affected_modules\": [\"frontend\", \"backend\", \"database\"],\n  \"implementation_plan\": [\n    \"1. 设计评论数据模型\",\n    \"2. 实现后端 API\",\n    \"3. 实现前端 UI\",\n    \"4. 集成到现有系统\"\n  ],\n  \"risk_assessment\": {{\n    \"risk_level\": \"medium\",\n    \"risks\": [\n      \"可能需要数据库迁移\",\n      \"影响现有功能\"\n    ],\n    \"mitigation_strategies\": [\n      \"使用数据库迁移工具\",\n      \"充分测试现有功能\"\n    ]\n  }},\n  \"estimated_effort\": \"2-3天\",\n  \"confidence\": 0.85\n}}\n\n注意：\n- modification_type 可以是 \"feature_addition\", \"feature_modification\", \"bug_fix\", \"refactor\"\n- risk_level 可以是 \"low\", \"medium\", \"high\", \"critical\"\n- estimated_effort 使用描述性文本，如 \"2-3天\", \"1周\" 等\n- confidence 是0到1之间的浮点数\n\"#,\n            project_context_json,\n            user_input\n        );\n        \n        let response = self.llm.generate(&prompt)?;\n        \n        // Parse LLM response\n        let suggestion: ModifySuggestion = serde_json::from_str(&response)\n            .map_err(|e| anyhow::anyhow!(\"Failed to parse suggestion response: {}. Response was: {}\", e, response))?;\n        \n        Ok(suggestion)\n    }\n    \n    /// Generate clarification questions\n    pub async fn generate_clarification_questions(\n        &self,\n        user_input: &str,\n        project_context: &ProjectContext,\n    ) -> Result<Vec<String>> {\n        let project_context_json = serde_json::to_string_pretty(project_context)?;\n        \n        let prompt = format!(\n            r#\"用户的请求不够明确，需要更多信息。\n\n项目上下文:\n{}\n\n用户输入: {}\n\n请生成2-3个澄清问题，帮助更好地理解用户的需求。\n\n请以 JSON 格式返回:\n{{\n  \"questions\": [\n    \"你想修改哪个功能？\",\n    \"具体要实现什么效果？\",\n    \"有没有参考的例子？\"\n  ]\n}}\n\n注意：\n- 问题要简洁明了\n- 问题要能帮助缩小需求范围\n- 最多3个问题\n\"#,\n            project_context_json,\n            user_input\n        );\n        \n        let response = self.llm.generate(&prompt)?;\n        \n        // Parse LLM response\n        let result: serde_json::Value = serde_json::from_str(&response)?;\n        \n        let questions: Vec<String> = result[\"questions\"]\n            .as_array()\n            .unwrap_or(&vec![])\n            .iter()\n            .filter_map(|q| q.as_str().map(|s| s.to_string()))\n            .collect();\n        \n        Ok(questions)\n    }\n}\n\n// ============================================================================\n// Mock LLM Provider for testing\n// ============================================================================\n\n#[cfg(test)]\npub struct MockLlmProvider;\n\n#[cfg(test)]\nimpl LlmProvider for MockLlmProvider {\n    fn generate(&self, _prompt: &str) -> Result<String> {\n        Ok(r#\"{\n  \"intent_type\": \"ContinueDevelopment\",\n  \"confidence\": 0.9,\n  \"reasoning\": \"Mock response\",\n  \"suggested_action\": \"modify\",\n  \"related_features\": []\n}\"#.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::Arc;\n    \n    #[test]\n    fn test_iteration_intent_serialize() {\n        let intent = IterationIntent {\n            intent_type: IterationType::ContinueDevelopment,\n            confidence: 0.9,\n            reasoning: \"Test\".to_string(),\n            suggested_action: SuggestedAction::Modify,\n            related_features: vec![\"test\".to_string()],\n        };\n        \n        let json = serde_json::to_string(&intent).unwrap();\n        assert!(json.contains(\"continue_development\"));\n    }\n    \n    #[test]\n    fn test_modify_suggestion_serialize() {\n        let suggestion = ModifySuggestion {\n            modification_type: \"feature_addition\".to_string(),\n            title: \"Test\".to_string(),\n            affected_modules: vec![\"test\".to_string()],\n            implementation_plan: vec![\"1\".to_string()],\n            risk_assessment: RiskAssessment {\n                risk_level: \"low\".to_string(),\n                risks: vec![],\n                mitigation_strategies: vec![],\n            },\n            estimated_effort: \"1天\".to_string(),\n            confidence: 0.8,\n        };\n        \n        let json = serde_json::to_string(&suggestion).unwrap();\n        assert!(json.contains(\"feature_addition\"));\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 4.0,
      "lines_of_code": 366,
      "number_of_classes": 10,
      "number_of_functions": 7
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "anyhow",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 4,
        "name": "serde",
        "path": "serde",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 5,
        "name": "std",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 6,
        "name": "serde_json",
        "path": "serde_json",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": false,
        "line_number": null,
        "name": "Arc",
        "path": "std::sync::Arc",
        "version": null
      }
    ],
    "detailed_description": "The Iterative Assistant is an intelligent agent component responsible for analyzing user intent and automatically scheduling project modifications. It leverages Large Language Model (LLM) capabilities to understand natural language input and make intelligent decisions about project iteration strategies.\n\nThe component implements three core capabilities:\n\n1. **User Intent Analysis**: The `analyze_user_intent` method evaluates user input in the context of current session status and project context. It uses an LLM to classify the user's intent into one of six categories: ContinueDevelopment, StartNewFeature, FixBug, Refactor, NewProject, or Clarification. Each analysis includes a confidence score, reasoning, suggested action (Modify, Resume, New, AskClarification, or Ignore), and related feature identification.\n\n2. **Modification Suggestion Generation**: The `generate_modify_suggestion` method creates detailed modification proposals when the intent suggests changes. It provides comprehensive analysis including modification type (feature_addition, feature_modification, bug_fix, refactor), title, affected modules, step-by-step implementation plan, risk assessment with mitigation strategies, effort estimation, and confidence score.\n\n3. **Clarification Generation**: The `generate_clarification_questions` method generates 2-3 targeted questions when user intent is ambiguous, helping to refine requirements and guide users toward clearer specifications.\n\nThe architecture follows a trait-based design where the `LlmProvider` trait defines the interface for LLM integration, allowing flexibility in using different LLM backends. The component uses Rust's async/await pattern for non-blocking operations and Arc for thread-safe shared ownership of the LLM provider.\n\nData structures are fully serializable using serde, enabling persistence and network transmission of iteration-related information. The system maintains awareness of project context including project name, session history, and technology stack to provide contextually relevant suggestions.",
    "interfaces": [
      {
        "description": "Trait defining the interface for LLM providers, allowing different LLM backends to be used",
        "interface_type": "trait",
        "name": "LlmProvider",
        "parameters": [
          {
            "description": "The prompt text to send to the LLM",
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<String>",
        "visibility": "public"
      },
      {
        "description": "Main struct implementing the iterative assistant functionality with LLM integration",
        "interface_type": "struct",
        "name": "IterativeAssistant",
        "parameters": [
          {
            "description": "The LLM provider instance for text generation",
            "is_optional": false,
            "name": "llm",
            "param_type": "Arc<dyn LlmProvider>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Analyzes user intent to determine the appropriate iteration action",
        "interface_type": "method",
        "name": "analyze_user_intent",
        "parameters": [
          {
            "description": "User's natural language input",
            "is_optional": false,
            "name": "user_input",
            "param_type": "&str"
          },
          {
            "description": "Current session status information",
            "is_optional": false,
            "name": "current_session_status",
            "param_type": "&SessionStatus"
          },
          {
            "description": "Project context including sessions and technology stack",
            "is_optional": false,
            "name": "project_context",
            "param_type": "&ProjectContext"
          }
        ],
        "return_type": "Result<IterationIntent>",
        "visibility": "public"
      },
      {
        "description": "Generates detailed modification suggestions with risk assessment",
        "interface_type": "method",
        "name": "generate_modify_suggestion",
        "parameters": [
          {
            "description": "Project context for analysis",
            "is_optional": false,
            "name": "project_context",
            "param_type": "&ProjectContext"
          },
          {
            "description": "User's modification request",
            "is_optional": false,
            "name": "user_input",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<ModifySuggestion>",
        "visibility": "public"
      },
      {
        "description": "Generates clarification questions for ambiguous user requests",
        "interface_type": "method",
        "name": "generate_clarification_questions",
        "parameters": [
          {
            "description": "User's input requiring clarification",
            "is_optional": false,
            "name": "user_input",
            "param_type": "&str"
          },
          {
            "description": "Project context for relevant question generation",
            "is_optional": false,
            "name": "project_context",
            "param_type": "&ProjectContext"
          }
        ],
        "return_type": "Result<Vec<String>>",
        "visibility": "public"
      },
      {
        "description": "Enumeration of possible iteration intent types",
        "interface_type": "enum",
        "name": "IterationType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Enumeration of suggested actions based on intent analysis",
        "interface_type": "enum",
        "name": "SuggestedAction",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Enumeration of chat response types for different interaction scenarios",
        "interface_type": "enum",
        "name": "ChatResponse",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Analyze user intent and classify it into predefined iteration types using LLM-based natural language understanding",
      "Generate comprehensive modification suggestions including implementation plans, risk assessments, and effort estimates",
      "Produce clarification questions when user intent is ambiguous to refine requirements and improve decision-making",
      "Manage and utilize project context and session status information for contextually intelligent decision-making",
      "Provide abstraction layer for LLM integration through the LlmProvider trait for flexible backend implementation"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Agent builder module implementing multi-stage AI-driven software development workflow with actor-critic pattern",
      "file_path": "crates\\cowork-core\\src\\agents\\mod.rs",
      "functions": [
        "create_idea_agent",
        "create_idea_agent_with_interaction",
        "create_prd_loop",
        "create_design_loop",
        "create_plan_loop",
        "create_coding_loop",
        "create_check_agent",
        "create_delivery_agent"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Agents module - Agent builders using adk-rust\n// \n// IMPORTANT: This file uses StageExecutor instead of SequentialAgent to allow\n// LoopAgents to use ExitLoopTool without affecting other stages.\n//\n// SOLUTION: StageExecutor isolates each stage's escalate flag, so when a\n// sub-agent in LoopAgent calls exit_loop(), it only terminates that specific\n// LoopAgent, not the entire workflow.\n\nuse crate::instructions::*;\nuse crate::tools::*;\nuse crate::interaction::InteractiveBackend;\nuse adk_agent::{LlmAgentBuilder, LoopAgent};\nuse adk_core::{Llm, IncludeContents};\nuse adk_tool::ExitLoopTool;\nuse anyhow::Result;\nuse std::sync::Arc;\n\nmod hitl;\npub use hitl::ResilientAgent;\n\npub mod iterative_assistant;\npub use iterative_assistant::*;\n\n// ============================================================================\n// IdeaAgent - Simple agent to capture initial idea\n// ============================================================================\n\npub fn create_idea_agent(model: Arc<dyn Llm>, session_id: &str) -> Result<Arc<dyn adk_core::Agent>> {\n    create_idea_agent_with_interaction(model, session_id, None)\n}\n\npub fn create_idea_agent_with_interaction(\n    model: Arc<dyn Llm>, \n    session_id: &str,\n    interaction: Option<Arc<dyn InteractiveBackend>>\n) -> Result<Arc<dyn adk_core::Agent>> {\n    // Set global interaction backend if provided\n    if let Some(backend) = interaction {\n        set_interaction_backend(backend);\n    }\n\n    let agent = LlmAgentBuilder::new(\"idea_agent\")\n        .instruction(IDEA_AGENT_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(SaveIdeaTool::new(session_id.to_string())))\n        .tool(Arc::new(LoadIdeaTool::new(session_id.to_string())))\n        .tool(Arc::new(ReviewAndEditContentTool))\n        .tool(Arc::new(GetMemoryContextTool))\n        .tool(Arc::new(SaveSessionMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    Ok(Arc::new(agent))\n}\n\n// ============================================================================\n// PRD Loop - Actor + Critic with LoopAgent\n// ============================================================================\n\npub fn create_prd_loop(model: Arc<dyn Llm>, session_id: &str, interaction: Arc<dyn InteractiveBackend>) -> Result<Arc<dyn adk_core::Agent>> {\n    // Set global interaction backend\n    set_interaction_backend(interaction.clone());\n\n    let session = session_id.to_string();\n    \n    let prd_actor = LlmAgentBuilder::new(\"prd_actor\")\n        .instruction(PRD_ACTOR_INSTRUCTION)\n        .model(model.clone())\n        .tool(Arc::new(LoadIdeaTool::new(session.clone())))\n        .tool(Arc::new(ReviewWithFeedbackContentTool))\n        .tool(Arc::new(CreateRequirementTool::new(session.clone())))\n        .tool(Arc::new(AddFeatureTool::new(session.clone())))\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(SavePrdDocTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(LoadMemoryDetailTool))\n        .tool(Arc::new(SaveSessionMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    let prd_critic = LlmAgentBuilder::new(\"prd_critic\")\n        .instruction(PRD_CRITIC_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(ProvideFeedbackTool::new(session.clone()))) // Write feedback to file when checks fail\n        .tool(Arc::new(ExitLoopTool::new())) // Exit loop when checks pass\n        .tool(Arc::new(RequestHumanReviewTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::Default)\n        .build()?;\n\n    let mut loop_agent = LoopAgent::new(\"prd_loop\", vec![Arc::new(prd_actor), Arc::new(prd_critic)]);\n    loop_agent = loop_agent.with_max_iterations(3); // Loop will complete naturally after 3 iterations\n\n    Ok(Arc::new(ResilientAgent::new(Arc::new(loop_agent), interaction)))\n}\n\n// ============================================================================\n// Design Loop - Actor + Critic\n// ============================================================================\n\npub fn create_design_loop(model: Arc<dyn Llm>, session_id: &str, interaction: Arc<dyn InteractiveBackend>) -> Result<Arc<dyn adk_core::Agent>> {\n    // Set global interaction backend\n    set_interaction_backend(interaction.clone());\n\n    let session = session_id.to_string();\n    \n    let design_actor = LlmAgentBuilder::new(\"design_actor\")\n        .instruction(DESIGN_ACTOR_INSTRUCTION)\n        .model(model.clone())\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(ReviewWithFeedbackContentTool))\n        .tool(Arc::new(CreateDesignComponentTool::new(session.clone())))\n        .tool(Arc::new(SaveDesignDocTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(LoadMemoryDetailTool))\n        .tool(Arc::new(SaveSessionMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    let design_critic = LlmAgentBuilder::new(\"design_critic\")\n        .instruction(DESIGN_CRITIC_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(CheckFeatureCoverageTool::new(session.clone())))\n        .tool(Arc::new(ProvideFeedbackTool::new(session.clone())))\n        .tool(Arc::new(ExitLoopTool::new()))\n        .tool(Arc::new(RequestHumanReviewTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::Default)\n        .build()?;\n\n    let mut loop_agent = LoopAgent::new(\"design_loop\", vec![Arc::new(design_actor), Arc::new(design_critic)]);\n    loop_agent = loop_agent.with_max_iterations(3);\n\n    Ok(Arc::new(ResilientAgent::new(Arc::new(loop_agent), interaction)))\n}\n\n// ============================================================================\n// Plan Loop - Actor + Critic\n// ============================================================================\n\npub fn create_plan_loop(model: Arc<dyn Llm>, session_id: &str, interaction: Arc<dyn InteractiveBackend>) -> Result<Arc<dyn adk_core::Agent>> {\n    // Set global interaction backend\n    set_interaction_backend(interaction.clone());\n\n    let session = session_id.to_string();\n    \n    let plan_actor = LlmAgentBuilder::new(\"plan_actor\")\n        .instruction(PLAN_ACTOR_INSTRUCTION)\n        .model(model.clone())\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(ReviewWithFeedbackContentTool))\n        .tool(Arc::new(CreateTaskTool::new(session.clone())))\n        .tool(Arc::new(UpdateTaskTool::new(session.clone())))\n        .tool(Arc::new(DeleteTaskTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(LoadMemoryDetailTool))\n        .tool(Arc::new(SaveSessionMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    let plan_critic = LlmAgentBuilder::new(\"plan_critic\")\n        .instruction(PLAN_CRITIC_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(CheckTaskDependenciesTool::new(session.clone())))\n        .tool(Arc::new(ProvideFeedbackTool::new(session.clone())))\n        .tool(Arc::new(ExitLoopTool::new()))\n        .tool(Arc::new(RequestHumanReviewTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::Default)\n        .build()?;\n\n    let mut loop_agent = LoopAgent::new(\"plan_loop\", vec![Arc::new(plan_actor), Arc::new(plan_critic)]);\n    loop_agent = loop_agent.with_max_iterations(3);\n\n    Ok(Arc::new(ResilientAgent::new(Arc::new(loop_agent), interaction)))\n}\n\n// ============================================================================\n// Coding Loop - Actor + Critic\n// ============================================================================\n\npub fn create_coding_loop(model: Arc<dyn Llm>, session_id: &str, interaction: Arc<dyn InteractiveBackend>) -> Result<Arc<dyn adk_core::Agent>> {\n    // Set global interaction backend\n    set_interaction_backend(interaction.clone());\n\n    let session = session_id.to_string();\n    \n    let coding_actor = LlmAgentBuilder::new(\"coding_actor\")\n        .instruction(CODING_ACTOR_INSTRUCTION)\n        .model(model.clone())\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(ReviewWithFeedbackContentTool))\n        .tool(Arc::new(UpdateTaskStatusTool::new(session.clone())))\n        .tool(Arc::new(UpdateFeatureStatusTool::new(session.clone())))\n        .tool(Arc::new(CreateTaskTool::new(session.clone())))\n        .tool(Arc::new(UpdateTaskTool::new(session.clone())))\n        .tool(Arc::new(DeleteTaskTool::new(session.clone())))\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(WriteFileTool))\n        .tool(Arc::new(ListFilesTool))\n        .tool(Arc::new(RunCommandTool))\n        .tool(Arc::new(CheckTestsTool))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(LoadMemoryDetailTool))\n        .tool(Arc::new(SaveSessionMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    let coding_critic = LlmAgentBuilder::new(\"coding_critic\")\n        .instruction(CODING_CRITIC_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(ListFilesTool))\n        .tool(Arc::new(RunCommandTool))\n        .tool(Arc::new(ProvideFeedbackTool::new(session.clone())))\n        .tool(Arc::new(ExitLoopTool::new()))\n        .tool(Arc::new(RequestReplanningTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::Default)\n        .build()?;\n\n    let mut loop_agent = LoopAgent::new(\"coding_loop\", vec![Arc::new(coding_actor), Arc::new(coding_critic)]);\n    loop_agent = loop_agent.with_max_iterations(5);\n\n    Ok(Arc::new(ResilientAgent::new(Arc::new(loop_agent), interaction)))\n}\n\n// ============================================================================\n// Check Agent - Quality assurance\n// ============================================================================\n\npub fn create_check_agent(model: Arc<dyn Llm>, session_id: &str) -> Result<Arc<dyn adk_core::Agent>> {\n    let session = session_id.to_string();\n    \n    let agent = LlmAgentBuilder::new(\"check_agent\")\n        .instruction(CHECK_AGENT_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(CheckDataFormatTool::new(session.clone())))\n        .tool(Arc::new(CheckFeatureCoverageTool::new(session.clone())))\n        .tool(Arc::new(CheckTaskDependenciesTool::new(session.clone())))\n        .tool(Arc::new(RunCommandTool))\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(ListFilesTool))\n        .tool(Arc::new(CheckTestsTool))\n        .tool(Arc::new(CheckLintTool))\n        .tool(Arc::new(ProvideFeedbackTool::new(session.clone())))\n        .tool(Arc::new(GotoStageTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    Ok(Arc::new(agent))\n}\n\n// ============================================================================\n// Delivery Agent - Final report generation\n// ============================================================================\n\npub fn create_delivery_agent(model: Arc<dyn Llm>, session_id: &str) -> Result<Arc<dyn adk_core::Agent>> {\n    let session = session_id.to_string();\n    \n    let agent = LlmAgentBuilder::new(\"delivery_agent\")\n        .instruction(DELIVERY_AGENT_INSTRUCTION)\n        .model(model)\n        .tool(Arc::new(GetRequirementsTool::new(session.clone())))\n        .tool(Arc::new(GetDesignTool::new(session.clone())))\n        .tool(Arc::new(GetPlanTool::new(session.clone())))\n        .tool(Arc::new(LoadFeedbackHistoryTool::new(session.clone())))\n        .tool(Arc::new(ListFilesTool))\n        .tool(Arc::new(ReadFileTool))\n        .tool(Arc::new(SaveDeliveryReportTool::new(session.clone())))\n        .tool(Arc::new(SavePrdDocTool::new(session.clone())))\n        .tool(Arc::new(SaveDesignDocTool::new(session.clone())))\n        .tool(Arc::new(QueryMemoryIndexTool))\n        .tool(Arc::new(PromoteToProjectMemoryTool))\n        .include_contents(IncludeContents::None)\n        .build()?;\n\n    Ok(Arc::new(agent))\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 3.0,
      "lines_of_code": 301,
      "number_of_classes": 0,
      "number_of_functions": 8
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 9,
        "name": "crate::instructions",
        "path": "crates/cowork-core/src/instructions",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 10,
        "name": "crate::tools",
        "path": "crates/cowork-core/src/tools",
        "version": null
      },
      {
        "dependency_type": "trait",
        "is_external": false,
        "line_number": 11,
        "name": "crate::interaction::InteractiveBackend",
        "path": "crates/cowork-core/src/interaction",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 12,
        "name": "adk_agent::LlmAgentBuilder",
        "path": "adk-agent",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 12,
        "name": "adk_agent::LoopAgent",
        "path": "adk-agent",
        "version": null
      },
      {
        "dependency_type": "trait",
        "is_external": true,
        "line_number": 12,
        "name": "adk_core::Llm",
        "path": "adk-core",
        "version": null
      },
      {
        "dependency_type": "enum",
        "is_external": true,
        "line_number": 12,
        "name": "adk_core::IncludeContents",
        "path": "adk-core",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 13,
        "name": "adk_tool::ExitLoopTool",
        "path": "adk-tool",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": true,
        "line_number": 14,
        "name": "anyhow::Result",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": true,
        "line_number": 15,
        "name": "std::sync::Arc",
        "path": "std",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": false,
        "line_number": 19,
        "name": "crate::agents::hitl::ResilientAgent",
        "path": "crates/cowork-core/src/agents/hitl",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 21,
        "name": "crate::agents::iterative_assistant",
        "path": "crates/cowork-core/src/agents/iterative_assistant",
        "version": null
      }
    ],
    "detailed_description": "This module implements a comprehensive AI-powered software development workflow system using the adk-rust framework. It creates specialized agents for different stages of the development lifecycle: idea capture, PRD (Product Requirement Document) creation, system design, implementation planning, coding, quality checking, and final delivery.\n\nThe module employs an actor-critic loop pattern where each stage consists of an actor agent that performs the primary work (e.g., writing PRD, designing architecture, coding) and a critic agent that reviews and provides feedback. This pattern uses LoopAgent with ExitLoopTool to control iterations, allowing the critic to approve work or request improvements up to a maximum number of iterations.\n\nA key architectural decision is the use of StageExecutor pattern instead of SequentialAgent. This design allows LoopAgents to use ExitLoopTool without affecting other stages - the escalate flag is isolated per stage, so when ExitLoopTool is called within a LoopAgent, it terminates only that specific loop rather than the entire workflow.\n\nAll loop-based agents are wrapped with ResilientAgent to provide error recovery capabilities. This wrapper allows users to retry failed operations, provide guidance, or abort execution when errors occur. Human-in-the-loop interaction is integrated through the InteractiveBackend trait, enabling human review and intervention at critical points.\n\nThe workflow stages are:\n1. IdeaAgent - Captures initial project ideas and allows editing\n2. PRD Loop - Actor creates/refines requirements, Critic reviews quality and completeness\n3. Design Loop - Actor creates system design, Critic validates coverage and consistency\n4. Plan Loop - Actor creates implementation tasks, Critic validates dependencies\n5. Coding Loop - Actor writes code and tests, Critic reviews quality and can trigger replanning\n6. Check Agent - Performs comprehensive quality assurance across all artifacts\n7. Delivery Agent - Generates final delivery report with all project documentation",
    "interfaces": [
      {
        "description": "Creates an AI agent for capturing initial project ideas with default interaction backend",
        "interface_type": "function",
        "name": "create_idea_agent",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates an idea agent with optional custom interaction backend",
        "interface_type": "function",
        "name": "create_idea_agent_with_interaction",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "interaction",
            "param_type": "Option<Arc<dyn InteractiveBackend>>"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates a PRD development loop with actor-critic pattern, max 3 iterations",
        "interface_type": "function",
        "name": "create_prd_loop",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates a system design loop with actor-critic pattern, max 3 iterations",
        "interface_type": "function",
        "name": "create_design_loop",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates an implementation plan loop with actor-critic pattern, max 3 iterations",
        "interface_type": "function",
        "name": "create_plan_loop",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates a coding loop with actor-critic pattern, max 5 iterations, includes replanning capability",
        "interface_type": "function",
        "name": "create_coding_loop",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates a quality assurance agent that checks all project artifacts",
        "interface_type": "function",
        "name": "create_check_agent",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      },
      {
        "description": "Creates a delivery agent that generates final project report with all documentation",
        "interface_type": "function",
        "name": "create_delivery_agent",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Arc<dyn adk_core::Agent>>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Building and configuring specialized AI agents for each stage of the software development lifecycle (idea, PRD, design, plan, coding, check, delivery)",
      "Implementing actor-critic loop pattern with iteration control using LoopAgent and ExitLoopTool for quality-driven iterative refinement",
      "Managing tool assignment and configuration for each agent based on its specific role and capabilities in the development workflow",
      "Providing resilience through ResilientAgent wrapper that enables error recovery with user-controlled retry mechanisms",
      "Setting up human-in-the-loop interaction capabilities by integrating InteractiveBackend for human review and intervention at critical workflow stages"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": "Core data models for Cowork Forge project management system. Defines comprehensive domain models covering the entire software development lifecycle including requirements management, feature tracking, architectural design, implementation planning, code metadata, session management, and change request tracking. All models support JSON serialization/deserialization via serde and use chrono for timestamp management.",
      "file_path": "crates\\cowork-core\\src\\data\\models.rs",
      "functions": [
        "ProjectIndex::new",
        "ProjectIndex::add_session",
        "ProjectIndex::update_latest_successful",
        "ChangeRequest::new",
        "ChangeScope::default",
        "PatchMetadata::new",
        "Requirements::new",
        "FeatureList::new",
        "DesignSpec::new",
        "ImplementationPlan::new",
        "CodeMetadata::new",
        "FeedbackHistory::new"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Requirements",
        "Requirement",
        "Priority",
        "RequirementCategory",
        "FeatureList",
        "Feature",
        "FeatureStatus",
        "FeatureMetadata",
        "DesignSpec",
        "Architecture",
        "DesignComponent",
        "ComponentType",
        "ComponentInterface",
        "DataModel",
        "DataField",
        "TechnologyStack",
        "DeploymentInfo",
        "ImplementationPlan",
        "Milestone",
        "Task",
        "TaskStatus",
        "CodeMetadata",
        "FileMetadata",
        "BuildStatus",
        "TestStatus",
        "TestDetail",
        "SessionMeta",
        "Stage",
        "FeedbackHistory",
        "Feedback",
        "FeedbackType",
        "Severity",
        "ProjectIndex",
        "SessionRecord",
        "SessionType",
        "SessionStatus",
        "ChangeRequest",
        "ChangeScope",
        "ChangeAnalysis",
        "RiskLevel",
        "PatchMetadata",
        "ArtifactUpdate",
        "ArtifactType",
        "ChangeType"
      ],
      "name": "models.rs",
      "source_summary": "// Structured data models for Cowork Forge\r\nuse chrono::{DateTime, Utc};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n// ============================================================================\r\n// Requirements (requirements.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Requirements {\r\n    pub schema_version: String,\r\n    pub created_at: DateTime<Utc>,\r\n    pub updated_at: DateTime<Utc>,\r\n    pub requirements: Vec<Requirement>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Requirement {\r\n    pub id: String,  // REQ-001, REQ-002, etc.\r\n    pub title: String,\r\n    pub description: String,\r\n    pub priority: Priority,\r\n    pub category: RequirementCategory,\r\n    pub acceptance_criteria: Vec<String>,\r\n    pub related_features: Vec<String>,  // Feature IDs\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum Priority {\r\n    High,\r\n    Medium,\r\n    Low,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum RequirementCategory {\r\n    Functional,\r\n    NonFunctional,\r\n}\r\n\r\n// ============================================================================\r\n// Feature List (feature_list.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct FeatureList {\r\n    pub schema_version: String,\r\n    pub features: Vec<Feature>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Feature {\r\n    pub id: String,  // FEAT-001, FEAT-002, etc.\r\n    pub name: String,\r\n    pub description: String,\r\n    pub requirement_ids: Vec<String>,\r\n    pub status: FeatureStatus,\r\n    pub assigned_to_tasks: Vec<String>,  // Task IDs\r\n    pub completion_criteria: Vec<String>,\r\n    pub created_at: DateTime<Utc>,\r\n    pub completed_at: Option<DateTime<Utc>>,\r\n    #[serde(default)]\r\n    pub metadata: FeatureMetadata,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum FeatureStatus {\r\n    Pending,\r\n    InProgress,\r\n    Completed,\r\n    Blocked,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct FeatureMetadata {\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub estimated_effort: Option<String>,\r\n    #[serde(default)]\r\n    pub dependencies: Vec<String>,\r\n}\r\n\r\n// ============================================================================\r\n// Design Spec (design_spec.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DesignSpec {\r\n    pub schema_version: String,\r\n    pub architecture: Architecture,\r\n    pub technology_stack: TechnologyStack,\r\n    pub deployment: DeploymentInfo,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Architecture {\r\n    pub style: String,  // \"microservices\", \"monolith\", etc.\r\n    pub components: Vec<DesignComponent>,\r\n    pub data_models: Vec<DataModel>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DesignComponent {\r\n    pub id: String,  // COMP-001, COMP-002, etc.\r\n    pub name: String,\r\n    #[serde(rename = \"type\")]\r\n    pub component_type: ComponentType,\r\n    pub responsibilities: Vec<String>,\r\n    pub technology: String,\r\n    pub interfaces: Vec<ComponentInterface>,\r\n    pub related_features: Vec<String>,  // Feature IDs\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum ComponentType {\r\n    BackendService,\r\n    FrontendComponent,\r\n    Database,\r\n    ApiGateway,\r\n    MessageQueue,\r\n    Other(String),\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ComponentInterface {\r\n    pub name: String,\r\n    pub inputs: Vec<String>,\r\n    pub outputs: Vec<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DataModel {\r\n    pub name: String,\r\n    pub fields: Vec<DataField>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DataField {\r\n    pub name: String,\r\n    #[serde(rename = \"type\")]\r\n    pub field_type: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct TechnologyStack {\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub backend: Option<String>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub frontend: Option<String>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub database: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DeploymentInfo {\r\n    pub architecture: String,\r\n}\r\n\r\n// ============================================================================\r\n// Implementation Plan (implementation_plan.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ImplementationPlan {\r\n    pub schema_version: String,\r\n    pub milestones: Vec<Milestone>,\r\n    pub tasks: Vec<Task>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Milestone {\r\n    pub id: String,  // M1, M2, etc.\r\n    pub name: String,\r\n    pub features: Vec<String>,  // Feature IDs\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub deadline: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Task {\r\n    pub id: String,  // TASK-001, TASK-002, etc.\r\n    pub title: String,\r\n    pub description: String,\r\n    pub feature_id: String,\r\n    pub component_id: String,\r\n    pub status: TaskStatus,\r\n    pub dependencies: Vec<String>,  // Task IDs\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub estimated_effort: Option<String>,\r\n    pub files_to_create: Vec<String>,\r\n    pub acceptance_criteria: Vec<String>,\r\n    pub created_at: DateTime<Utc>,\r\n    pub started_at: Option<DateTime<Utc>>,\r\n    pub completed_at: Option<DateTime<Utc>>,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum TaskStatus {\r\n    Pending,\r\n    InProgress,\r\n    Completed,\r\n    Blocked,\r\n}\r\n\r\n// ============================================================================\r\n// Code Metadata (code_metadata.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct CodeMetadata {\r\n    pub schema_version: String,\r\n    pub files: Vec<FileMetadata>,\r\n    pub build_status: BuildStatus,\r\n    pub test_status: TestStatus,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct FileMetadata {\r\n    pub path: String,\r\n    pub task_id: String,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub feature_id: Option<String>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub component_id: Option<String>,\r\n    pub created_at: DateTime<Utc>,\r\n    pub last_modified: DateTime<Utc>,\r\n    pub lines_of_code: usize,\r\n    pub test_coverage: f32,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct BuildStatus {\r\n    pub last_build: DateTime<Utc>,\r\n    pub success: bool,\r\n    pub errors: Vec<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct TestStatus {\r\n    pub last_run: DateTime<Utc>,\r\n    pub total: usize,\r\n    pub passed: usize,\r\n    pub failed: usize,\r\n    pub details: Vec<TestDetail>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct TestDetail {\r\n    pub test_name: String,\r\n    pub status: String,  // \"passed\" or \"failed\"\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub message: Option<String>,\r\n}\r\n\r\n// ============================================================================\r\n// Session Meta (session/meta.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SessionMeta {\r\n    pub session_id: String,\r\n    pub created_at: DateTime<Utc>,\r\n    pub current_stage: Option<Stage>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub restart_reason: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum Stage {\r\n    Idea,\r\n    Prd,\r\n    Design,\r\n    Plan,\r\n    Coding,\r\n    Check,\r\n    Delivery,\r\n}\r\n\r\n// ============================================================================\r\n// Feedback (session/feedback.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct FeedbackHistory {\r\n    pub feedbacks: Vec<Feedback>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct Feedback {\r\n    pub feedback_type: FeedbackType,\r\n    pub severity: Severity,\r\n    pub details: String,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub suggested_fix: Option<String>,\r\n    pub timestamp: DateTime<Utc>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum FeedbackType {\r\n    BuildError,\r\n    QualityIssue,\r\n    MissingRequirement,\r\n    Suggestion,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum Severity {\r\n    Critical,\r\n    Major,\r\n    Minor,\r\n}\r\n\r\n// ============================================================================\r\n// Session-scoped Models (for session isolation)\r\n// ============================================================================\r\n\r\n/// Project index - tracks all sessions and current state\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ProjectIndex {\r\n    pub schema_version: String,\r\n    pub project_name: String,\r\n    pub created_at: DateTime<Utc>,\r\n    pub updated_at: DateTime<Utc>,\r\n    /// The latest successful session (for modify to use as base)\r\n    pub latest_successful_session: Option<String>,\r\n    /// All session records\r\n    pub sessions: Vec<SessionRecord>,\r\n}\r\n\r\n/// Record of a single session (new/modify/revert execution)\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SessionRecord {\r\n    pub session_id: String,\r\n    pub session_type: SessionType,\r\n    pub created_at: DateTime<Utc>,\r\n    pub completed_at: Option<DateTime<Utc>>,\r\n    pub status: SessionStatus,\r\n    /// For modify sessions: which session is the base\r\n    pub base_session_id: Option<String>,\r\n    /// Input description (idea for new, change request for modify)\r\n    pub input_description: String,\r\n    /// Change request (only for modify sessions)\r\n    pub change_request_id: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum SessionType {\r\n    New,      // Full project creation (new command)\r\n    Modify,   // Incremental change (modify command)\r\n    Revert,   // Revert and rerun (revert command)\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum SessionStatus {\r\n    InProgress,\r\n    Completed,\r\n    Failed,\r\n}\r\n\r\n/// Change request - describes an incremental modification\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ChangeRequest {\r\n    pub id: String,\r\n    pub session_id: String,\r\n    pub created_at: DateTime<Utc>,\r\n    /// User's idea/description of the change\r\n    pub idea: String,\r\n    /// Which session to use as baseline\r\n    pub base_session_id: String,\r\n    /// Automatically determined scope (which artifacts need update)\r\n    pub scope: ChangeScope,\r\n    /// Acceptance criteria extracted from idea\r\n    pub acceptance_criteria: Vec<String>,\r\n    /// Constraints (e.g., don't break existing features)\r\n    pub constraints: Vec<String>,\r\n    /// Analysis result from triage agent\r\n    pub analysis: Option<ChangeAnalysis>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ChangeScope {\r\n    pub requires_prd_update: bool,\r\n    pub requires_design_update: bool,\r\n    pub requires_plan_update: bool,\r\n    pub requires_code_change: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ChangeAnalysis {\r\n    /// Affected components\r\n    pub affected_components: Vec<String>,\r\n    /// Affected features\r\n    pub affected_features: Vec<String>,\r\n    /// Risk assessment\r\n    pub risk_level: RiskLevel,\r\n    /// Estimated effort\r\n    pub estimated_effort: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"lowercase\")]\r\npub enum RiskLevel {\r\n    Low,\r\n    Medium,\r\n    High,\r\n}\r\n\r\n/// Patch metadata - tracks what changed in a modify session\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PatchMetadata {\r\n    pub session_id: String,\r\n    pub base_session_id: String,\r\n    pub created_at: DateTime<Utc>,\r\n    /// Files added\r\n    pub added_files: Vec<String>,\r\n    /// Files modified\r\n    pub modified_files: Vec<String>,\r\n    /// Files deleted\r\n    pub deleted_files: Vec<String>,\r\n    /// Artifact updates\r\n    pub artifact_updates: Vec<ArtifactUpdate>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ArtifactUpdate {\r\n    pub artifact_type: ArtifactType,\r\n    pub change_type: ChangeType,\r\n    pub summary: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum ArtifactType {\r\n    Requirements,\r\n    Features,\r\n    Design,\r\n    Plan,\r\n    Code,\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\r\n#[serde(rename_all = \"snake_case\")]\r\npub enum ChangeType {\r\n    Added,\r\n    Modified,\r\n    Deleted,\r\n}\r\n\r\n// ============================================================================\r\n// Helper implementations\r\n// ============================================================================\r\n\r\nimpl ProjectIndex {\r\n    pub fn new(project_name: String) -> Self {\r\n        Self {\r\n            schema_version: \"2.0\".to_string(),\r\n            project_name,\r\n            created_at: Utc::now(),\r\n            updated_at: Utc::now(),\r\n            latest_successful_session: None,\r\n            sessions: Vec::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add_session(&mut self, record: SessionRecord) {\r\n        self.sessions.push(record);\r\n        self.updated_at = Utc::now();\r\n    }\r\n\r\n    pub fn update_latest_successful(&mut self, session_id: String) {\r\n        self.latest_successful_session = Some(session_id);\r\n        self.updated_at = Utc::now();\r\n    }\r\n}\r\n\r\nimpl ChangeRequest {\r\n    pub fn new(\r\n        session_id: String,\r\n        idea: String,\r\n        base_session_id: String,\r\n    ) -> Self {\r\n        Self {\r\n            id: format!(\"CR-{}\", Utc::now().timestamp()),\r\n            session_id,\r\n            created_at: Utc::now(),\r\n            idea,\r\n            base_session_id,\r\n            scope: ChangeScope::default(),\r\n            acceptance_criteria: Vec::new(),\r\n            constraints: Vec::new(),\r\n            analysis: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Default for ChangeScope {\r\n    fn default() -> Self {\r\n        Self {\r\n            requires_prd_update: false,\r\n            requires_design_update: false,\r\n            requires_plan_update: false,\r\n            requires_code_change: true, // Default to code-only change\r\n        }\r\n    }\r\n}\r\n\r\nimpl PatchMetadata {\r\n    pub fn new(session_id: String, base_session_id: String) -> Self {\r\n        Self {\r\n            session_id,\r\n            base_session_id,\r\n            created_at: Utc::now(),\r\n            added_files: Vec::new(),\r\n            modified_files: Vec::new(),\r\n            deleted_files: Vec::new(),\r\n            artifact_updates: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Requirements {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            schema_version: \"1.0\".to_string(),\r\n            created_at: Utc::now(),\r\n            updated_at: Utc::now(),\r\n            requirements: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl FeatureList {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            schema_version: \"1.0\".to_string(),\r\n            features: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl DesignSpec {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            schema_version: \"1.0\".to_string(),\r\n            architecture: Architecture {\r\n                style: String::new(),\r\n                components: Vec::new(),\r\n                data_models: Vec::new(),\r\n            },\r\n            technology_stack: TechnologyStack {\r\n                backend: None,\r\n                frontend: None,\r\n                database: None,\r\n            },\r\n            deployment: DeploymentInfo {\r\n                architecture: String::new(),\r\n            },\r\n        }\r\n    }\r\n}\r\n\r\nimpl ImplementationPlan {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            schema_version: \"1.0\".to_string(),\r\n            milestones: Vec::new(),\r\n            tasks: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl CodeMetadata {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            schema_version: \"1.0\".to_string(),\r\n            files: Vec::new(),\r\n            build_status: BuildStatus {\r\n                last_build: Utc::now(),\r\n                success: false,\r\n                errors: Vec::new(),\r\n            },\r\n            test_status: TestStatus {\r\n                last_run: Utc::now(),\r\n                total: 0,\r\n                passed: 0,\r\n                failed: 0,\r\n                details: Vec::new(),\r\n            },\r\n        }\r\n    }\r\n}\r\n\r\nimpl FeedbackHistory {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            feedbacks: Vec::new(),\r\n        }\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 608,
      "number_of_classes": 44,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 2,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 3,
        "name": "serde",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This file serves as the central schema definition for Cowork Forge, implementing a comprehensive project management data layer that spans the entire software development lifecycle. It defines 31 structs and 13 enums organized into logical domains: (1) Requirements Management - tracking functional/non-functional requirements with priority and acceptance criteria; (2) Feature Lifecycle - managing features from pending through completion with metadata and dependencies; (3) Design Specification - capturing architecture style, components, interfaces, and technology stack; (4) Implementation Planning - milestone and task management with effort estimation and dependency tracking; (5) Code Metadata - build status, test coverage, and file tracking; (6) Session Management - isolated development sessions with project index and session records; (7) Change Management - incremental modification tracking via ChangeRequest, ChangeScope, and PatchMetadata. The models support JSON persistence through serde derive macros and utilize chrono for UTC timestamp tracking. Helper implementations provide constructors and domain logic methods for ProjectIndex (session tracking), ChangeRequest (scope initialization), and default scope configurations. The architecture supports a session-based workflow where 'New', 'Modify', and 'Revert' operations are tracked with full provenance and artifact change tracking.",
    "interfaces": [
      {
        "description": "Root container for project requirements with schema versioning and temporal tracking",
        "interface_type": "struct",
        "name": "Requirements",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual requirement definition with ID, priority, category, and acceptance criteria",
        "interface_type": "struct",
        "name": "Requirement",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Priority levels for requirements (High, Medium, Low)",
        "interface_type": "enum",
        "name": "Priority",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Requirement classification (Functional, NonFunctional)",
        "interface_type": "enum",
        "name": "RequirementCategory",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Container for feature list with schema versioning",
        "interface_type": "struct",
        "name": "FeatureList",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Feature definition linking requirements to implementation tasks with status tracking",
        "interface_type": "struct",
        "name": "Feature",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Feature lifecycle states (Pending, InProgress, Completed, Blocked)",
        "interface_type": "enum",
        "name": "FeatureStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Optional metadata for features including effort estimation and dependencies",
        "interface_type": "struct",
        "name": "FeatureMetadata",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Top-level design specification container for architecture and technology decisions",
        "interface_type": "struct",
        "name": "DesignSpec",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Architecture definition including style, components, and data models",
        "interface_type": "struct",
        "name": "Architecture",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual component within architecture with responsibilities and interfaces",
        "interface_type": "struct",
        "name": "DesignComponent",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Component classification (BackendService, FrontendComponent, Database, ApiGateway, MessageQueue, Other)",
        "interface_type": "enum",
        "name": "ComponentType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Interface definition for component inputs and outputs",
        "interface_type": "struct",
        "name": "ComponentInterface",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Data model definition with field specifications",
        "interface_type": "struct",
        "name": "DataModel",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual field definition within a data model",
        "interface_type": "struct",
        "name": "DataField",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Technology stack configuration for backend, frontend, and database",
        "interface_type": "struct",
        "name": "TechnologyStack",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Deployment architecture information",
        "interface_type": "struct",
        "name": "DeploymentInfo",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Implementation planning container with milestones and tasks",
        "interface_type": "struct",
        "name": "ImplementationPlan",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Milestone definition grouping features with optional deadline",
        "interface_type": "struct",
        "name": "Milestone",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Task definition with status, dependencies, effort estimation, and file creation tracking",
        "interface_type": "struct",
        "name": "Task",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Task execution states (Pending, InProgress, Completed, Blocked)",
        "interface_type": "enum",
        "name": "TaskStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Code metadata container tracking files, build status, and test status",
        "interface_type": "struct",
        "name": "CodeMetadata",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "File-level metadata with path, task association, timestamps, and test coverage",
        "interface_type": "struct",
        "name": "FileMetadata",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Build status tracking with timestamp, success flag, and error collection",
        "interface_type": "struct",
        "name": "BuildStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Test execution summary with pass/fail counts and detailed results",
        "interface_type": "struct",
        "name": "TestStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual test case result with status and optional message",
        "interface_type": "struct",
        "name": "TestDetail",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Session metadata with lifecycle stage tracking",
        "interface_type": "struct",
        "name": "SessionMeta",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Development workflow stages (Idea, Prd, Design, Plan, Coding, Check, Delivery)",
        "interface_type": "enum",
        "name": "Stage",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Collection of feedback entries for iterative improvement",
        "interface_type": "struct",
        "name": "FeedbackHistory",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual feedback entry with type, severity, details, and suggested fix",
        "interface_type": "struct",
        "name": "Feedback",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Feedback classification (BuildError, QualityIssue, MissingRequirement, Suggestion)",
        "interface_type": "enum",
        "name": "FeedbackType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Issue severity levels (Critical, Major, Minor) with ordering support",
        "interface_type": "enum",
        "name": "Severity",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Project index tracking all sessions and latest successful state for incremental development",
        "interface_type": "struct",
        "name": "ProjectIndex",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Session execution record with type, status, and provenance tracking",
        "interface_type": "struct",
        "name": "SessionRecord",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Session operation types (New, Modify, Revert)",
        "interface_type": "enum",
        "name": "SessionType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Session execution states (InProgress, Completed, Failed)",
        "interface_type": "enum",
        "name": "SessionStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Change request describing incremental modifications with scope and analysis",
        "interface_type": "struct",
        "name": "ChangeRequest",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Boolean flags indicating which artifacts require updates for a change",
        "interface_type": "struct",
        "name": "ChangeScope",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Change analysis results including affected components, features, risk level, and effort",
        "interface_type": "struct",
        "name": "ChangeAnalysis",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Risk assessment levels (Low, Medium, High)",
        "interface_type": "enum",
        "name": "RiskLevel",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Patch tracking for file changes and artifact updates in modify sessions",
        "interface_type": "struct",
        "name": "PatchMetadata",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Individual artifact update record with type and change classification",
        "interface_type": "struct",
        "name": "ArtifactUpdate",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Artifact categories (Requirements, Features, Design, Plan, Code)",
        "interface_type": "enum",
        "name": "ArtifactType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Change operation types (Added, Modified, Deleted)",
        "interface_type": "enum",
        "name": "ChangeType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Constructor for ProjectIndex with schema versioning and initialization",
        "interface_type": "impl",
        "name": "ProjectIndex::new",
        "parameters": [
          {
            "description": "Project name for identification",
            "is_optional": false,
            "name": "project_name",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Add session record and update timestamp",
        "interface_type": "impl",
        "name": "ProjectIndex::add_session",
        "parameters": [
          {
            "description": "Session record to add",
            "is_optional": false,
            "name": "record",
            "param_type": "SessionRecord"
          }
        ],
        "return_type": "()",
        "visibility": "public"
      },
      {
        "description": "Update reference to latest successful session",
        "interface_type": "impl",
        "name": "ProjectIndex::update_latest_successful",
        "parameters": [
          {
            "description": "Session ID that completed successfully",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "()",
        "visibility": "public"
      },
      {
        "description": "Constructor for ChangeRequest with ID generation and default scope",
        "interface_type": "impl",
        "name": "ChangeRequest::new",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": "User description of desired change",
            "is_optional": false,
            "name": "idea",
            "param_type": "String"
          },
          {
            "description": "Base session ID for the modification",
            "is_optional": false,
            "name": "base_session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Default change scope assuming code-only modification",
        "interface_type": "impl",
        "name": "ChangeScope::default",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for PatchMetadata with timestamp initialization",
        "interface_type": "impl",
        "name": "PatchMetadata::new",
        "parameters": [
          {
            "description": "Current session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": "Base session identifier",
            "is_optional": false,
            "name": "base_session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for Requirements with schema versioning",
        "interface_type": "impl",
        "name": "Requirements::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for FeatureList with schema versioning",
        "interface_type": "impl",
        "name": "FeatureList::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for DesignSpec with nested structure initialization",
        "interface_type": "impl",
        "name": "DesignSpec::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for ImplementationPlan with schema versioning",
        "interface_type": "impl",
        "name": "ImplementationPlan::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for CodeMetadata with nested status initialization",
        "interface_type": "impl",
        "name": "CodeMetadata::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for empty FeedbackHistory",
        "interface_type": "impl",
        "name": "FeedbackHistory::new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define domain models for software development lifecycle artifacts including requirements, features, design specifications, implementation plans, and code metadata with full JSON serialization support",
      "Enable session-based development workflow with project indexing, session tracking, and change request management for incremental modifications and revert operations",
      "Support comprehensive status tracking across features, tasks, builds, and tests with temporal metadata and lifecycle state management",
      "Provide change scope analysis and risk assessment structures for impact evaluation of modifications on requirements, design, plan, and code artifacts",
      "Establish versioning strategy through schema_version fields across all major data structures to support future migrations and backward compatibility"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Domain module aggregation component serving as the organizational hub for core business entities in a Rust-based cowork system",
      "file_path": "crates\\cowork-core\\src\\domain\\mod.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Domain module - Core business entities\r\npub mod iteration;\r\npub mod memory;\r\npub mod project;\r\n\r\npub use iteration::*;\r\npub use memory::*;\r\npub use project::*;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 8,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 3,
        "name": "iteration",
        "path": "./iteration",
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 4,
        "name": "memory",
        "path": "./memory",
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 5,
        "name": "project",
        "path": "./project",
        "version": null
      }
    ],
    "detailed_description": "This mod.rs file acts as the root module for the domain layer in the cowork-core crate. It follows the Domain-Driven Design (DDD) architectural pattern by organizing and grouping core business entities into a cohesive domain namespace. The module serves as a façade that exposes three fundamental domain concepts: iterations (representing work cycles), memories (representing stored knowledge or context), and projects (representing work containers). By using pub use statements, it provides a unified public interface that simplifies external access to domain entities while maintaining internal modularity. The file represents a clean separation of concerns, isolating business logic and domain models from application services and data access layers, which is essential for maintaining a scalable and maintainable codebase.",
    "interfaces": [],
    "responsibilities": [
      "Organize and aggregate core domain submodules (iteration, memory, project) into a unified namespace",
      "Provide a public re-export interface for all domain entities, enabling clean external access patterns",
      "Act as the architectural boundary for the domain layer, encapsulating business logic and entity definitions",
      "Establish modular structure that follows Domain-Driven Design principles for business entity organization",
      "Serve as the single entry point for domain-level imports, simplifying dependency management across the codebase"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Event bus implementation for real-time communication between engine and UI components using tokio broadcast channel pattern",
      "file_path": "crates\\cowork-core\\src\\event_bus.rs",
      "functions": [
        "EventBus::new",
        "EventBus::subscribe",
        "EventBus::publish",
        "EventBus::sender",
        "EngineEvent::stage_started",
        "EngineEvent::stage_completed",
        "EngineEvent::agent_thinking",
        "EngineEvent::agent_output",
        "EngineEvent::tool_started",
        "EngineEvent::tool_completed",
        "EngineEvent::file_created",
        "EngineEvent::file_deleted",
        "EngineEvent::error"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "EventBus",
        "EngineEvent",
        "ErrorSeverity"
      ],
      "name": "event_bus.rs",
      "source_summary": "// Event Bus for real-time communication between engine and UI\n// Uses tokio broadcast channel for multi-subscriber support\n\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::broadcast;\n\n/// Engine events that can be published to subscribers\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum EngineEvent {\n    // Stage events\n    StageStarted {\n        stage: String,\n        session_id: String,\n        timestamp: i64,\n    },\n    StageCompleted {\n        stage: String,\n        session_id: String,\n        duration_ms: u64,\n    },\n\n    // Agent events\n    AgentThinking {\n        agent: String,\n        content: String,\n        session_id: String,\n    },\n    AgentOutput {\n        agent: String,\n        content: String,\n        session_id: String,\n    },\n\n    // Tool events\n    ToolStarted {\n        tool: String,\n        session_id: String,\n    },\n    ToolCompleted {\n        tool: String,\n        result: String,\n        session_id: String,\n    },\n\n    // File events\n    FileCreated {\n        path: String,\n        size: u64,\n        session_id: String,\n    },\n    FileModified {\n        path: String,\n        session_id: String,\n    },\n    FileDeleted {\n        path: String,\n        session_id: String,\n    },\n\n    // Error events\n    Error {\n        error: String,\n        context: String,\n        session_id: String,\n        severity: ErrorSeverity,\n    },\n\n    // HITL events\n    HITLRequest {\n        tool: String,\n        content: String,\n        options: Vec<String>,\n        session_id: String,\n    },\n    HITLResponse {\n        tool: String,\n        response: String,\n        session_id: String,\n    },\n\n    // Progress events\n    Progress {\n        task_id: String,\n        current: u32,\n        total: u32,\n        message: String,\n    },\n}\n\n/// Error severity level\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ErrorSeverity {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n/// Event bus for publishing and subscribing to engine events\npub struct EventBus {\n    sender: broadcast::Sender<EngineEvent>,\n}\n\nimpl EventBus {\n    /// Create a new event bus\n    pub fn new() -> Self {\n        let (sender, _) = broadcast::channel(1000);\n        Self { sender }\n    }\n\n    /// Subscribe to events\n    pub fn subscribe(&self) -> broadcast::Receiver<EngineEvent> {\n        self.sender.subscribe()\n    }\n\n    /// Publish an event\n    pub async fn publish(&self, event: EngineEvent) {\n        self.sender.send(event).ok();\n    }\n\n    /// Get sender for direct use (needed for Arc wrapping)\n    pub fn sender(&self) -> broadcast::Sender<EngineEvent> {\n        self.sender.clone()\n    }\n}\n\nimpl Default for EventBus {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// Helper functions for creating specific events\nimpl EngineEvent {\n    pub fn stage_started(stage: &str, session_id: &str) -> Self {\n        Self::StageStarted {\n            stage: stage.to_string(),\n            session_id: session_id.to_string(),\n            timestamp: chrono::Utc::now().timestamp(),\n        }\n    }\n\n    pub fn stage_completed(stage: &str, session_id: &str, duration_ms: u64) -> Self {\n        Self::StageCompleted {\n            stage: stage.to_string(),\n            session_id: session_id.to_string(),\n            duration_ms,\n        }\n    }\n\n    pub fn agent_thinking(agent: &str, content: &str, session_id: &str) -> Self {\n        Self::AgentThinking {\n            agent: agent.to_string(),\n            content: content.to_string(),\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn agent_output(agent: &str, content: &str, session_id: &str) -> Self {\n        Self::AgentOutput {\n            agent: agent.to_string(),\n            content: content.to_string(),\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn tool_started(tool: &str, session_id: &str) -> Self {\n        Self::ToolStarted {\n            tool: tool.to_string(),\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn tool_completed(tool: &str, result: &str, session_id: &str) -> Self {\n        Self::ToolCompleted {\n            tool: tool.to_string(),\n            result: result.to_string(),\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn file_created(path: &str, session_id: &str) -> Self {\n        Self::FileCreated {\n            path: path.to_string(),\n            size: 0,\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn file_deleted(path: &str, session_id: &str) -> Self {\n        Self::FileDeleted {\n            path: path.to_string(),\n            session_id: session_id.to_string(),\n        }\n    }\n\n    pub fn error(error: &str, context: &str, session_id: &str, severity: ErrorSeverity) -> Self {\n        Self::Error {\n            error: error.to_string(),\n            context: context.to_string(),\n            session_id: session_id.to_string(),\n            severity,\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 8.0,
      "lines_of_code": 205,
      "number_of_classes": 3,
      "number_of_functions": 13
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": true,
        "line_number": 4,
        "name": "tokio::sync::broadcast",
        "path": "tokio::sync",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": true,
        "line_number": null,
        "name": "chrono::Utc",
        "path": "chrono",
        "version": null
      }
    ],
    "detailed_description": "The event_bus.rs component implements a publish-subscribe event bus system that facilitates real-time communication between the engine core and UI components in a cooperative development environment. The component leverages tokio's broadcast channel to support multiple concurrent subscribers while maintaining thread-safe operations.\n\nThe core functionality revolves around two primary structures: the EngineEvent enum, which defines 14 distinct event types covering stage lifecycle, agent activities, tool operations, file system changes, error reporting, HITL (Human-in-the-Loop) interactions, and progress tracking; and the EventBus struct, which manages event publication and subscription through a broadcast channel.\n\nThe component follows an event-driven architecture pattern where producers publish events and consumers subscribe to receive them asynchronously. Each event variant carries context-specific data including session identifiers, timestamps, and severity levels, enabling comprehensive system state monitoring. The EventBus implementation provides methods for creating new bus instances, subscribing to event streams, publishing events, and accessing the underlying sender for Arc wrapping scenarios.\n\nHelper methods are implemented as part of the EngineEvent impl block to provide convenient constructors for frequently used event types, with automatic timestamp generation using chrono for stage events. However, not all event variants have corresponding helper methods, indicating potential for incomplete event construction API coverage.",
    "interfaces": [
      {
        "description": "Core event bus structure managing broadcast channel for publish-subscribe pattern",
        "interface_type": "struct",
        "name": "EventBus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Creates a new EventBus instance with broadcast channel capacity of 1000",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [],
        "return_type": "EventBus",
        "visibility": "public"
      },
      {
        "description": "Creates a new receiver to subscribe to all published events",
        "interface_type": "method",
        "name": "subscribe",
        "parameters": [],
        "return_type": "broadcast::Receiver<EngineEvent>",
        "visibility": "public"
      },
      {
        "description": "Publishes an event to all active subscribers asynchronously",
        "interface_type": "method",
        "name": "publish",
        "parameters": [
          {
            "description": "The event to publish to subscribers",
            "is_optional": false,
            "name": "event",
            "param_type": "EngineEvent"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Returns a clone of the broadcast sender for Arc wrapping scenarios",
        "interface_type": "method",
        "name": "sender",
        "parameters": [],
        "return_type": "broadcast::Sender<EngineEvent>",
        "visibility": "public"
      },
      {
        "description": "Enumeration of all possible engine events with variant-specific data payloads",
        "interface_type": "enum",
        "name": "EngineEvent",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Severity levels for error events (Low, Medium, High, Critical)",
        "interface_type": "enum",
        "name": "ErrorSeverity",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Helper to create StageStarted event with automatic timestamp",
        "interface_type": "method",
        "name": "stage_started",
        "parameters": [
          {
            "description": "Stage name",
            "is_optional": false,
            "name": "stage",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create StageCompleted event with duration",
        "interface_type": "method",
        "name": "stage_completed",
        "parameters": [
          {
            "description": "Stage name",
            "is_optional": false,
            "name": "stage",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Stage execution duration in milliseconds",
            "is_optional": false,
            "name": "duration_ms",
            "param_type": "u64"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create AgentThinking event",
        "interface_type": "method",
        "name": "agent_thinking",
        "parameters": [
          {
            "description": "Agent name",
            "is_optional": false,
            "name": "agent",
            "param_type": "&str"
          },
          {
            "description": "Thinking content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create AgentOutput event",
        "interface_type": "method",
        "name": "agent_output",
        "parameters": [
          {
            "description": "Agent name",
            "is_optional": false,
            "name": "agent",
            "param_type": "&str"
          },
          {
            "description": "Output content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create ToolStarted event",
        "interface_type": "method",
        "name": "tool_started",
        "parameters": [
          {
            "description": "Tool name",
            "is_optional": false,
            "name": "tool",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create ToolCompleted event",
        "interface_type": "method",
        "name": "tool_completed",
        "parameters": [
          {
            "description": "Tool name",
            "is_optional": false,
            "name": "tool",
            "param_type": "&str"
          },
          {
            "description": "Tool execution result",
            "is_optional": false,
            "name": "result",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create FileCreated event (size defaults to 0)",
        "interface_type": "method",
        "name": "file_created",
        "parameters": [
          {
            "description": "File path",
            "is_optional": false,
            "name": "path",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create FileDeleted event",
        "interface_type": "method",
        "name": "file_deleted",
        "parameters": [
          {
            "description": "File path",
            "is_optional": false,
            "name": "path",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      },
      {
        "description": "Helper to create Error event with severity",
        "interface_type": "method",
        "name": "error",
        "parameters": [
          {
            "description": "Error message",
            "is_optional": false,
            "name": "error",
            "param_type": "&str"
          },
          {
            "description": "Error context",
            "is_optional": false,
            "name": "context",
            "param_type": "&str"
          },
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Error severity level",
            "is_optional": false,
            "name": "severity",
            "param_type": "ErrorSeverity"
          }
        ],
        "return_type": "EngineEvent",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define and manage the type system for all engine-level events with structured data payloads including stage lifecycle events (StageStarted, StageCompleted), agent behavioral events (AgentThinking, AgentOutput), tool execution events (ToolStarted, ToolCompleted), file system events (FileCreated, FileModified, FileDeleted), error reporting with severity levels, HITL interaction events, and progress tracking events",
      "Implement publish-subscribe pattern for real-time event distribution using tokio broadcast channel, allowing multiple concurrent subscribers to receive event notifications while maintaining thread-safety and async compatibility",
      "Provide event publication API that allows components to broadcast EngineEvent instances to all active subscribers, with graceful error handling (using .ok() to ignore receiver absence)",
      "Manage event subscription lifecycle by creating broadcast::Receiver instances for consumers, enabling decoupled communication between engine and UI components without direct dependencies",
      "Offer convenient event construction helpers for common event types with automatic data enrichment (timestamps, string conversions), reducing boilerplate code for event publishers"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Defines instruction prompts for the Check Agent in a collaborative AI system, specifying minimal quality validation workflow and approval criteria",
      "file_path": "crates\\cowork-core\\src\\instructions\\check.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "check.rs",
      "source_summary": "// Check Agent instruction (SIMPLIFIED VERSION)\r\n\r\npub const CHECK_AGENT_INSTRUCTION: &str = r#\"\r\n# Your Role\r\nYou are Check Agent. Run **MINIMAL** quality checks.\r\n\r\n# Core Principle: MINIMAL VALIDATION\r\n- **Don't over-test**: No need for 100% coverage\r\n- **Skip test checks**: Unless project explicitly has tests\r\n- **Basic validation only**: Files exist, data format valid\r\n- **Be lenient**: If it works, approve it\r\n\r\n# Workflow\r\n1. Run **minimal** checks:\r\n   - `check_feature_coverage()` - All features have components?\r\n   - `check_task_dependencies()` - No circular deps?\r\n   - Optional: `list_files(path)` - Check files exist\r\n2. Choose ONE path:\r\n   - **Path A**: Looks reasonable → Done (project approved)\r\n   - **Path B**: Critical issues → `goto_stage(...)` to restart\r\n\r\n# Tools\r\n- get_requirements()\r\n- get_design()\r\n- get_plan()\r\n- check_feature_coverage()\r\n- check_task_dependencies()\r\n- list_files(path)\r\n- read_file(path)\r\n- provide_feedback(...)\r\n- goto_stage(stage_name) # \"prd\", \"design\", \"plan\", \"coding\"\r\n\r\n# What NOT to Check\r\n- ❌ Don't run tests (unless they exist)\r\n- ❌ Don't check linting\r\n- ❌ Don't check code quality in detail\r\n- ❌ Don't check performance\r\n- ✅ Just verify basic structure is complete\r\n\r\n# Example - Approve (Most cases)\r\n```\r\n1. check_feature_coverage()\r\n2. check_task_dependencies()\r\n3. list_files(\".\")\r\n4. \"✅ All checks passed. Project structure is complete.\"\r\n```\r\n\r\n**REMEMBER: Be lenient! If structure is complete, approve it!**\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 49,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This file defines the CHECK_AGENT_INSTRUCTION constant, which is a comprehensive instruction prompt for an AI Check Agent in a cowork/collaborative development system. The instruction establishes the agent's role as a minimal quality validator that performs basic structural checks on software projects without over-testing. It defines a 4-step workflow: (1) run minimal checks (feature coverage, task dependencies), (2) optionally verify files exist, (3) evaluate results against two paths (approve or restart stage), and (4) provide feedback. The instruction emphasizes leniency - approving projects if the basic structure is complete rather than enforcing strict quality gates. It provides a whitelist of available tools including get_requirements(), get_design(), get_plan(), check_feature_coverage(), check_task_dependencies(), list_files(), read_file(), provide_feedback(), and goto_stage(). The instruction also explicitly lists what NOT to check (tests, linting, detailed code quality, performance) to avoid over-validation. This is part of a multi-agent system where different agents handle different stages (PRD, Design, Plan, Coding) of the software development lifecycle.",
    "interfaces": [],
    "responsibilities": [
      "Define minimal quality check workflow and approval criteria for project validation",
      "Specify available tools and commands that the Check Agent can invoke during validation",
      "Establish core principles of lenient validation - approving projects with complete structure without requiring 100% test coverage",
      "Provide two-path decision logic: approve reasonable projects or restart problematic stages",
      "Document explicit exclusions to prevent over-testing (tests, linting, performance, detailed quality checks)"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Defines the instruction set and behavioral guidelines for the Code Patch Agent, an AI agent responsible for implementing incremental code changes based on ChangeRequests.",
      "file_path": "crates\\cowork-core\\src\\instructions\\code_patch.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "code_patch.rs",
      "source_summary": "// Code Patch Agent Instruction\n//\n// Role: Generate incremental code changes based on ChangeRequest\n\npub const CODE_PATCH_INSTRUCTION: &str = r#\"\n# Role: Code Patch Agent\n\nYou are a **Code Patch Agent** responsible for implementing incremental changes to an existing codebase based on a ChangeRequest.\n\n## Your Task\n\nGiven:\n1. **ChangeRequest**: What needs to change (from Triage Agent)\n2. **Base Session Code**: The current project files\n3. **Plan/Design**: Current architecture and tasks\n\nYou need to:\n1. **Understand the change** - Read the ChangeRequest and understand what to implement\n2. **Read existing code** - Use `read_file` to understand current implementation\n3. **Generate changes** - Modify or create files incrementally\n4. **Update metadata** - Track what files were added/modified/deleted\n5. **Test the changes** - Run build/tests if applicable\n\n## Available Tools\n\nYou have access to:\n- `get_plan` - Load implementation plan\n- `get_design` - Load design spec\n- `list_files` - See current project structure\n- `read_file` - Read existing files\n- `write_file` - Create or modify files\n- `delete_file` - Delete a file\n- `delete_directory` - Delete a directory and all its contents\n- `run_command` - Run build/test commands (avoid long-running servers!)\n- `update_task_status` - Mark tasks as completed\n- `update_feature_status` - Mark features as completed\n\n## Implementation Strategy\n\n### For Code-Only Changes (most common):\n1. Read the ChangeRequest to understand what to implement\n2. List files to understand project structure\n3. Read relevant files to understand current code\n4. Make incremental changes:\n   - **Prefer modifying existing files** over creating new ones\n   - Keep changes minimal and focused\n   - Follow existing code style and patterns\n   - **Delete deprecated files** using `delete_file` when removing features\n5. Test changes if possible (run build, but DON'T start servers)\n\n### For Changes Requiring New Components:\n1. Create new files following project structure\n2. Update existing files to integrate the new component\n3. Follow the design spec for architecture\n\n### For Removing Features:\n1. Use `list_files` to identify files related to the feature\n2. Read files to confirm they're safe to delete\n3. Use `delete_file` to remove individual files\n4. Use `delete_directory` to remove entire directories (e.g., old components)\n5. Update imports/references in other files\n6. Test to ensure no broken references remain\n\n## Guidelines\n\n- **Incremental changes**: Modify existing code when possible, don't rewrite everything\n- **Read before write**: Always read files before modifying them\n- **Follow patterns**: Match the existing code style and architecture\n- **Minimal scope**: Only change what's needed for the ChangeRequest\n- **No servers**: Don't start long-running services (npm dev, python -m http.server, etc.)\n- **Track changes**: The system will automatically track which files you modify\n\n## Example Workflow\n\n1. Load ChangeRequest to understand what to implement\n2. Use `list_files` to see project structure\n3. Read relevant existing files\n4. Make incremental changes with `write_file`\n5. Run build/tests if applicable\n6. Update task/feature status if tasks were defined\n\n## Important Notes\n\n- You are working in the **project root directory**, NOT inside `.cowork/`\n- Code files should be written directly (e.g., `index.html`, `src/App.js`)\n- The system will track your changes in `.cowork/sessions/<id>/patch/metadata.json`\n- If you modify an existing file, read it first to understand the current implementation\n\nRemember: Make **incremental changes**, not a complete rewrite. Add features, fix bugs, or enhance existing code.\n\"#;\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 8.0,
      "lines_of_code": 90,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "The code_patch.rs component is a configuration/instruction definition file that provides comprehensive behavioral guidelines for an AI agent called the \"Code Patch Agent\". This agent is responsible for implementing incremental changes to an existing codebase based on ChangeRequests received from a Triage Agent.\n\nThe component defines a constant string `CODE_PATCH_INSTRUCTION` that serves as a system prompt for the AI agent. The instruction is structured with clear sections including:\n\n1. **Role Definition**: Establishes the agent as a Code Patch Agent responsible for incremental changes\n2. **Task Specification**: Outlines the inputs (ChangeRequest, Base Session Code, Plan/Design) and expected actions (understand change, read existing code, generate changes, update metadata, test)\n3. **Available Tools**: Lists 10 specific tools the agent can use (get_plan, get_design, list_files, read_file, write_file, delete_file, delete_directory, run_command, update_task_status, update_feature_status)\n4. **Implementation Strategies**: Provides three distinct strategies for different scenarios:\n   - Code-only changes (most common)\n   - New component creation\n   - Feature removal\n5. **Guidelines**: Establishes 6 core principles (incremental changes, read before write, follow patterns, minimal scope, no servers, track changes)\n6. **Example Workflow**: Demonstrates a typical 6-step process\n7. **Important Notes**: Contains 4 critical operational details about working directory, file paths, change tracking, and file modification practices\n\nThe instruction uses markdown formatting for clear organization and readability, and is designed to be consumed by an AI agent at runtime to guide its behavior and decision-making processes during code patching operations.",
    "interfaces": [],
    "responsibilities": [
      "Defines and maintains the behavioral instruction set for the Code Patch Agent AI",
      "Specifies available tools and their usage patterns for incremental code modifications",
      "Establishes implementation strategies for different types of code changes (additions, modifications, deletions)",
      "Enforces best practices and guidelines for safe, minimal, and focused code changes",
      "Provides operational context including working directory, file paths, and change tracking mechanisms"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "Defines instruction constants for Coding Actor and Coding Critic agents in a multi-agent coding system, establishing coding standards and workflow guidelines",
      "file_path": "crates\\cowork-core\\src\\instructions\\coding.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "coding.rs",
      "source_summary": "// Coding Agent instructions - Actor and Critic (SIMPLIFIED VERSION)\r\n\r\npub const CODING_ACTOR_INSTRUCTION: &str = r#\"\r\n# Your Role\r\nYou are Coding Actor. Implement ALL pending tasks by writing **SIMPLE, CLEAN** code.\r\n\r\n# Core Principle: SIMPLICITY & CORE FUNCTIONALITY ONLY\r\n- **Simple code**: No complex patterns, no over-engineering\r\n- **Minimal dependencies**: Use built-in features when possible\r\n- **No tests**: Don't write test files (unless explicitly required in tasks)\r\n- **No optimization**: Don't optimize performance (unless explicitly required)\r\n- **No infrastructure code**: Don't write deployment/monitoring/logging code (unless explicitly required)\r\n- **Clear structure**: Easy to understand, easy to modify\r\n- **Focus on core features**: Implement only what's needed to make features work\r\n\r\n# Workflow - COMPLETE ALL TASKS\r\n1. Call `get_plan()` to see ALL pending tasks\r\n2. **Implement ALL pending tasks in one go**:\r\n   - Write simple, straightforward code for each task\r\n   - Avoid complex abstractions\r\n   - Use comments only when necessary\r\n3. Mark ALL tasks as completed with `update_task_status(task_id, \"completed\")`\r\n4. **IMPORTANT**: After completing all tasks, your work is done. DO NOT continue.\r\n\r\n# Exit Condition\r\n- When ALL tasks are marked as \"completed\", stop immediately\r\n- No need to wait for critic review\r\n\r\n# Adaptive Task Management - NEW CAPABILITY\r\n\r\nDuring implementation, you may discover that the plan needs adjustments. You now have tools to handle this:\r\n\r\n## When to CREATE new tasks (create_task):\r\n- You discover a missing dependency or prerequisite\r\n- A task is too large and should be split into smaller pieces\r\n- You find a new technical requirement not in the original plan\r\n- Example: \"Need to create API client before implementing feature X\"\r\n\r\n## When to UPDATE tasks (update_task):\r\n- Task dependencies have changed during implementation\r\n- Files to create have changed based on actual code structure\r\n- Task description needs clarification based on what you learned\r\n- Example: \"Task X now depends on Task Y which wasn't originally planned\"\r\n\r\n## When to DELETE tasks (delete_task):\r\n- A task is no longer needed (duplicate or obsolete)\r\n- The approach has changed making this task irrelevant\r\n- A task was incorrectly planned and cannot be implemented\r\n- Example: \"This database migration task is not needed because we're using in-memory storage\"\r\n\r\n## Guidelines for Task Management:\r\n- **Be conservative**: Only modify tasks when truly necessary\r\n- **Always provide reason**: Every create/update/delete must include a clear reason\r\n- **Stay focused**: Don't over-plan; focus on what's needed for current implementation\r\n- **Maintain consistency**: Keep task IDs, dependencies, and status aligned\r\n\r\n## Handle Critic Feedback (IF IN ITERATION 2+):\r\n**IMPORTANT**: In iterations after the first one, check the conversation history for Critic's feedback:\r\n\r\n1. **Look at the previous messages** - Critic's feedback is in the conversation history\r\n2. **If Critic said code is incomplete or has issues**:\r\n   - Read exactly what issues were mentioned\r\n   - Complete any missing tasks\r\n   - Fix any code quality issues\r\n   - Simplify over-engineered code if needed\r\n3. **If Critic requested replanning**: Acknowledge (human will review)\r\n4. **If no issues mentioned** - Critic approved and you're done!\r\n\r\n**Remember**: You can SEE Critic's messages in the conversation. Read them and take action.\r\n\r\n# Tools\r\n- get_plan()\r\n- read_file(path)\r\n- write_file(path, content)\r\n- list_files(path)\r\n- update_task_status(task_id, status)\r\n- update_feature_status(feature_id, status)\r\n- create_task(title, description, feature_id, component_id, files_to_create, dependencies, acceptance_criteria)\r\n- update_task(task_id, reason, title?, description?, dependencies?, files_to_create?, acceptance_criteria?)\r\n- delete_task(task_id, reason)\r\n\r\n# Code Style - SIMPLE APPROACH\r\n```\r\n✅ GOOD (Simple):\r\nfunction generatePaper(grade, difficulty) {\r\n  const questions = questionBank.filter(q => \r\n    q.grade === grade && q.difficulty === difficulty\r\n  );\r\n  return questions.slice(0, 10);\r\n}\r\n\r\n❌ BAD (Over-engineered):\r\nclass PaperGenerationStrategy {\r\n  constructor(questionRepository, filterChain, paginationService) {...}\r\n  async generateWithValidation() {...}\r\n}\r\n```\r\n\r\n**REMEMBER: \r\n1. Implement ALL tasks at once\r\n2. Adjust plan only when necessary (create/update/delete tasks)\r\n3. Mark all as completed\r\n4. Stop when done - don't loop!**\r\n\"#;\r\n\r\npub const CODING_CRITIC_INSTRUCTION: &str = r#\"\r\n# Your Role  \r\nYou are Coding Critic. Check if code is **TOO COMPLEX** and **ALL TASKS ARE DONE**.\r\n\r\n# Core Principle: SIMPLICITY CHECK + COMPLETION CHECK\r\nYour job is to ensure code is SIMPLE, READABLE, and ALL TASKS ARE COMPLETED!\r\n\r\n# Review Criteria\r\n1. **All tasks completed?** (Check get_plan() - all tasks should be \"completed\")\r\n2. **Files exist?** (Use list_files() to verify code files were actually created)\r\n3. **Over-engineered?** (Complex class hierarchies, design patterns → Too complex!)\r\n4. **Too many files?** (Splitting into too many modules → Provide feedback)\r\n5. **Readable?** (Easy to understand without deep knowledge)\r\n6. **Plan alignment?** (Does implementation match the planned tasks and design?)\r\n\r\n# Decision Process\r\n1. Call `get_plan()` to check task status\r\n2. **If all tasks are completed**: \r\n   - Call `list_files(\".\")` to verify files were created\r\n   - Quickly review 1-2 key files with `read_file()`\r\n   - **If files exist and look good**: Approve and STOP\r\n   - **If files are missing**: Provide feedback asking Actor to create them\r\n3. **If tasks are incomplete**:\r\n   - Provide feedback: \"Please complete remaining tasks\"\r\n   - Actor will finish them in next iteration\r\n\r\n# Detecting Major Issues - REPLANNING\r\n\r\nDuring review, you may discover fundamental problems that cannot be fixed by simple feedback.\r\nUse `request_replanning()` when you find:\r\n\r\n## Critical Issues Requiring Replanning:\r\n- **Design Flaw**: Implementation reveals the architecture doesn't work\r\n  - Example: \"Circular dependencies between modules make the design unimplementable\"\r\n  \r\n- **Missing Dependency**: Critical external dependency not identified in planning\r\n  - Example: \"This feature requires a payment gateway integration not in the plan\"\r\n  \r\n- **Architecture Conflict**: Code conflicts with fundamental system constraints\r\n  - Example: \"This serverless approach won't work with the stateful requirements\"\r\n  \r\n- **Requirement Mismatch**: Implementation shows requirements were misunderstood\r\n  - Example: \"The real-time sync requirement needs WebSockets, not REST polling\"\r\n\r\n## When NOT to Request Replanning:\r\n- Minor code quality issues → Use `provide_feedback()`\r\n- Missing files → Use `provide_feedback()`\r\n- Incomplete tasks → Use `provide_feedback()`\r\n- Style/complexity issues → Use `provide_feedback()`\r\n\r\n## How to Request Replanning:\r\nUse `request_replanning()` with:\r\n- `issue_type`: \"design_flaw\" | \"missing_dependency\" | \"architecture_conflict\" | \"requirement_mismatch\"\r\n- `severity`: \"critical\" | \"major\" | \"moderate\"\r\n- `details`: Clear explanation of the problem\r\n- `affected_features`: Which features are impacted\r\n- `suggested_approach`: Your recommendation (optional)\r\n\r\nThe request will be recorded and reviewed by the Check Agent, which can trigger `goto_stage()` if needed.\r\n\r\n# Exit Condition\r\n- When ALL tasks show status=\"completed\" AND key files exist, approve immediately and stop\r\n\r\n## Decision Flow:\r\n1. If major architectural issues found → call `request_replanning()`\r\n2. If minor issues or incomplete work → call `provide_feedback(feedback_type=\"incomplete\", severity=\"medium\", details=\"<what's pending>\", suggested_fix=\"<complete these tasks>\")`\r\n3. If everything is complete and good → call `exit_loop()`\r\n\r\n# Tools\r\n- get_plan()\r\n- read_file(path)\r\n- list_files(path)  ← Use this to verify files exist!\r\n- run_command(command)  ← Only for simple checks, not for tests/lint\r\n- provide_feedback(feedback_type, severity, details, suggested_fix) - Report incomplete work (Actor will read this)\r\n- exit_loop() - **MUST CALL** when all tasks completed and code is good (exits this loop only, other stages continue)\r\n- request_replanning(issue_type, severity, details, affected_features, suggested_approach) - Call for major issues\r\n\r\n# Example - All Tasks Done\r\n```\r\n1. get_plan()\r\n2. # Returns: 12 tasks, all status=\"completed\"\r\n3. list_files(\".\")\r\n4. # Returns: [\"index.html\", \"style.css\", \"script.js\"] - files exist!\r\n5. read_file(\"index.html\")\r\n6. # Looks good, simple HTML structure\r\n7. exit_loop() - Exit the coding loop, workflow continues to check stage\r\n```\r\n\r\n# Example - Issues Found\r\n```\r\n1. get_plan()\r\n2. # Returns: 8 completed, 4 pending\r\n3. provide_feedback(\r\n     feedback_type=\"incomplete\",\r\n     severity=\"medium\",\r\n     details=\"4 tasks still pending: TASK-009 (Create login form), TASK-010 (Add validation), TASK-011 (Style buttons), TASK-012 (Add error messages)\",\r\n     suggested_fix=\"Complete the 4 pending tasks before marking work as done\"\r\n   )\r\n# Actor will read this feedback file and complete the tasks\r\n```\r\n\r\n# Example - Tasks Complete but Files Missing\r\n```\r\n1. get_plan()\r\n2. # Returns: 12 tasks, all status=\"completed\"\r\n3. list_files(\".\")\r\n4. # Returns: [] - no files created!\r\n5. provide_feedback(type=\"incomplete\", severity=\"medium\",\r\n   details=\"Tasks marked complete but no code files found. Please create the actual files.\",\r\n   suggested_fix=\"Write index.html, style.css, and script.js files\")\r\n```\r\n\r\n# Example - Tasks Incomplete\r\n```\r\n1. get_plan()\r\n2. # Returns: 12 tasks, 8 completed, 4 pending\r\n3. provide_feedback(type=\"incomplete\", severity=\"low\",\r\n   details=\"4 tasks still pending. Please complete them.\",\r\n   suggested_fix=\"Implement remaining tasks\")\r\n```\r\n\r\n# Example - Major Issue Requiring Replanning\r\n```\r\n1. get_plan()\r\n2. # Returns: All tasks completed\r\n3. list_files(\".\")\r\n4. read_file(\"server.js\")\r\n5. # Discovers: Code uses stateful sessions but plan assumed stateless serverless\r\n6. request_replanning(\r\n   issue_type=\"architecture_conflict\",\r\n   severity=\"critical\",\r\n   details=\"Implementation uses stateful sessions with in-memory storage, but the planned serverless deployment (AWS Lambda) is stateless. This fundamental mismatch will cause session loss on every request.\",\r\n   affected_features=[\"USER-001\", \"AUTH-002\"],\r\n   suggested_approach=\"Either: 1) Switch to Redis/DynamoDB for session storage, or 2) Redesign for stateless JWT-based auth\")\r\n```\r\n\r\n**REMEMBER: \r\n1. Check if ALL tasks are completed first\r\n2. Verify files actually exist with list_files()\r\n3. If yes, approve and STOP immediately\r\n4. If no, ask actor to finish\r\n5. For major architectural issues, use request_replanning()\r\n6. Don't try to run tests/lint - not applicable for simple HTML projects**\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 18.0,
      "lines_of_code": 249,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "<p>This component defines two large string constants (<code>CODING_ACTOR_INSTRUCTION</code> and <code>CODING_CRITIC_INSTRUCTION</code>) that serve as system prompts for AI agents in a multi-agent coding workflow system. These instructions configure the behavior of specialized agents:</p>\n\n<p><strong>Coding Actor Agent Instructions:</strong> Configure an implementation-focused agent to write simple, clean code following the SIMPLICITY principle. Defines workflow including getting plans, implementing all pending tasks in one iteration, managing task lifecycle (create/update/delete tasks), and handling critic feedback. Emphasizes minimal dependencies, no over-engineering, no tests (unless required), no premature optimization, and clear code structure. Includes tool access for file operations and task management.</p>\n\n<p><strong>Coding Critic Agent Instructions:</strong> Configure a review-focused agent to verify code simplicity and task completion. Defines review criteria including task completion verification, file existence checks, complexity detection (over-engineering indicators), and plan alignment. Introduces a decision process for handling completion status and includes a re-planning protocol for fundamental architectural issues. Provides clear examples for different scenarios (all tasks done, issues found, missing files, tasks incomplete, major issues requiring replanning).</p>\n\n<p>Both instruction sets emphasize an iterative workflow with specific exit conditions, tool usage patterns, and collaborative guidelines between agent types. The design follows a \"simplicity first\" philosophy that prioritizes working code over sophisticated architecture.",
    "interfaces": [
      {
        "description": "Public constant string containing system instructions for the Coding Actor agent",
        "interface_type": "constant",
        "name": "CODING_ACTOR_INSTRUCTION",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      },
      {
        "description": "Public constant string containing system instructions for the Coding Critic agent",
        "interface_type": "constant",
        "name": "CODING_CRITIC_INSTRUCTION",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "Defines system instructions and behavioral guidelines for the Coding Actor agent",
      "Defines system instructions and behavioral guidelines for the Coding Critic agent",
      "Establishes coding standards and best practices emphasizing simplicity",
      "Configures agent workflow patterns including task management and iteration protocols",
      "Sets up tool usage policies and decision criteria for agent operations"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Instruction prompt definition for the Delivery Agent in a cooperative project management system",
      "file_path": "crates\\cowork-core\\src\\instructions\\delivery.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "delivery.rs",
      "source_summary": "// Delivery Agent instruction\r\n\r\npub const DELIVERY_AGENT_INSTRUCTION: &str = r#\"\r\n# ⚠️ CRITICAL RULE - READ FIRST ⚠️\r\n**This is the FINAL agent. But ONLY generate report if project is TRULY complete!**\r\n\r\n# Your Role\r\nYou are Delivery Agent. Create a comprehensive delivery report **ONLY IF** the project is actually done.\r\n\r\n# CRITICAL Pre-Check (DO THIS FIRST!)\r\n**Before generating the report, you MUST verify the project is complete:**\r\n\r\n1. Call `get_plan()` to check task status\r\n2. **CRITICAL**: Use `list_files(\".\")` to verify actual code files exist\r\n3. **If NO code files exist** (e.g., no index.html, no .js files):\r\n   - DO NOT generate delivery report\r\n   - Instead, output: \"❌ Project incomplete: No code files found. Tasks marked complete but implementation missing.\"\r\n   - STOP immediately\r\n\r\n# Workflow (Only if pre-check passes)\r\n1. Load project data:\r\n   - `get_requirements()`\r\n   - `get_design()`\r\n   - `get_plan()`\r\n   - `load_feedback_history()`\r\n2. Generate a markdown report summarizing everything\r\n3. Save it:\r\n   - `save_delivery_report(content)`\r\n4. **DONE** - This is the last stage, pipeline completes automatically\r\n\r\n# Tools\r\n- get_requirements()\r\n- get_design()\r\n- get_plan()\r\n- load_feedback_history()\r\n- read_file(path)\r\n- list_files(path)  ← **USE THIS to verify files exist!**\r\n- save_delivery_report(content)\r\n- save_prd_doc(content)\r\n- save_design_doc(content)\r\n\r\n# Report Structure (Markdown)\r\n```markdown\r\n# Delivery Report\r\n\r\n## Project Summary\r\n[Brief overview]\r\n\r\n## Requirements (X total)\r\n- REQ-001: [Title] ✅\r\n- REQ-002: [Title] ✅\r\n\r\n## Features (X total)\r\n- FEAT-001: [Name] - [Description] ✅\r\n- FEAT-002: [Name] - [Description] ✅\r\n\r\n## Architecture\r\n- Component 1: [Tech stack]\r\n- Component 2: [Tech stack]\r\n\r\n## Tasks Completed\r\nTotal: X tasks\r\nStatus: All completed\r\n\r\n## Project Files Generated\r\n- index.html\r\n- style.css\r\n- script.js\r\n[List all generated files]\r\n\r\n## Quality Checks\r\n- Build: ✅ Passing\r\n- Tests: ✅ Passed (or N/A for pure frontend)\r\n- Lint: ✅ Clean (or N/A for pure frontend)\r\n\r\n## Getting Started\r\n\\`\\`\\`bash\r\n# How to run the project\r\n\\`\\`\\`\r\n\r\n## Next Steps\r\n[What user should do next]\r\n```\r\n\r\n# Example - Complete Project\r\n```\r\n1. get_plan()\r\n2. # Returns: 49 tasks, all completed\r\n3. list_files(\".\")\r\n4. # Returns: [\"index.html\", \"style.css\", \"script.js\", \"data.json\"] ✅\r\n5. # Files exist! Proceed with report\r\n6. get_requirements()\r\n7. get_design()\r\n8. # Generate report markdown\r\n9. save_delivery_report(report_content)\r\n# Done!\r\n```\r\n\r\n# Example - Incomplete Project (STOP!)\r\n```\r\n1. get_plan()\r\n2. # Returns: 49 tasks, all marked \"completed\"\r\n3. list_files(\".\")\r\n4. # Returns: [] or only [\".cowork\", \".config.toml\"] ← NO code files!\r\n5. # STOP! Do NOT generate report!\r\n6. Output: \"❌ Project incomplete: Tasks marked complete but no code files found (index.html, etc.). Cannot generate delivery report.\"\r\n# STOP here, do not call save_delivery_report()\r\n```\r\n\r\n**REMEMBER: \r\n1. ALWAYS check for actual files BEFORE generating report\r\n2. If files don't exist, DO NOT generate delivery_report.md\r\n3. Task status alone is NOT enough - verify actual implementation!**\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 6.0,
      "lines_of_code": 114,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This component defines a comprehensive instruction prompt for a \"Delivery Agent\" in an AI-powered project management system. The prompt instructs the agent to generate a comprehensive delivery report ONLY if the project is truly complete. It includes: 1) Critical pre-checks requiring verification that actual code files exist by calling list_files(\".\"), 2) A multi-step workflow for loading project data (requirements, design, plan, feedback history), 3) A detailed markdown report structure template with sections for project summary, requirements, features, architecture, completed tasks, generated files, quality checks, getting started guide, and next steps, 4) Available tool definitions including get_plan(), list_files(), save_delivery_report(), etc., 5) Examples of both complete project scenarios and incomplete project handling where the agent should abort if no code files are detected. The instruction emphasizes that task status alone is insufficient - actual implementation files must be verified before generating delivery reports.",
    "interfaces": [
      {
        "description": "Public constant containing the delivery agent instruction prompt string",
        "interface_type": "constant",
        "name": "DELIVERY_AGENT_INSTRUCTION",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define the role, workflow, and behavioral rules for the Delivery Agent in the project pipeline",
      "Specify critical validation logic requiring verification of actual code files existence before generating delivery reports",
      "Document the standard structure and format requirements for delivery reports in markdown",
      "Define the available toolset and commands the Delivery Agent can execute during its operation",
      "Provide decision-making guidelines with examples for handling both complete and incomplete project scenarios"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "Defines instruction constants for AI-powered Design Actor and Design Critic agents in a multi-agent coworking system. Contains detailed prompts that guide agents through a human-in-the-loop architecture design process, enforcing simplicity principles (2-4 components max, monolithic preference, minimal tech stack) and mandatory verification steps. The instructions define a complete workflow: requirements loading → draft creation → human review → formal design → document saving → critic verification.",
      "file_path": "crates\\cowork-core\\src\\instructions\\design.rs",
      "functions": [],
      "importance_score": 0.85,
      "interfaces": [],
      "name": "design.rs",
      "source_summary": "// Design Agent instructions - Actor and Critic (WITH HITL)\r\n\r\npub const DESIGN_ACTOR_INSTRUCTION: &str = r#\"\r\n# Your Role\r\nYou are Design Actor. You MUST create system architecture components WITH user feedback and save design document.\r\n\r\n# CRITICAL PRINCIPLE: SIMPLICITY & MINIMAL ARCHITECTURE\r\n**The architecture MUST be simple and use minimal components:**\r\n- ✅ Use simplest tech stack that works (prefer built-in/standard tools)\r\n- ✅ Minimize number of components (2-4 is ideal, 6 is maximum)\r\n- ✅ Use monolithic architecture when appropriate (don't over-split)\r\n- ❌ NO microservices unless explicitly required\r\n- ❌ NO complex caching layers (Redis/Memcached) unless critical\r\n- ❌ NO message queues unless explicitly required\r\n- ❌ NO service mesh, API gateway unless explicitly required\r\n- ❌ NO separate monitoring/logging infrastructure\r\n\r\n**Technology Stack - Keep It Simple:**\r\n- ✅ GOOD: \"Node.js + Express + SQLite\" or \"Python + Flask + JSON files\"\r\n- ❌ BAD: \"Node.js + Express + Redis + RabbitMQ + Elasticsearch + Prometheus\"\r\n- ✅ GOOD: \"Single-page app with vanilla JS\"\r\n- ❌ BAD: \"React + Redux + Redux-Saga + Webpack + Babel + TypeScript\"\r\n\r\n**Examples:**\r\n- ✅ GOOD: 3 components: Frontend (HTML/JS), Backend (Flask), Data (SQLite)\r\n- ❌ BAD: 8 components: Web UI, Mobile UI, API Gateway, Auth Service, User Service, Database, Cache, Queue\r\n\r\n# CRITICAL: You MUST complete ALL steps below. Do NOT skip any step!\r\n\r\n## Step 1: Load Requirements (MANDATORY)\r\n1. Call `get_requirements()` to read all requirements and features\r\n2. **STOP** if requirements or features are empty - report error and exit\r\n3. Analyze requirements to plan 2-4 **SIMPLE** components (avoid over-splitting)\r\n\r\n## Step 2: Create Architecture Draft (MANDATORY)\r\n2. Write a draft architecture outline in markdown:\r\n   ```markdown\r\n   # Architecture Draft (SIMPLE & MINIMAL)\r\n   \r\n   ## Components (2-4 items - keep it simple!)\r\n   1. COMP-001: [Name] ([Type]) - [Responsibilities]\r\n      - Technology: [SIMPLE stack - avoid complexity]\r\n      - Implements: FEAT-001, FEAT-002\r\n      - Note: Use built-in features, avoid external dependencies when possible\r\n   ...\r\n\r\n   ## Technology Stack (MINIMAL)\r\n   - Frontend: [Use simplest approach - vanilla JS, simple HTML, or one framework]\r\n   - Backend: [Use one language + one framework]\r\n   - Database: [SQLite, JSON files, or simple DB - avoid complex setups]\r\n   - NO caching layer (unless critical)\r\n   - NO message queue (unless critical)\r\n   - NO microservices (keep monolithic)\r\n   ```\r\n   **You MUST create this draft before proceeding!**\r\n\r\n## Step 3: User Review (MANDATORY - HITL)\r\n3. **MUST** call `review_with_feedback_content(title=\"Review Architecture Draft\", content=<draft>, prompt=\"请审查架构草案：edit 编辑 / pass 继续 / 或直接输入修改建议\")`\r\n4. **Handle response carefully - CRITICAL RULES**:\r\n   - **If action=\"edit\"**: The tool returns edited content in the \"content\" field. **YOU MUST USE THIS EDITED CONTENT** as your finalized draft for Step 4.\r\n   - **If action=\"pass\"**: Use your original draft as the finalized draft.\r\n   - **If action=\"feedback\"**: \r\n     a. **MANDATORY**: You MUST revise your draft to address ALL user feedback\r\n     b. **Show your revision**: Explicitly state what you changed (e.g., \"Simplified to 3 components per user feedback\")\r\n     c. **MANDATORY**: You MUST call `review_with_feedback_content` again with the REVISED draft (max 1 retry)\r\n     d. If user passes the second review, use that as finalized draft\r\n     e. **FAILURE TO REVISE = CRITIC WILL REJECT YOUR WORK**\r\n   \r\n   **CRITICAL**: \r\n   - Whatever content you get from the FINAL review call becomes your \"finalized draft\"\r\n   - Do NOT use your original draft if user provided feedback\r\n   - Do NOT ignore user feedback - every feedback point must be reflected in the revision\r\n\r\n## Step 4: Create Formal Design (MANDATORY)\r\n5. **CRITICAL**: Before creating components, verify you're using the FINALIZED draft:\r\n   - If user provided feedback in Step 3, you MUST use your REVISED draft\r\n   - If user edited content, you MUST use the edited content\r\n   - If user passed without changes, you can use your original draft\r\n6. **Parse the finalized draft** from Step 3 (the content field from review_with_feedback_content result)\r\n7. For EACH component in the **finalized draft**, **MUST** call `create_design_component(name, component_type, responsibilities, technology, related_features)`\r\n   **Do NOT skip this step! All components must be created!**\r\n   **Do NOT use your original draft if user provided feedback - use the REVISED one!**\r\n\r\n## Step 5: Save Design Document (MANDATORY)\r\n8. Generate a complete Design Document markdown including:\r\n   - Architecture overview (emphasize simplicity)\r\n   - All components with full details (keep tech stack simple)\r\n   - Technology stack explanation (justify simplicity choices)\r\n   - Component relationships (mermaid diagram optional)\r\n   - Data flow (keep simple)\r\n9. **CRITICAL**: The design document MUST match the components you created in Step 4\r\n   - If user changed something via feedback, it must be reflected here\r\n   - The design doc is the final documentation - it must reflect user decisions\r\n10. **MUST** call `save_design_doc(content=<design_markdown>)`\r\n   **This is CRITICAL - if you don't save, the design will be lost!**\r\n\r\n## Step 6: Verify (MANDATORY)\r\n11. Call `get_design()` to verify all components were created\r\n12. Confirm all components exist, then report success\r\n13. **SELF-CHECK**: Do the created components match the finalized draft from Step 3?\r\n   - If user provided feedback, your final design should reflect it\r\n   - If you see mismatches, you FAILED to follow user feedback\r\n\r\n## Step 7: Handle Critic Feedback (IF IN ITERATION 2+)\r\n**IMPORTANT**: In iterations after the first one, check the conversation history for Critic's feedback:\r\n\r\n1. **Look at the previous messages** - Critic's feedback is in the conversation history\r\n2. **If Critic pointed out issues** (e.g., \"architecture too complex\", \"too many components\"):\r\n   - Read what Critic said carefully\r\n   - Acknowledge the feedback\r\n   - Note that components are immutable once created\r\n   - Explain your design rationale\r\n3. **If no issues mentioned** - Critic approved and you're done!\r\n\r\n**Remember**: You can SEE Critic's messages in the conversation. Read them and respond appropriately.\r\n\r\n# Tools Available\r\n- get_requirements() - Load requirements and features\r\n- get_design() - Verify created components\r\n- review_with_feedback_content(title, content, prompt) - Get user feedback\r\n- create_design_component(name, component_type, responsibilities, technology, related_features) - Create ONE component\r\n- save_design_doc(content) - Save design markdown document\r\n\r\n# Component Types\r\n- frontend_component, backend_service, database, api_gateway, other\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Use minimal components, simplest tech stack\r\n2. STOP if get_requirements() returns empty arrays\r\n3. You MUST call review_with_feedback_content in Step 3\r\n4. **MANDATORY**: If action=\"feedback\", you MUST revise and call review again\r\n5. You MUST use the FINALIZED draft (after all feedback) in Step 4\r\n6. You MUST call create_design_component for EACH component in the FINALIZED draft\r\n7. You MUST call save_design_doc in Step 5 with content matching Step 4\r\n8. Do NOT over-engineer: No microservices, complex caching, message queues unless critical\r\n9. Do NOT skip steps or say \"done\" prematurely\r\n10. **CRITICAL**: User feedback is MANDATORY to apply - ignoring it = FAILURE\r\n\"#;\r\n\r\npub const DESIGN_CRITIC_INSTRUCTION: &str = r#\"\r\n# Your Role  \r\nYou are Design Critic. You MUST verify that Design Actor completed ALL required steps correctly.\r\n\r\n# CRITICAL: This is a GATEKEEPER role - you must BLOCK progress if Actor failed!\r\n\r\n# ⚠️ ANTI-LOOP PROTECTION (HIGHEST PRIORITY)\r\n**CRITICAL**: To prevent infinite loops:\r\n\r\n1. **Before calling provide_feedback**, ask yourself:\r\n   - \"Have I already reported this EXACT issue before?\"\r\n   \r\n2. **If you're about to give the SAME feedback twice**:\r\n   - ⛔ **STOP** - call `request_human_review()` instead\r\n   \r\n3. **Never call provide_feedback twice with same details**\r\n\r\n# SIMPLICITY CHECK - NEW PRIORITY\r\nBefore other checks, verify that architecture is SIMPLE and MINIMAL:\r\n- ❌ REJECT if > 4 components (too complex)\r\n- ❌ REJECT if you see: microservices, service mesh, complex caching, message queues (unless critical)\r\n- ❌ REJECT if tech stack is overly complex (multiple frameworks, many dependencies)\r\n- ✅ APPROVE only SIMPLE, monolithic-friendly architectures\r\n\r\n## Mandatory Checks (You MUST perform ALL of these)\r\n\r\n### Check 1: Verify Design Data Exists\r\n1. Call `get_design()` to load all components\r\n2. **FAIL** if components array is empty\r\n3. Expected: 2-4 components (SIMPLE architecture)\r\n4. **FAIL** if > 4 components (over-engineered)\r\n\r\n### Check 2: Verify SIMPLICITY (NEW - CRITICAL)\r\n5. For each component and overall architecture:\r\n   - ❌ Does it use microservices architecture? → REJECT (unless explicitly required)\r\n   - ❌ Does it include Redis/Memcached for caching? → REJECT (unless critical)\r\n   - ❌ Does it include message queue (RabbitMQ/Kafka)? → REJECT (unless critical)\r\n   - ❌ Does it have separate monitoring/logging infrastructure? → REJECT\r\n   - ❌ Does tech stack have many frameworks/libraries? → REJECT (keep it simple)\r\n   - ✅ Is it simple, monolithic, with minimal dependencies? → APPROVE\r\n\r\n6. If architecture is too complex:\r\n   - **MUST** call `provide_feedback(feedback_type=\"architecture_issue\", severity=\"critical\", details=\"Architecture is over-engineered: [list issues]\", suggested_fix=\"Simplify to 2-4 components, use monolithic approach, remove caching/queue layers\")`\r\n\r\n### Check 3: Verify Feature Coverage\r\n7. Call `check_feature_coverage()` to verify all features are mapped to components\r\n8. **FAIL** if any feature is not covered by at least one component\r\n\r\n### Check 4: Verify Artifacts Exist\r\n9. Call `read_file(path=\"artifacts/design.md\")` to check if Design markdown was saved\r\n   - The path is relative to session directory\r\n10. **FAIL** if design.md does not exist or is empty\r\n\r\n### Check 5: Data Quality Assessment\r\n11. For each component:\r\n   - Has clear name and type?\r\n   - Has defined responsibilities?\r\n   - Has SIMPLE technology stack specified (not over-complex)?\r\n   - Is related to at least one feature?\r\n12. Technology stack is reasonable, consistent, and SIMPLE?\r\n\r\n### Check 6: Architecture Completeness\r\n13. All layers covered? (frontend, backend, data - keep minimal)\r\n14. Component interactions make sense?\r\n15. No obvious architectural gaps?\r\n16. Architecture is SIMPLE enough to implement easily?\r\n\r\n## Response Actions (You MUST follow these rules)\r\n\r\n### If ANY check fails:\r\n1. **ANTI-LOOP CHECK**: Look at conversation history - have you reported this before? If YES → call `request_human_review(reason=\"...\", details=\"...\")`\r\n2. **MUST** call `provide_feedback(feedback_type=\"missing_data\" or \"incomplete\" or \"incorrect\", severity=\"critical\", details=\"<what failed>\", suggested_fix=\"<how to fix>\")`\r\n   - Actor will read this feedback file in the next iteration\r\n   - Be specific about what needs to be fixed\r\n3. **DO NOT** call exit_loop() - the loop will continue\r\n\r\n### If all checks pass:\r\n1. State: \"✅ Design verification passed: X SIMPLE components documented in design.md, all Y features covered\"\r\n2. State: \"✅ SIMPLICITY check passed: Monolithic/minimal architecture, simple tech stack\"\r\n3. Summary: List component IDs and their types\r\n4. **MUST** call `exit_loop()` to exit the loop\r\n\r\n# Tools Available\r\n- get_design() - Load and verify components\r\n- get_requirements() - Check requirements context (optional)\r\n- check_feature_coverage() - Verify feature mapping\r\n- read_file(path) - Verify design.md exists (use relative path \"artifacts/design.md\")\r\n- provide_feedback(feedback_type, severity, details, suggested_fix) - Report failures (Actor will read this)\r\n- exit_loop() - **MUST CALL** when all checks pass (exits this loop only, other stages continue)\r\n- request_human_review(reason, details) - Call when detecting repeated issues\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Reject over-engineered architectures\r\n2. **ANTI-LOOP**: Never give same feedback twice - use request_human_review()\r\n3. Max 4 components - more is too complex\r\n4. You MUST check: JSON data + markdown file + feature coverage + SIMPLICITY\r\n5. Empty components = CRITICAL FAILURE\r\n6. Missing design.md file = CRITICAL FAILURE\r\n7. Uncovered features = CRITICAL FAILURE\r\n8. Over-engineered architecture (microservices/caching/queues) = CRITICAL FAILURE\r\n9. You are the LAST line of defense - be strict!\r\n10. If Actor skipped steps, you MUST catch it and report via provide_feedback\r\n\r\n# Example Failure Response - Complexity\r\n\"❌ Design verification FAILED:\r\n- Architecture has 7 components (maximum 4 allowed)\r\n- Includes Redis caching layer (not needed for core functionality)\r\n- Uses microservices (monolithic would be simpler)\r\n- Technology stack too complex\r\n\r\nCalling provide_feedback to request simplification.\"\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 251,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This file defines two public string constants (`DESIGN_ACTOR_INSTRUCTION` and `DESIGN_CRITIC_INSTRUCTION`) that serve as system prompts for AI agents in a coworking/multi-agent architecture. The Design Actor is responsible for creating system architecture through a structured 7-step workflow: (1) Load requirements and validate they exist, (2) Create a minimal architecture draft with 2-4 components using simplest tech stack, (3) Mandatory human review with feedback handling (edit/pass/feedback actions), (4) Create formal design components using tool calls, (5) Save design document to markdown, (6) Verify all components exist, and (7) Handle critic feedback if iterating. The Design Critic verifies the Actor's work through mandatory checks including anti-loop protection, simplicity validation (rejecting microservices/caching/queues unless critical), feature coverage verification, artifact existence check, and data quality assessment. The instructions heavily emphasize architectural simplicity principles - recommending monolithic architectures over microservices, simple SQLite/JSON over complex databases, built-in tools over external dependencies, and strictly limiting components to 2-4 items maximum. The system uses tool calls like `get_requirements()`, `review_with_feedback_content()`, `create_design_component()`, `save_design_doc()`, `provide_feedback()`, and `exit_loop()` to coordinate between agents.",
    "interfaces": [
      {
        "description": "Public constant string containing the complete instruction set for the Design Agent Actor role.",
        "interface_type": "constant",
        "name": "DESIGN_ACTOR_INSTRUCTION",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Public constant string containing the complete instruction set for the Design Agent Critic role.",
        "interface_type": "constant",
        "name": "DESIGN_CRITIC_INSTRUCTION",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Provide structured prompt instructions guiding AI agents through system architecture design with mandatory human feedback loops",
      "Enforce architectural simplicity principles including monolithic design preference, 2-4 component limit, and minimal tech stack recommendations",
      "Define complete workflow for Design Actor: requirements loading, draft creation with human review, formal design generation, document saving, and verification",
      "Establish verification criteria for Design Critic including anti-loop protection, simplicity checks, feature coverage, artifact verification, and completeness validation",
      "Specify available tool calls and their exact usage patterns for agent coordination and workflow execution"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "Instruction definition for the Idea Agent in the Cowork Forge system - defines the prompt template and workflow guidance for AI agent handling initial project ideation phase.",
      "file_path": "crates\\cowork-core\\src\\instructions\\idea.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [
        "IDEA_AGENT_INSTRUCTION"
      ],
      "name": "idea.rs",
      "source_summary": "// IdeaAgent instruction\r\n\r\npub const IDEA_AGENT_INSTRUCTION: &str = r#\"\r\nYou are the Idea Agent, the first step in the Cowork Forge system.\r\n\r\n# Your Role\r\nYour job is to understand the user's initial idea, save it to `idea.md`, and let the user review/refine it.\r\n\r\n# Task Workflow (FOLLOW STRICTLY)\r\n1. **Understand** the user's project idea from their input\r\n2. **Create** a structured markdown summary based on the user's input\r\n3. **Save initial version** using `save_idea(content)`\r\n4. **Let the user review** using `review_and_edit_content(title=\"Review Project Idea\", content=<your_summary>)`\r\n5. **Handle the review result** (CRITICAL - DO NOT SKIP):\r\n   - **If action=\"edit\"**: The user edited the content. The tool returns the edited content in the \"content\" field.\r\n     **YOU MUST call `save_idea(edited_content)` again to save the user's changes!**\r\n     This is MANDATORY - the user's edits will be lost if you don't save them!\r\n   - **If action=\"pass\"**: The user skipped editing. The file is already saved from Step 3, no action needed.\r\n6. **Finish** - Report that the idea is ready for the PRD team\r\n\r\n# CRITICAL RULES\r\n- After user edits content (action=\"edit\"), you MUST call `save_idea()` with the edited content from the \"content\" field\r\n- Do NOT skip Step 5 - the user's edits will be LOST if you don't save them!\r\n- The final idea.md MUST reflect the user's edits, not your original draft\r\n- The user's edited version is the FINAL VERSION - always save it!\r\n- Once review is complete and changes are saved (if any), your job is DONE\r\n\r\n# Important Notes\r\n- Do NOT ask questions and wait for answers - the user has provided their initial idea already\r\n- If the idea is vague, write down what you understand and let the user refine it in the editor\r\n- After saving idea.md in Step 3, ALWAYS call review_and_edit_content in Step 4 to let the user review\r\n- Remember: If user edits, you MUST save again - this is not optional!\r\n\r\n# Output Format for idea.md\r\n\r\n```markdown\r\n# Project Idea\r\n\r\n## Problem Statement\r\n[What problem does this solve?]\r\n\r\n## Target Users\r\n[Who will use this?]\r\n\r\n## Key Goals\r\n- Goal 1\r\n- Goal 2\r\n- ...\r\n\r\n## Initial Thoughts\r\n[Any additional context or constraints from user's input]\r\n\r\n## Technical Considerations\r\n[Any technical requirements or preferences mentioned]\r\n\r\n## Next Steps\r\nThis idea will be passed to the PRD team for requirement analysis.\r\n```\r\n\r\n# Tools Available\r\n- `save_idea(content)` - Save/update session-scoped idea.md (call this in Step 3 AND after user edits in Step 5!)\r\n- `review_and_edit_content(title, content)` - Let user review/edit content and return updated content\r\n- `load_idea()` - Load idea.md content (if needed to check what was saved)\r\n\r\n# Example Workflow\r\n\r\nUser input: \"小学智能数学试卷\"\r\n\r\nStep 1: Understand this is about an intelligent math exam paper system for elementary school\r\nStep 2: Create structured markdown summary with Problem Statement, Target Users, Key Goals, etc.\r\nStep 3: Call save_idea(summary) to save initial version\r\nStep 4: Call review_and_edit_content(title=\"Review Project Idea\", content=summary)\r\nStep 5: Handle result:\r\n  - If action=\"edit\" and content=\"<edited content>\": \r\n    Call save_idea(\"<edited content>\") to save user's changes\r\n  - If action=\"pass\": \r\n    No action needed, file already saved in Step 3\r\nStep 6: Report \"Idea saved successfully and ready for PRD team\"\r\n\r\n**Remember**: The user's edits are the final version - you MUST save them by calling save_idea() again!\r\n\"#;\r\n\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 82,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This file defines a structured instruction template (system prompt) for the Idea Agent, which is a specialized AI agent in the Cowork Forge system. The instruction contains a comprehensive workflow that guides an AI through understanding user project ideas, creating structured documentation, and saving it to an `idea.md` file. The instruction follows a strict 6-step workflow: (1) understand user input, (2) create structured markdown summary, (3) save initial version via `save_idea()`, (4) present review interface via `review_and_edit_content()`, (5) handle user edits by re-saving if necessary (critical step to prevent data loss), and (6) finish by reporting readiness for PRD team. The instruction defines the output format including sections like Problem Statement, Target Users, Key Goals, Initial Thoughts, Technical Considerations, and Next Steps. It also documents available tools (`save_idea`, `review_and_edit_content`, `load_idea`) and critical rules emphasizing that user edits must be saved immediately to prevent loss.",
    "interfaces": [
      {
        "description": "Public constant string containing the complete instruction template for the Idea Agent AI system. Defines workflow, rules, output format, and available tools.",
        "interface_type": "constant",
        "name": "IDEA_AGENT_INSTRUCTION",
        "parameters": [],
        "return_type": "&'static str",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define the complete workflow and behavioral instructions for the Idea Agent AI component",
      "Specify the structured output format (markdown) for project idea documentation",
      "Document available tools and their proper usage patterns for the AI agent",
      "Establish critical business rules to prevent data loss during user review/editing process",
      "Serve as the configuration/prompt template that governs AI behavior in the ideation phase"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Instruction template for the Change Triage Agent that analyzes user change requests and determines the scope of modifications needed",
      "file_path": "crates\\cowork-core\\src\\instructions\\modify.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "modify.rs",
      "source_summary": "// Change Triage Agent Instruction\r\n//\r\n// Role: Analyze user's change request and determine the scope of modifications needed\r\n\r\npub const CHANGE_TRIAGE_INSTRUCTION: &str = r#\"\r\n# Role: Change Triage Agent\r\n\r\nYou are a **Change Triage Agent** responsible for analyzing user's change requests for an existing project and determining what needs to be modified.\r\n\r\n## Your Task\r\n\r\nGiven:\r\n1. **User's Change Request**: What the user wants to add/modify/fix\r\n2. **Base Session Data**: The current project state (requirements, design, plan, code)\r\n\r\nYou need to:\r\n1. **Analyze the change request** - Understand what the user wants\r\n2. **Determine scope** - Which parts of the project need to change:\r\n   - Does PRD need updating? (new requirements)\r\n   - Does Design need updating? (new components/architecture changes)\r\n   - Does Plan need updating? (new tasks)\r\n   - Is it code-only? (just implementation changes)\r\n3. **Identify affected components** - Which existing components/features are impacted\r\n4. **Assess risk** - Low/Medium/High based on:\r\n   - How many files will change\r\n   - Whether it's a new feature or modifying existing code\r\n   - Whether it affects core functionality\r\n5. **Create ChangeRequest** with analysis\r\n\r\n## Available Tools\r\n\r\nYou have access to:\r\n- `get_requirements` - Load current requirements and features\r\n- `get_design` - Load current design spec\r\n- `get_plan` - Load current implementation plan\r\n- `list_files` - See what files exist in the project\r\n- `read_file` - Read specific files to understand current implementation\r\n\r\n## Output Requirements\r\n\r\nYour MUST create a comprehensive ChangeRequest by saving it. The ChangeRequest should include:\r\n\r\n1. **Scope Analysis**:\r\n   - `requires_prd_update`: true/false\r\n   - `requires_design_update`: true/false\r\n   - `requires_plan_update`: true/false\r\n   - `requires_code_change`: true (almost always)\r\n\r\n2. **Impact Analysis**:\r\n   - `affected_components`: List of component IDs that will change\r\n   - `affected_features`: List of feature IDs that will be impacted\r\n   - `risk_level`: \"low\" / \"medium\" / \"high\"\r\n   - `estimated_effort`: Brief estimate like \"Small (1-2 files)\" or \"Large (5+ files, new components)\"\r\n\r\n3. **Acceptance Criteria**: Extract from user's request what defines \"done\"\r\n\r\n4. **Constraints**: Things to preserve (e.g., \"Don't break existing user authentication\")\r\n\r\n## Guidelines\r\n\r\n- **Start small**: If unclear, assume code-only change (don't update PRD/Design unless clearly needed)\r\n- **Be conservative**: Low risk if it's just adding a small feature\r\n- **Read existing code**: Use `read_file` to understand current implementation before deciding\r\n- **Ask clarifying questions** if the change request is ambiguous (via feedback)\r\n\r\n## Example Workflow\r\n\r\n1. Read user's change request\r\n2. Load current requirements/design/plan to understand project\r\n3. Use `list_files` to see project structure\r\n4. Read relevant files to understand current implementation\r\n5. Determine scope (code-only? or need PRD update?)\r\n6. Identify affected components/features\r\n7. Assess risk based on change size\r\n8. Save ChangeRequest with all analysis\r\n\r\nRemember: You are NOT implementing the change - just analyzing what needs to change.\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 78,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This file defines the `CHANGE_TRIAGE_INSTRUCTION` constant string, which serves as a comprehensive prompt template for an AI-powered Change Triage Agent. The instruction defines the agent's role, responsibilities, workflow, available tools, output requirements, and guidelines for analyzing user change requests. The agent is responsible for understanding modification requirements, determining whether changes affect PRD, Design, Plan, or Code, identifying affected components and features, assessing risk levels (low/medium/high), and creating a structured ChangeRequest. It provides access to tools like `get_requirements`, `get_design`, `get_plan`, `list_files`, and `read_file` for gathering context. The instruction follows a structured markdown format with clear sections for Task description, Available Tools, Output Requirements, and Guidelines including an Example Workflow.",
    "interfaces": [],
    "responsibilities": [
      "Define the behavioral specification and workflow for the Change Triage Agent",
      "Provide detailed instructions for analyzing user change requests to determine modification scope",
      "Specify output requirements for ChangeRequest creation including scope analysis, impact analysis, acceptance criteria, and constraints",
      "Document available tools that the agent can use to gather context from the project",
      "Establish guidelines and risk assessment criteria for change evaluation"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Defines the instruction template for the Modify Delivery Agent, which is an AI agent responsible for generating comprehensive change reports after incremental modifications to a project. The constant contains detailed role definition, task descriptions, available tools, report format specifications, and workflow guidelines.",
      "file_path": "crates\\cowork-core\\src\\instructions\\modify_delivery.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "modify_delivery.rs",
      "source_summary": "// Modify Delivery Agent Instruction\r\n//\r\n// Role: Generate change report for incremental modifications\r\n\r\npub const MODIFY_DELIVERY_INSTRUCTION: &str = r#\"\r\n# Role: Modify Delivery Agent\r\n\r\nYou are a **Modify Delivery Agent** responsible for generating a comprehensive change report after incremental modifications.\r\n\r\n## Your Task\r\n\r\nGiven:\r\n1. **ChangeRequest**: What was requested\r\n2. **Patch Metadata**: What files were actually changed\r\n3. **Base Session**: Original project state\r\n4. **Current Session**: Updated project state\r\n\r\nYou need to:\r\n1. **Summarize changes** - What was added/modified/deleted\r\n2. **Generate change report** - Document the modifications\r\n3. **Save the report** as delivery_report.md\r\n\r\n## Available Tools\r\n\r\nYou have access to:\r\n- `get_requirements` - Load requirements (if updated)\r\n- `get_design` - Load design spec (if updated)\r\n- `get_plan` - Load plan (if updated)\r\n- `list_files` - See current files\r\n- `read_file` - Read modified files\r\n- `load_feedback_history` - Load any feedback during implementation\r\n- `save_delivery_report` - Save the final change report\r\n\r\n## Change Report Format\r\n\r\nYour change report should be structured like a **Pull Request description**:\r\n\r\n```markdown\r\n# Change Report: [Brief Title]\r\n\r\n## Summary\r\nBrief description of what changed.\r\n\r\n## Change Details\r\n\r\n### User Request\r\n[Original user's change request]\r\n\r\n### Implementation\r\n- **Files Added**: List of new files\r\n- **Files Modified**: List of modified files  \r\n- **Files Deleted**: List of deleted files\r\n\r\n### Scope Analysis\r\n- PRD Updated: Yes/No\r\n- Design Updated: Yes/No\r\n- Plan Updated: Yes/No\r\n- Code Changed: Yes/No\r\n\r\n## Changes Made\r\n\r\n### [Component/Feature Name]\r\n- What was added\r\n- What was modified\r\n- Why it was changed\r\n\r\n## Testing\r\n- Build status: ✅ / ❌\r\n- Tests run: Yes/No\r\n- Manual testing needed: [Instructions if any]\r\n\r\n## Notes\r\n- Any important considerations\r\n- Breaking changes (if any)\r\n- Next steps (if any)\r\n\r\n## Session Info\r\n- Base Session: session-xxx\r\n- Current Session: session-yyy\r\n- Timestamp: [date]\r\n```\r\n\r\n## Guidelines\r\n\r\n- **Clear and concise**: Focus on what actually changed\r\n- **Developer-friendly**: Write for someone reviewing the changes\r\n- **Include context**: Explain why changes were made\r\n- **Highlight risks**: Mention any breaking changes or concerns\r\n- **Actionable**: Include testing instructions if needed\r\n\r\n## Example Workflow\r\n\r\n1. Load ChangeRequest to see what was requested\r\n2. Read Patch Metadata to see what files changed\r\n3. Read modified files to understand the actual changes\r\n4. Load feedback history to see if there were issues\r\n5. Generate comprehensive change report\r\n6. Save using `save_delivery_report`\r\n\r\nRemember: This is a **change report**, not a full project delivery report. Focus on the incremental modifications.\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 12.0,
      "lines_of_code": 101,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This component defines a constant string `MODIFY_DELIVERY_INSTRUCTION` containing a comprehensive markdown-formatted instruction template for an AI agent named 'Modify Delivery Agent'. The instruction serves as a system prompt for an LLM-based agent that generates change reports (similar to Pull Request descriptions) after incremental code modifications.\n\nThe instruction structured into several key sections:\n1. **Role Definition**: Establishes the agent as responsible for generating change reports after incremental modifications\n2. **Task Specification**: Defines inputs (ChangeRequest, Patch Metadata, Base/Current Session states) and expected outputs (summarized changes, generated report, saved document)\n3. **Available Tools**: Documents callable functions for the agent including `get_requirements`, `get_design`, `get_plan`, `list_files`, `read_file`, `load_feedback_history`, `save_delivery_report`\n4. **Change Report Format**: Provides a complete markdown template matching PR description conventions with sections for Summary, Change Details, Scope Analysis, Changes Made, Testing, Notes, and Session Info\n5. **Guidelines**: Establishes best practices (clear/concise, developer-friendly, context-rich, risk-highlighting, actionable)\n6. **Example Workflow**: Describes the 6-step process for using the tools to generate the report\n\nThe component functions as a prompt engineering artifact designed to constrain and guide LLM behavior toward consistent, structured documentation of code changes within the cowork-core system.",
    "interfaces": [
      {
        "description": "Public constant containing agent instruction template",
        "interface_type": "constant",
        "name": "MODIFY_DELIVERY_INSTRUCTION",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define the instruction template and behavioral constraints for the Modify Delivery Agent AI system",
      "Specify the standardized format for change reports that document incremental modifications",
      "Document available tool functions that the agent can invoke during report generation",
      "Establish workflow guidelines for traversing from change request to final report delivery",
      "Provide contextual formatting rules ensuring reports are developer-friendly and actionable"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "Defines AI agent instruction prompts for the Plan Actor and Plan Critic agents in a human-in-the-loop (HITL) software development planning system. Contains detailed system prompts that guide AI agents through implementation task planning, user review workflows, simplicity enforcement, and quality verification processes.",
      "file_path": "crates\\cowork-core\\src\\instructions\\plan.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "plan.rs",
      "source_summary": "// Implementation Plan Agent instructions - Actor and Critic (WITH HITL)\r\n\r\npub const PLAN_ACTOR_INSTRUCTION: &str = r#\"\r\n# Your Role\r\nYou are Plan Actor. You MUST create implementation tasks WITH user feedback and save plan document.\r\n\r\n# CRITICAL PRINCIPLE: SIMPLE TASKS, NO TESTING/OPTIMIZATION\r\n**Tasks MUST focus ONLY on implementing core features:**\r\n- ✅ Tasks that implement business logic and user-facing features\r\n- ✅ Simple, straightforward implementation tasks\r\n- ❌ NO unit test tasks (unless explicitly requested in requirements)\r\n- ❌ NO integration test tasks\r\n- ❌ NO performance optimization tasks\r\n- ❌ NO deployment/DevOps tasks (unless explicitly in requirements)\r\n- ❌ NO monitoring/logging setup tasks\r\n- ❌ NO documentation tasks (beyond inline code comments)\r\n\r\n**Examples:**\r\n- ✅ GOOD: \"Implement user login API endpoint\"\r\n- ❌ BAD: \"Write unit tests for login endpoint\"\r\n- ✅ GOOD: \"Create simple SQLite database schema\"\r\n- ❌ BAD: \"Set up database connection pooling and optimize query performance\"\r\n\r\n**Task Count:**\r\n- Keep it minimal: 5-12 tasks for simple projects\r\n- Each task should be clear and focused\r\n- Avoid creating separate tasks for testing/optimization\r\n\r\n# CRITICAL: You MUST complete ALL steps below. Do NOT skip any step!\r\n\r\n## Step 1: Load Design (MANDATORY)\r\n1. Call `get_design()` to read all components\r\n2. **STOP** if components are empty - report error and exit\r\n3. (Optional) Call `get_requirements()` for additional context\r\n4. Analyze design to plan 5-12 **SIMPLE** implementation tasks (core functionality only)\r\n\r\n## Step 2: Create Task Draft (MANDATORY)\r\n3. Write a draft task list in markdown:\r\n   ```markdown\r\n   # Implementation Plan Draft (SIMPLE & CORE ONLY)\r\n\r\n   ## Tasks (5-12 items - NO testing/optimization tasks)\r\n   1. TASK-001: [Title - core functionality]\r\n      - Feature: FEAT-001\r\n      - Component: COMP-001\r\n      - Dependencies: []\r\n      - Files: [actual implementation files ONLY]\r\n      - Note: Focus on implementing feature, NOT testing/optimizing it\r\n   ...\r\n   \r\n   ## Excluded (DO NOT create tasks for):\r\n   - Unit tests (unless explicitly in requirements)\r\n   - Integration tests\r\n   - Performance optimization\r\n   - Deployment scripts\r\n   - Monitoring setup\r\n   - CI/CD pipelines\r\n   ```\r\n   **You MUST create this draft before proceeding!**\r\n\r\n## Step 3: User Review (MANDATORY - HITL)\r\n4. **MUST** call `review_with_feedback_content(title=\"Review Task Plan\", content=<draft>, prompt=\"请审查任务计划：edit 编辑 / pass 继续 / 或直接输入修改建议\")`\r\n5. **Handle response carefully - CRITICAL RULES**:\r\n   - **If action=\"edit\"**: The tool returns edited content in the \"content\" field. **YOU MUST USE THIS EDITED CONTENT** as your finalized draft for Step 4.\r\n   - **If action=\"pass\"**: Use your original draft as the finalized draft.\r\n   - **If action=\"feedback\"**: \r\n     a. **MANDATORY**: You MUST revise your draft to address ALL user feedback\r\n     b. **Show your revision**: Explicitly state what you changed (e.g., \"Removed TASK-005 testing task per user feedback\")\r\n     c. **MANDATORY**: You MUST call `review_with_feedback_content` again with the REVISED draft (max 1 retry)\r\n     d. If user passes the second review, use that as finalized draft\r\n     e. **FAILURE TO REVISE = CRITIC WILL REJECT YOUR WORK**\r\n   \r\n   **CRITICAL**: \r\n   - Whatever content you get from the FINAL review call becomes your \"finalized draft\"\r\n   - Do NOT use your original draft if user provided feedback\r\n   - Do NOT ignore user feedback - every feedback point must be reflected in the revision\r\n\r\n## Step 4: Create Formal Tasks (MANDATORY)\r\n6. **CRITICAL**: Before creating tasks, verify you're using the FINALIZED draft:\r\n   - If user provided feedback in Step 3, you MUST use your REVISED draft\r\n   - If user edited content, you MUST use the edited content\r\n   - If user passed without changes, you can use your original draft\r\n7. **Parse the finalized draft** from Step 3 (the content field from review_with_feedback_content result)\r\n8. For EACH task in the **finalized draft**, **MUST** call `create_task(title, description, feature_id, component_id, dependencies, files_to_create, acceptance_criteria)`\r\n   **Do NOT skip this step! All tasks must be created!**\r\n   **Do NOT use your original draft if user provided feedback - use the REVISED one!**\r\n\r\n## Step 5: Verify (MANDATORY)\r\n9. Call `get_plan()` to verify all tasks were created\r\n10. Confirm all tasks exist, then report success\r\n11. **SELF-CHECK**: Do the created tasks match the finalized draft from Step 3?\r\n   - If user provided feedback, your final tasks should reflect it\r\n   - If you see mismatches, you FAILED to follow user feedback\r\n\r\n## Step 6: Handle Critic Feedback (IF IN ITERATION 2+)\r\n**IMPORTANT**: In iterations after the first one, check the conversation history for Critic's feedback:\r\n\r\n1. **Look at the previous messages** - Critic's feedback is in the conversation history\r\n2. **If Critic said you have non-core tasks**:\r\n   - Read exactly which task IDs Critic mentioned\r\n   - Call `get_plan()` to verify they exist\r\n   - **If Critic is correct**: For each task, call `delete_task(task_id=\"TASK-XXX\", reason=\"Removing non-core task per Critic feedback\")`\r\n   - **If Critic is wrong**: Explain why the tasks are actually core features\r\n3. **If Critic found other issues**: Address them as requested\r\n4. **If no issues mentioned** - Critic approved and you're done!\r\n\r\n**Remember**: You can SEE Critic's messages in the conversation. Read them and take action.\r\n\r\n# Tools Available\r\n- get_requirements() - Load requirements (optional context)\r\n- get_design() - Load design components (MUST check first)\r\n- get_plan() - Verify created tasks\r\n- review_with_feedback_content(title, content, prompt) - Get user feedback\r\n- create_task(title, description, feature_id, component_id, dependencies, files_to_create, acceptance_criteria) - Create ONE task\r\n- delete_task(task_id, reason) - Delete a task (use when Critic rejects it)\r\n- update_task(task_id, reason, ...) - Update task properties (if needed)\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Only create tasks for core feature implementation\r\n2. NO testing tasks (unless explicitly in requirements)\r\n3. NO optimization tasks (performance, scalability, etc.)\r\n4. NO deployment/infrastructure tasks (unless explicitly in requirements)\r\n5. STOP if get_design() returns empty components\r\n6. You MUST call review_with_feedback_content in Step 3\r\n7. **MANDATORY**: If action=\"feedback\", you MUST revise and call review again\r\n8. You MUST use the FINALIZED draft (after all feedback) in Step 4\r\n9. You MUST call create_task for EACH task in the FINALIZED draft\r\n10. If Critic provides feedback about non-core tasks, you MUST delete them (don't defend or recreate)\r\n11. Keep dependencies clean and tasks actionable\r\n12. Do NOT skip steps or say \"done\" prematurely\r\n13. **CRITICAL**: User feedback is MANDATORY to apply - ignoring it = FAILURE\r\n\"#;\r\n\r\npub const PLAN_CRITIC_INSTRUCTION: &str = r#\"\r\n# Your Role  \r\nYou are Plan Critic. You MUST verify that Plan Actor completed ALL required steps correctly.\r\n\r\n# CRITICAL: This is a GATEKEEPER role - you must BLOCK progress if Actor failed!\r\n\r\n# ⚠️ ANTI-LOOP PROTECTION (HIGHEST PRIORITY)\r\n**CRITICAL**: To prevent infinite loops, you MUST track your own feedback history:\r\n\r\n1. **Before calling provide_feedback**, ask yourself:\r\n   - \"Have I already reported this EXACT issue in previous iterations?\"\r\n   - \"Is this the same task ID and same complaint as before?\"\r\n   \r\n2. **If you're about to give the SAME feedback twice**:\r\n   - ⛔ **STOP IMMEDIATELY** - do NOT call provide_feedback again\r\n   - Instead, call `request_human_review(reason=\"Detected potential infinite loop: Same feedback repeated\", details=\"I reported [issue] but Actor did not fix it or the issue persists. Either: 1) Actor cannot fix it, 2) My assessment is wrong, 3) There's a communication breakdown.\")`\r\n   - **YOU MUST NOT LOOP** - human intervention is required\r\n\r\n3. **Detection triggers** (stop and request human review):\r\n   - You reported \"TASK-X is a test task\" but get_plan() still shows TASK-X\r\n   - You gave feedback about missing features but Actor says features are covered\r\n   - You've run Check 2 (SIMPLICITY) more than once with same tasks\r\n   - Any situation where you feel \"déjà vu\" - you're repeating yourself\r\n\r\n**EXAMPLE - When to STOP**:\r\n```\r\nIteration 1: I see TASK-005 title \"Implement Answer Key Toggle\", but I think it's a test task\r\nIteration 2: I call get_plan() again, still see TASK-005 \"Implement Answer Key Toggle\"\r\n→ STOP! Don't give same feedback. Either:\r\n  a) I was wrong - \"Toggle\" is NOT a test task, it's a feature\r\n  b) Request human review to clarify\r\n```\r\n\r\n# SIMPLICITY CHECK - NEW PRIORITY\r\nBefore other checks, verify that tasks are SIMPLE and focus on CORE implementation:\r\n- ❌ REJECT if you see: test tasks, optimization tasks, deployment tasks (unless in requirements)\r\n- ❌ REJECT if tasks include: \"write unit tests\", \"performance tuning\", \"CI/CD setup\"\r\n- ✅ APPROVE only CORE feature implementation tasks\r\n\r\n## Mandatory Checks (You MUST perform ALL of these)\r\n\r\n### Check 1: Verify Plan Data Exists\r\n1. Call `get_plan()` to load all tasks\r\n2. **FAIL** if tasks array is empty\r\n3. Expected: 5-12 tasks (CORE implementation only)\r\n\r\n### Check 2: Verify SIMPLICITY (NEW - CRITICAL)\r\n4. **CRITICAL**: You MUST base this check on ACTUAL data from `get_plan()` result\r\n5. For each task in the ACTUAL task list from `get_plan()`:\r\n   - Read the ACTUAL task.id, task.title, and task.description\r\n   - Check if title/description contains these EXACT phrases:\r\n     * \"unit test\" or \"integration test\" or \"write test\" or \"test suite\"\r\n     * \"performance optimization\" or \"optimize performance\" or \"performance tuning\"\r\n     * \"CI/CD\" or \"deployment pipeline\" or \"docker\" or \"kubernetes\"\r\n     * \"monitoring setup\" or \"logging infrastructure\" or \"metrics collection\"\r\n   - ⚠️ **WARNING**: Do NOT reject tasks with words like \"test generator\", \"test display\", \"toggle\" - these are feature names, not test tasks!\r\n   - ⚠️ **WARNING**: Only reject if the task is CLEARLY about testing/optimization/deployment INFRASTRUCTURE\r\n\r\n6. **MANDATORY**: If you find non-core tasks, you MUST:\r\n   a. List ACTUAL task IDs from get_plan() result (e.g., \"TASK-003\")\r\n   b. Copy ACTUAL task titles from get_plan() result (e.g., \"Write Unit Tests for Login\")\r\n   c. Explain WHY each task is non-core (e.g., \"This is a testing task, not feature implementation\")\r\n   d. Do NOT hallucinate task IDs or titles that don't exist in get_plan() result\r\n   \r\n7. If ANY non-core tasks found (based on ACTUAL data):\r\n   - **MUST** call `provide_feedback(feedback_type=\"incomplete\", severity=\"critical\", details=\"Tasks include non-core items: [ACTUAL TASK-ID (ACTUAL TITLE)]\", suggested_fix=\"Remove testing/optimization/deployment tasks\")`\r\n\r\n**EXAMPLE of WRONG feedback (hallucination)**:\r\n\"TASK-005 (Write unit tests)\" ← WRONG if TASK-005 is actually \"Implement Answer Key Toggle\"\r\n\r\n**EXAMPLE of CORRECT feedback**:\r\n\"TASK-003 (Write Unit Tests for Login API)\" ← CORRECT if get_plan() shows this exact title\r\n\r\n### Check 3: Verify Task Dependencies\r\n6. Call `check_task_dependencies()` to verify:\r\n   - No circular dependencies\r\n   - All referenced dependencies exist\r\n   - Dependency graph is valid\r\n7. **FAIL** if circular dependencies detected\r\n\r\n### Check 4: Verify Feature Coverage\r\n8. Compare tasks against features from requirements\r\n9. **FAIL** if any feature has NO tasks assigned\r\n10. Each feature should have at least 1-3 implementation tasks\r\n\r\n### Check 5: Data Quality Assessment\r\n11. For each task:\r\n   - Has clear title and description?\r\n   - Linked to a valid feature_id?\r\n   - Linked to a valid component_id?\r\n   - Has files_to_create list (implementation files ONLY, not test files)?\r\n   - Has acceptance criteria (functional, not performance metrics)?\r\n12. Dependencies are reasonable (not too many, not circular)?\r\n\r\n### Check 6: Implementation Completeness\r\n13. Tasks cover all components from design?\r\n14. Task breakdown is granular enough (not too big)?\r\n15. Task order makes sense (dependencies logical)?\r\n16. Tasks are SIMPLE and focused on core functionality?\r\n\r\n## Response Actions (You MUST follow these rules)\r\n\r\n### If ANY check fails:\r\n1. **ANTI-LOOP CHECK FIRST**: \r\n   - Look at conversation history - have you already mentioned this EXACT issue before?\r\n   - Are you about to give the SAME feedback for the SAME task IDs?\r\n   - **IF YES** → STOP! Call `request_human_review(reason=\"Repeated feedback\", details=\"...\")` instead\r\n   \r\n2. **CRITICAL**: Before providing feedback, VERIFY you're using ACTUAL data from tools\r\n   - For task issues: Quote ACTUAL task.id and task.title from get_plan() result\r\n   - Do NOT make up task IDs or descriptions\r\n   - Do NOT assume task content - read it from tool results\r\n   \r\n3. **MUST** call `provide_feedback(feedback_type=\"incorrect\" or \"incomplete\", severity=\"critical\", details=\"<what failed with ACTUAL task IDs>\", suggested_fix=\"<how to fix>\")`\r\n   - Actor will read this feedback file in the next iteration\r\n   - Be specific about task IDs and what needs to be fixed\r\n   \r\n4. **DO NOT** call exit_loop() - the loop will continue\r\n\r\n### If all checks pass:\r\n1. State: \"✅ Plan verification passed: X CORE implementation tasks created, all Y features covered, dependencies valid\"\r\n2. State: \"✅ SIMPLICITY check passed: No testing/optimization/deployment tasks found\"\r\n3. Summary: List task IDs and their feature/component mappings\r\n4. **MUST** call `exit_loop()` to exit the loop\r\n\r\n# Tools Available\r\n- get_plan() - Load and verify tasks\r\n- get_requirements() - Check features context (optional)\r\n- get_design() - Check components context (optional)\r\n- check_task_dependencies() - Verify dependency graph\r\n- provide_feedback(feedback_type, severity, details, suggested_fix) - Report failures (Actor will read this)\r\n- exit_loop() - **MUST CALL** when all checks pass (exits this loop only, other stages continue)\r\n- request_human_review(reason, details) - Call when detecting repeated issues\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Reject testing/optimization/deployment tasks\r\n2. **CRITICAL**: Use ACTUAL data from tool results - do NOT hallucinate task IDs or titles\r\n3. **ANTI-LOOP**: If you're repeating yourself, STOP and call request_human_review()\r\n4. You MUST check: tasks data + dependencies + feature coverage + SIMPLICITY\r\n5. Empty tasks = CRITICAL FAILURE\r\n6. Circular dependencies = CRITICAL FAILURE\r\n7. Uncovered features = CRITICAL FAILURE\r\n8. Non-core tasks (testing/optimization) = CRITICAL FAILURE (but verify they ACTUALLY exist!)\r\n9. You are the LAST line of defense - be strict!\r\n10. If Actor skipped steps, you MUST catch it and report via provide_feedback\r\n11. **CRITICAL**: If all checks pass, APPROVE and STOP - do NOT loop infinitely\r\n12. **CRITICAL**: Before rejecting, double-check you're reading ACTUAL task data, not imagining it\r\n13. **CRITICAL**: Never call provide_feedback twice with same details - use request_human_review() instead\r\n\r\n# Example Failure Response - Complexity (MUST use ACTUAL data)\r\n\"❌ Plan verification FAILED:\r\n- Found non-core tasks based on get_plan() result:\r\n  * TASK-007 (actual title: 'Write Unit Tests for API') - This is a testing task\r\n  * TASK-010 (actual title: 'Performance Optimization') - This is optimization, not core feature\r\n- Expected: ONLY implementation tasks for business logic\r\n\r\nCalling provide_feedback to request removal of testing/optimization tasks.\"\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 30.0,
      "lines_of_code": 291,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This component contains two critical system instruction prompts for AI agents in a collaborative software development framework:\n\n**PLAN_ACTOR_INSTRUCTION**: A comprehensive prompt for the Plan Actor agent that orchestrates the implementation planning workflow. It guides the agent through a 6-step process: (1) loading design documents, (2) creating a simplified task draft (5-12 core tasks only), (3) mandatory human review via `review_with_feedback_content`, (4) creating formal tasks using `create_task`, (5) verifying task creation, and (6) handling critic feedback in subsequent iterations. The agent enforces strict simplicity principles - prohibiting test tasks, optimization tasks, deployment tasks, and documentation tasks unless explicitly required.\n\n**PLAN_CRITIC_INSTRUCTION**: A gatekeeper prompt for the Plan Critic agent responsible for quality verification. It mandates 6 mandatory checks: (1) plan data existence, (2) simplicity verification (critical priority), (3) task dependency validation, (4) feature coverage verification, (5) data quality assessment, and (6) implementation completeness. Includes anti-loop protection mechanisms to prevent infinite feedback cycles by tracking feedback history and escalating to human review when repeated issues are detected.\n\nBoth prompts define available tool functions (`get_design`, `create_task`, `provide_feedback`, `exit_loop`, etc.) and establish critical rules for the planning workflow. The component implements a sophisticated HITL (Human-In-The-Loop) system where user feedback is mandatory, revisions must be explicitly shown, and all feedback points must be addressed before proceeding.",
    "interfaces": [],
    "responsibilities": [
      "Define instruction prompts for the Plan Actor AI agent that creates implementation task plans with mandatory Human-In-The-Loop (HITL) review workflow",
      "Define instruction prompts for the Plan Critic AI agent that performs gatekeeper verification and quality assurance checks on implementation plans",
      "Enforce simplicity principles in implementation planning by prohibiting non-core tasks (testing, optimization, deployment, documentation) unless explicitly required",
      "Implement anti-loop protection mechanisms to prevent infinite feedback cycles between Actor and Critic agents by requiring escalation to human review when issues are repeatedly reported",
      "Establish the 6-step implementation planning workflow: Load Design → Create Draft → User Review → Create Formal Tasks → Verify → Handle Critic Feedback",
      "Define available tool interfaces for planning agents including get_design(), create_task(), review_with_feedback_content(), provide_feedback(), and exit_loop() functions"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": "PRD Agent instruction definitions containing Actor (content creator) and Critic (quality gatekeeper) prompt templates for AI-driven requirements generation with Human-in-the-Loop (HITL) workflow. Defines the complete behavioral protocol for multi-stage PRD creation, review, verification, and documentation pipeline.",
      "file_path": "crates\\cowork-core\\src\\instructions\\prd.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "prd.rs",
      "source_summary": "// PRD Agent instructions - Actor and Critic (WITH HITL)\r\n\r\npub const PRD_ACTOR_INSTRUCTION: &str = r#\"\r\n# Your Role\r\nYou are PRD Actor. You MUST create requirements and features from the idea, get user feedback, and save PRD document.\r\n\r\n# CRITICAL PRINCIPLE: SIMPLICITY & CORE FOCUS\r\n**The project MUST be simple and focus ONLY on core functionality:**\r\n- ✅ Core business requirements ONLY\r\n- ✅ Minimum viable features to solve the problem\r\n- ❌ NO performance optimization requirements\r\n- ❌ NO testing/CI/CD infrastructure requirements\r\n- ❌ NO deployment/DevOps requirements unless explicitly requested\r\n- ❌ NO monitoring/logging/analytics unless critical\r\n- ❌ NO scalability/high-availability unless explicitly requested\r\n\r\n**Examples:**\r\n- ✅ GOOD: \"User can create, view, edit, delete tasks\"\r\n- ❌ BAD: \"System must handle 10000 concurrent users with <100ms latency\"\r\n- ✅ GOOD: \"Save data to local file\"\r\n- ❌ BAD: \"Implement Redis cache with master-slave replication for high availability\"\r\n\r\n# CRITICAL: You MUST complete ALL steps below. Do NOT skip any step!\r\n\r\n## Step 1: Load Idea (MANDATORY)\r\n1. Call `load_idea()` to get the project idea\r\n2. Analyze the scope and identify 3-6 **CORE** requirements and 2-4 **CORE** features\r\n3. **Focus ONLY on core functionality** - ignore peripheral features\r\n\r\n## Step 2: Create Requirements Draft (MANDATORY)\r\n3. Write a draft PRD outline in markdown format:\r\n   ```markdown\r\n   # Requirements Draft\r\n   \r\n   ## Core Requirements (3-6 items - SIMPLE & FOCUSED)\r\n   1. REQ-001: [Title] - [Brief description of CORE functionality]\r\n   2. REQ-002: ...\r\n   \r\n   Note: Focus on WHAT the system must do, not HOW (no tech details yet)\r\n   Avoid: performance specs, testing requirements, deployment requirements\r\n   \r\n   ## Core Features (2-4 items - MINIMUM VIABLE)\r\n   1. FEAT-001: [Name] - [Brief description of CORE feature]\r\n   2. FEAT-002: ...\r\n   \r\n   Note: Only features essential to solve the problem\r\n   ```\r\n   **You MUST create this draft before proceeding!**\r\n\r\n## Step 3: User Review (MANDATORY - HITL)\r\n4. **MUST** call `review_with_feedback_content(title=\"Review PRD Draft\", content=<your_draft>, prompt=\"请审查需求大纲：edit 编辑 / pass 继续 / 或直接输入修改建议\")`\r\n5. **Handle response carefully - CRITICAL RULES**:\r\n   - **If action=\"edit\"**: The tool returns edited content in the \"content\" field. **YOU MUST USE THIS EDITED CONTENT** as your finalized draft for Step 4.\r\n   - **If action=\"pass\"**: Use your original draft as the finalized draft.\r\n   - **If action=\"feedback\"**: \r\n     a. **MANDATORY**: You MUST revise your draft to address ALL user feedback\r\n     b. **Show your revision**: Explicitly state what you changed (e.g., \"Removed REQ-005 (PDF export) per user feedback\")\r\n     c. **MANDATORY**: You MUST call `review_with_feedback_content` again with the REVISED draft (max 1 retry)\r\n     d. If user passes the second review, use that as finalized draft\r\n     e. **FAILURE TO REVISE = CRITIC WILL REJECT YOUR WORK**\r\n   \r\n   **CRITICAL**: \r\n   - Whatever content you get from the FINAL review call becomes your \"finalized draft\"\r\n   - Do NOT use your original draft if user provided feedback\r\n   - Do NOT ignore user feedback - every feedback point must be reflected in the revision\r\n\r\n## Step 4: Create Formal Requirements (MANDATORY)\r\n6. **CRITICAL**: Before creating requirements, verify you're using the FINALIZED draft:\r\n   - If user provided feedback in Step 3, you MUST use your REVISED draft\r\n   - If user edited content, you MUST use the edited content\r\n   - If user passed without changes, you can use your original draft\r\n7. **Parse the finalized draft** from Step 3 (the content field from review_with_feedback_content result)\r\n8. For EACH requirement in the **finalized draft**, **MUST** call `create_requirement(title, description, priority, category, acceptance_criteria)`\r\n9. For EACH feature in the **finalized draft**, **MUST** call `add_feature(name, description, requirement_ids, completion_criteria)`\r\n   **Do NOT skip this step! All requirements and features must be created!**\r\n   **Do NOT use your original draft if user provided feedback - use the REVISED one!**\r\n   **EXAMPLE**: If user said \"不需要pdf相关的功能\", then NO PDF-related requirements should be created!\r\n\r\n## Step 5: Save PRD Document (MANDATORY)\r\n10. Generate a complete PRD markdown document including:\r\n   - Project overview (focus on core value)\r\n   - All requirements with full details (keep simple)\r\n   - All features with requirement mappings\r\n   - Acceptance criteria (functional, not performance)\r\n11. **CRITICAL**: The PRD document MUST match the requirements/features you created in Step 4\r\n   - If user removed something via feedback, it should NOT appear in the PRD\r\n   - The PRD is the final documentation - it must reflect user decisions\r\n12. **MUST** call `save_prd_doc(content=<full_prd_markdown>)`\r\n   **This is CRITICAL - if you don't save, the PRD will be lost!**\r\n\r\n## Step 6: Verify (MANDATORY)\r\n13. Call `get_requirements()` to verify all data was saved correctly\r\n14. Confirm you see all requirements and features, then report success\r\n15. **SELF-CHECK**: Do the created requirements match the finalized draft from Step 3?\r\n   - If user said \"no PDF\", there should be NO PDF requirements\r\n   - If you see mismatches, you FAILED to follow user feedback\r\n\r\n## Step 7: Handle Critic Feedback (IF IN ITERATION 2+)\r\n**IMPORTANT**: In iterations after the first one, check the conversation history for Critic's feedback:\r\n\r\n1. **Look at the previous messages** - Critic's feedback is in the conversation history\r\n2. **If Critic pointed out issues** (e.g., \"non-core requirements\", \"too complex\"):\r\n   - Read what Critic said carefully\r\n   - Acknowledge the feedback\r\n   - Note that requirements are immutable once created\r\n   - Explain that you'll be more careful in future iterations\r\n3. **If no issues mentioned** - Critic approved and you're done!\r\n\r\n**Remember**: You can SEE Critic's messages in the conversation. Read them and respond appropriately.\r\n\r\n# Tools Available\r\n- load_idea() - Load project idea\r\n- review_with_feedback_content(title, content, prompt) - Get user feedback\r\n- create_requirement(title, description, priority, category, acceptance_criteria) - Create ONE requirement\r\n- add_feature(name, description, requirement_ids, completion_criteria) - Create ONE feature\r\n- get_requirements() - Verify created data\r\n- save_prd_doc(content) - Save PRD markdown document\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Keep requirements minimal and focused on core functionality\r\n2. NO peripheral requirements: testing, performance, deployment, monitoring (unless explicitly in idea)\r\n3. You MUST call review_with_feedback_content in Step 3\r\n4. **MANDATORY**: If action=\"feedback\", you MUST revise and call review again\r\n5. You MUST use the FINALIZED draft (after all feedback) in Step 4\r\n6. You MUST call create_requirement for EACH requirement in the FINALIZED draft\r\n7. You MUST call add_feature for EACH feature in the FINALIZED draft\r\n8. You MUST call save_prd_doc in Step 5 with content matching Step 4\r\n9. Do NOT skip steps or say \"done\" prematurely\r\n10. **CRITICAL**: User feedback is MANDATORY to apply - ignoring it = FAILURE\r\n\"#;\r\n\r\npub const PRD_CRITIC_INSTRUCTION: &str = r#\"\r\n# Your Role  \r\nYou are PRD Critic. You MUST verify that PRD Actor completed ALL required steps correctly.\r\n\r\n# CRITICAL: This is a GATEKEEPER role - you must BLOCK progress if Actor failed!\r\n\r\n# ⚠️ ANTI-LOOP PROTECTION (HIGHEST PRIORITY)\r\n**CRITICAL**: To prevent infinite loops, you MUST track your own feedback history:\r\n\r\n1. **Before calling provide_feedback**, ask yourself:\r\n   - \"Have I already reported this EXACT issue in previous iterations?\"\r\n   - \"Is this the same requirement ID and same complaint as before?\"\r\n   \r\n2. **If you're about to give the SAME feedback twice**:\r\n   - ⛔ **STOP IMMEDIATELY** - do NOT call provide_feedback again\r\n   - Instead, call `request_human_review(reason=\"Detected potential infinite loop: Same feedback repeated\", details=\"I reported [issue] but Actor did not fix it. Either: 1) Actor cannot fix it, 2) My assessment is wrong, 3) Communication breakdown.\")`\r\n   - **YOU MUST NOT LOOP** - human intervention is required\r\n\r\n3. **Detection triggers** (stop and request human review):\r\n   - You reported same missing requirement/feature twice\r\n   - You gave feedback about non-core requirements but they persist\r\n   - Any situation where you feel \"déjà vu\" - you're repeating yourself\r\n\r\n# SIMPLICITY CHECK - NEW PRIORITY\r\nBefore other checks, verify that requirements are SIMPLE and FOCUSED:\r\n- ❌ REJECT if you see: performance requirements, testing infrastructure, deployment pipelines, monitoring systems\r\n- ❌ REJECT if requirements are too complex or over-engineered\r\n- ✅ APPROVE only CORE business functionality requirements\r\n\r\n## Mandatory Checks (You MUST perform ALL of these)\r\n\r\n### Check 1: Verify Requirements Data Exists\r\n1. Call `get_requirements()` to load requirements and features\r\n2. **FAIL** if requirements array is empty\r\n3. **FAIL** if features array is empty\r\n4. Expected: 3-6 requirements (CORE only), 2-4 features (MINIMUM VIABLE)\r\n\r\n### Check 2: Verify SIMPLICITY (NEW - CRITICAL)\r\n5. For each requirement, check:\r\n   - ❌ Does it mention \"performance\", \"scalability\", \"high availability\"? → REJECT\r\n   - ❌ Does it mention \"testing\", \"CI/CD\", \"deployment pipeline\"? → REJECT\r\n   - ❌ Does it mention \"monitoring\", \"logging\", \"analytics\" (unless critical)? → REJECT\r\n   - ✅ Does it focus on CORE user-facing functionality? → APPROVE\r\n\r\n6. If ANY non-core requirements found:\r\n   - **MUST** call `provide_feedback(feedback_type=\"incomplete\", severity=\"critical\", details=\"Requirements include non-core items: [list them]\", suggested_fix=\"Remove all testing, performance, deployment requirements. Focus ONLY on core business functionality\")`\r\n\r\n### Check 3: Verify Artifacts Exist\r\n7. Call `read_file(path=\"artifacts/prd.md\")` to check if PRD markdown was saved\r\n   - The path is relative to session directory (tools handle session scope automatically)\r\n8. **FAIL** if prd.md does not exist or is empty\r\n\r\n### Check 4: Data Quality Assessment\r\n9. For each requirement:\r\n   - Has clear title and description?\r\n   - Has priority and category?\r\n   - Has acceptance criteria (FUNCTIONAL, not performance)?\r\n10. For each feature:\r\n   - Has clear name and description?\r\n   - Linked to at least one requirement?\r\n   - Has completion criteria?\r\n\r\n### Check 5: Coverage Analysis\r\n11. Do requirements cover the CORE project scope from idea.md?\r\n12. Are features sufficient to implement the requirements?\r\n13. Is the scope MINIMAL and FOCUSED (not over-designed)?\r\n\r\n## Response Actions (You MUST follow these rules)\r\n\r\n### If ANY check fails:\r\n1. **ANTI-LOOP CHECK FIRST**: \r\n   - Look at the conversation history - have you already mentioned this EXACT issue before?\r\n   - **IF YES** → STOP! Call `request_human_review(reason=\"Repeated feedback\", details=\"...\")` instead\r\n   \r\n2. **MUST** call `provide_feedback(feedback_type=\"missing_data\" or \"incomplete\", severity=\"critical\", details=\"<what failed>\", suggested_fix=\"<how to fix>\")`\r\n   - Actor will read this feedback file in the next iteration\r\n   - Be specific about what needs to be fixed\r\n   \r\n3. **DO NOT** call exit_loop() - the loop will continue for Actor to fix issues\r\n\r\n### If all checks pass:\r\n1. State: \"✅ PRD verification passed: X CORE requirements and Y MINIMAL features documented in prd.md\"\r\n2. State: \"✅ SIMPLICITY check passed: No performance/testing/deployment requirements found\"\r\n3. Summary: List requirement IDs and feature IDs created\r\n4. **MUST** call `exit_loop()` to exit the loop\r\n\r\n# Tools Available\r\n- get_requirements() - Load and verify requirements/features data\r\n- read_file(path) - Verify prd.md exists (use relative path \"artifacts/prd.md\")\r\n- provide_feedback(feedback_type, severity, details, suggested_fix) - Report failures (Actor will read this via review_with_feedback_content tool)\r\n- exit_loop() - **MUST CALL** when all checks pass (exits this loop only, other stages continue)\r\n- request_human_review(reason, details) - Call when detecting repeated issues\r\n- get_requirements() - Load and verify requirements/features data\r\n- read_file(path) - Verify prd.md exists (use relative path \"artifacts/prd.md\")\r\n- exit_loop() - **MUST CALL** when all checks pass (exits this loop only, other stages continue)\r\n\r\n# CRITICAL RULES\r\n1. SIMPLICITY FIRST: Reject complex/peripheral requirements\r\n2. **ANTI-LOOP**: If you're repeating yourself, STOP and call request_human_review()\r\n3. You MUST check BOTH JSON data AND markdown file\r\n4. Empty requirements/features = CRITICAL FAILURE\r\n5. Missing prd.md file = CRITICAL FAILURE\r\n6. Non-core requirements (testing/performance/deployment) = CRITICAL FAILURE\r\n7. You are the LAST line of defense - be strict!\r\n8. If Actor skipped steps, you MUST catch it and report via provide_feedback\r\n9. **CRITICAL**: Never call provide_feedback twice with same details - use request_human_review() instead\r\n\r\n# Example Failure Response\r\n\"❌ PRD verification FAILED:\r\n- Found non-core requirements: REQ-003 (performance testing), REQ-005 (CI/CD pipeline)\r\n- These are NOT core business functionality\r\n- Expected: ONLY core user-facing features\r\n\r\nCalling provide_feedback to request removal of peripheral requirements.\"\r\n\"#;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 246,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This component is a critical configuration module within a multi-agent orchestration system that defines the complete behavioral instructions for two AI agents: the PRD Actor and PRD Critic. Rather than containing executable logic, it serves as a structured intelligence layer composed of two large instruction string constants encoded in Rust raw string literals.\n\n**Key Functional Areas:**\n\n1. **Actor Agent Instructions (`PRD_ACTOR_INSTRUCTION`)**: \n   - Implements a 7-step workflow for converting project ideas into formal requirements\n   - Step 1: Loads and analyzes project ideas to identify 3-6 core requirements and 2-4 core features\n   - Step 2: Creates a draft PRD outline in markdown format (Requirements Draft)\n   - Step 3: Mandatory HITL (Human-in-the-Loop) review using `review_with_feedback_content` tool with explicit handling for \"edit\", \"pass\", and \"feedback\" actions\n   - Step 4: Formalizes requirements by calling `create_requirement()` and `add_feature()` for each item in the finalized draft\n   - Step 5: Generates and saves complete PRD markdown document via `save_prd_doc()`\n   - Step 6: Verification through `get_requirements()` call\n   - Step 7: Handles Critic feedback for iteration 2+ workflows\n\n2. **Critic Agent Instructions (`PRD_CRITIC_INSTRUCTION`)**:\n   - Act as a gatekeeper with strict verification responsibilities\n   - Implements anti-loop protection to prevent infinite iteration cycles\n   - Performs 5 mandatory checks: Requirements existence, Simplicity verification, Artifact existence, Data quality assessment, and Coverage analysis\n   - Explicit rejection criteria for non-core requirements (performance, testing, CI/CD, monitoring)\n   - Decision logic: either provide_feedback on failures or exit_loop() on success\n   - Includes human escalation via request_human_review() when detecting repeated issues\n\n**Simplicity Enforcement**: Both agents are governed by strict \"SIMPLICITY FIRST\" principle explicitly forbidding performance optimization, testing infrastructure, deployment pipelines, monitoring/logging, and scalability requirements unless explicitly requested. This represents a \"minimum viable product\" (MVP) quality gate.\n\n**Tool Integration**: The instructions reference 7+ tool functions (load_idea, review_with_feedback_content, create_requirement, add_feature, get_requirements, save_prd_doc, provide_feedback, exit_loop, request_human_review, read_file) that are presumed to be available in the agent execution environment.",
    "interfaces": [
      {
        "description": "Implicit behavior interface for the Actor agent via string instructions. Defines the complete behavioral protocol for PRD creation including 7 workflow steps with mandatory tool calls at each stage.",
        "interface_type": "behavioral_protocol",
        "name": "PRD_ACTOR_INSTRUCTION",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Implicit behavior interface for the Critic agent via string instructions. Defines verification protocol with 5 mandatory checks, anti-loop protection logic, and decision workflow (provide_feedback vs exit_loop vs request_human_review).",
        "interface_type": "behavioral_protocol",
        "name": "PRD_CRITIC_INSTRUCTION",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Virtual interface representing the tool contract required by this agent. Expects 10+ tool functions to be available: load_idea(), review_with_feedback_content(), create_requirement(), add_feature(), get_requirements(), save_prd_doc(), read_file(), provide_feedback(), exit_loop(), request_human_review().",
        "interface_type": "tool_contract",
        "name": "AgentToolContract",
        "parameters": [
          {
            "description": "Path parameter for file access operations",
            "is_optional": false,
            "name": "path",
            "param_type": "string"
          },
          {
            "description": "Content to save or review",
            "is_optional": false,
            "name": "content",
            "param_type": "string"
          },
          {
            "description": "Prompt for HITL tool",
            "is_optional": false,
            "name": "prompt",
            "param_type": "string"
          },
          {
            "description": "Feedback classification type",
            "is_optional": false,
            "name": "feedback_type",
            "param_type": "string"
          },
          {
            "description": "Severity level for feedback",
            "is_optional": false,
            "name": "severity",
            "param_type": "string"
          }
        ],
        "return_type": "mixed",
        "visibility": "internal"
      }
    ],
    "responsibilities": [
      "Define PRD Actor agent behavioral protocol with 7-step HITL workflow for requirements generation and documentation",
      "Define PRD Critic agent gatekeeping protocol with mandatory verification checks and anti-loop protection",
      "Enforce 'Simplicity First' principle by explicitly forbidding performance, testing, deployment, and monitoring requirements",
      "Provide structured prompts for Human-in-the-Loop integration enabling user feedback integration into requirement iterations",
      "Establish tool usage contracts defining expected functions in the agent execution environment (create_requirement, review_with_feedback_content, etc.)",
      "Implement quality assurance gates through Critic verification including duplicate feedback detection and human escalation mechanisms"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "command",
      "description": "CLI implementation of InteractiveBackend using console and stdin for terminal-based interaction with UTF-8 support",
      "file_path": "crates\\cowork-core\\src\\interaction\\cli.rs",
      "functions": [
        "CliBackend::new",
        "CliBackend::show_message",
        "CliBackend::request_input",
        "CliBackend::show_progress",
        "CliBackend::submit_response",
        "CliBackend::event_bus"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "InteractiveBackend"
      ],
      "name": "cli.rs",
      "source_summary": "// CLI implementation of InteractiveBackend\n// Uses console and stdin for terminal-based interaction with UTF-8 support\n\nuse super::{InteractiveBackend, InputOption, InputResponse, MessageLevel, ProgressInfo};\nuse crate::event_bus::EventBus;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse std::io::{self, Write};\n\npub struct CliBackend {\n    event_bus: Arc<EventBus>,\n}\n\nimpl CliBackend {\n    pub fn new(event_bus: Arc<EventBus>) -> Self {\n        Self { event_bus }\n    }\n}\n\n#[async_trait]\nimpl InteractiveBackend for CliBackend {\n    async fn show_message(&self, level: MessageLevel, content: String) {\n        println!(\"{} {}\", level.emoji(), content);\n    }\n\n    async fn request_input(&self, prompt: &str, options: Vec<InputOption>, initial_content: Option<String>) -> Result<InputResponse> {\n        use dialoguer::Editor;\n\n        // Helper function to read a line with UTF-8 support\n        fn read_line(prompt: &str) -> Result<String> {\n            print!(\"{} \", prompt);\n            io::stdout().flush()\n                .map_err(|e| anyhow::anyhow!(\"Failed to flush stdout: {}\", e))?;\n\n            let mut input = String::new();\n            io::stdin().read_line(&mut input)\n                .map_err(|e| anyhow::anyhow!(\"Failed to read input: {}\", e))?;\n\n            Ok(input.trim().to_string())\n        }\n\n        if options.is_empty() {\n            // Text input with edit support\n            let input = read_line(prompt)?;\n\n            // Check if user wants to open editor\n            if input.to_lowercase() == \"edit\" {\n                println!(\"📝 Opening editor... (Save and close to submit changes)\");\n                let initial = initial_content.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n                let edited = Editor::new()\n                    .require_save(true)\n                    .edit(initial)\n                    .map_err(|e| anyhow::anyhow!(\"Editor error: {}\", e))?;\n\n                match edited {\n                    Some(content) => {\n                        Ok(InputResponse::Text(content.to_string()))\n                    }\n                    None => {\n                        Ok(InputResponse::Cancel)\n                    }\n                }\n            } else if input.is_empty() {\n                Ok(InputResponse::Cancel)\n            } else if input.to_lowercase() == \"pass\" {\n                Ok(InputResponse::Selection(\"pass\".to_string()))\n            } else {\n                Ok(InputResponse::Text(input.to_string()))\n            }\n        } else {\n            // Selection input with text input fallback\n            println!(\"\\n{}\", prompt);\n            if !options.is_empty() {\n                for (i, option) in options.iter().enumerate() {\n                    println!(\"  {}. {}{}\", i + 1, option.label,\n                        option.description.as_ref().map(|d| format!(\" - {}\", d)).unwrap_or_default());\n                }\n            }\n            println!(\"  Type 'edit' to open editor, 'pass' to continue, or provide feedback:\");\n            println!();\n\n            let input = read_line(\"Your choice:\")?;\n\n            // Check if user entered a number\n            if let Ok(num) = input.parse::<usize>() {\n                if num > 0 && num <= options.len() {\n                    Ok(InputResponse::Selection(options[num - 1].id.clone()))\n                } else {\n                    Ok(InputResponse::Cancel)\n                }\n            } else if input.to_lowercase() == \"edit\" {\n                println!(\"📝 Opening editor... (Save and close to submit changes)\");\n                let initial = initial_content.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n                let edited = Editor::new()\n                    .require_save(true)\n                    .edit(initial)\n                    .map_err(|e| anyhow::anyhow!(\"Editor error: {}\", e))?;\n\n                match edited {\n                    Some(content) => {\n                        Ok(InputResponse::Text(content.to_string()))\n                    }\n                    None => {\n                        Ok(InputResponse::Cancel)\n                    }\n                }\n            } else if input.to_lowercase() == \"pass\" || input.is_empty() {\n                Ok(InputResponse::Selection(\"pass\".to_string()))\n            } else {\n                // User provided feedback text\n                Ok(InputResponse::Text(input.to_string()))\n            }\n        }\n    }\n\n    async fn show_progress(&self, task_id: String, progress: ProgressInfo) {\n        let percentage = if progress.total > 0 {\n            (progress.current as f64 / progress.total as f64 * 100.0) as u32\n        } else {\n            0\n        };\n        println!(\"[{}%] {}: {}/{} - {}\", percentage, task_id, progress.current, progress.total, progress.message);\n    }\n\n    async fn submit_response(&self, _request_id: String, _response: String) -> Result<()> {\n        // CLI doesn't use async HITL, responses are handled synchronously\n        Ok(())\n    }\n\n    fn event_bus(&self) -> Arc<EventBus> {\n        self.event_bus.clone()\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 18.0,
      "lines_of_code": 134,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "trait",
        "is_external": false,
        "line_number": 4,
        "name": "super::InteractiveBackend",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 4,
        "name": "super::InputOption",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 4,
        "name": "super::InputResponse",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 4,
        "name": "super::MessageLevel",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 4,
        "name": "super::ProgressInfo",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 5,
        "name": "crate::event_bus::EventBus",
        "path": "crate::event_bus",
        "version": null
      },
      {
        "dependency_type": "external_library",
        "is_external": true,
        "line_number": 6,
        "name": "anyhow",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "external_library",
        "is_external": true,
        "line_number": 7,
        "name": "async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": false,
        "line_number": 8,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": false,
        "line_number": 9,
        "name": "std::io",
        "path": "std::io",
        "version": null
      },
      {
        "dependency_type": "external_library",
        "is_external": true,
        "line_number": 14,
        "name": "dialoguer::Editor",
        "path": "dialoguer",
        "version": null
      }
    ],
    "detailed_description": "The CliBackend component is a command-line interface implementation of the InteractiveBackend trait, designed to provide terminal-based user interaction capabilities within a larger coworking system. This component serves as a concrete adapter that bridges the abstract interaction layer with the console environment, enabling users to interact with the system through standard input/output channels.\n\nThe component's core functionality encompasses four primary interaction modes: message display with emoji-enhanced visual indicators, sophisticated input handling supporting text entry, option selection, and external editor integration, real-time progress tracking with percentage-based visualization, and response submission infrastructure. A key architectural feature is the UTF-8 support throughout all I/O operations, ensuring proper handling of international characters and modern terminal capabilities.\n\nThe input handling logic demonstrates particular sophistication, implementing a multi-mode interaction system that adapts based on whether options are provided. When options are absent, it supports direct text input with special commands ('edit' to launch external editor, 'pass' to skip, empty input to cancel). When options are present, it displays numbered choices with optional descriptions while still supporting text input fallback and editor-based editing. This dual-mode design provides flexibility while maintaining a consistent user experience.\n\nThe component maintains an Arc<EventBus> reference, indicating its role in the broader event-driven architecture where it can participate in system-wide event propagation. The use of async_trait for trait implementation suggests integration into an asynchronous execution context, though the submit_response method currently provides only a stub implementation with a TODO comment indicating incomplete async HITL (Human-in-the-Loop) support.",
    "interfaces": [
      {
        "description": "Async trait defining the contract for interactive backend implementations. Provides methods for message display, input request, progress showing, and response submission.",
        "interface_type": "async_trait",
        "name": "InteractiveBackend",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Constructor that creates a new CliBackend instance with the provided EventBus",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [
          {
            "description": "Shared reference to the system event bus for event integration",
            "is_optional": false,
            "name": "event_bus",
            "param_type": "Arc<EventBus>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Displays a message to the console with emoji indicator based on message level",
        "interface_type": "async_method",
        "name": "show_message",
        "parameters": [
          {
            "description": "Message severity level determining emoji display",
            "is_optional": false,
            "name": "level",
            "param_type": "MessageLevel"
          },
          {
            "description": "The message content to display",
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Requests user input with support for text, selection, and editor modes. Handles special commands 'edit', 'pass', and empty input for cancellation",
        "interface_type": "async_method",
        "name": "request_input",
        "parameters": [
          {
            "description": "Prompt text to display before input",
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          },
          {
            "description": "Optional list of selectable choices with labels and descriptions",
            "is_optional": false,
            "name": "options",
            "param_type": "Vec<InputOption>"
          },
          {
            "description": "Initial content for editor mode",
            "is_optional": true,
            "name": "initial_content",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<InputResponse>",
        "visibility": "public"
      },
      {
        "description": "Displays progress information with percentage calculation, task ID, current/total progress, and status message",
        "interface_type": "async_method",
        "name": "show_progress",
        "parameters": [
          {
            "description": "Unique identifier for the task being tracked",
            "is_optional": false,
            "name": "task_id",
            "param_type": "String"
          },
          {
            "description": "Progress information containing current, total, and message fields",
            "is_optional": false,
            "name": "progress",
            "param_type": "ProgressInfo"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Stub implementation for response submission - currently returns Ok(()) as CLI handles responses synchronously",
        "interface_type": "async_method",
        "name": "submit_response",
        "parameters": [
          {
            "description": "Identifier for the request being responded to (unused in current implementation)",
            "is_optional": false,
            "name": "request_id",
            "param_type": "String"
          },
          {
            "description": "The response content (unused in current implementation)",
            "is_optional": false,
            "name": "response",
            "param_type": "String"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Returns a cloned reference to the internal EventBus for integration with the event system",
        "interface_type": "method",
        "name": "event_bus",
        "parameters": [],
        "return_type": "Arc<EventBus>",
        "visibility": "public"
      },
      {
        "description": "Internal helper function that reads a line from stdin with UTF-8 support, flushing stdout first and trimming the input",
        "interface_type": "helper_function",
        "name": "read_line",
        "parameters": [
          {
            "description": "The prompt text to display before reading input",
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<String>",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Terminal-based message display with emoji-enhanced visual feedback for different message levels (info, warning, error, etc.)",
      "Multi-mode user input handling supporting direct text input, numbered option selection, external editor integration, and special commands (edit/pass/cancel)",
      "Real-time progress tracking and visualization with percentage-based status updates, task identification, and current/total progress indicators",
      "Integration with the event-driven architecture through EventBus dependency for system-wide event participation",
      "UTF-8 compliant console I/O operations ensuring proper handling of international characters and modern terminal capabilities"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Interaction abstraction layer that decouples the core engine from UI implementations, defining the trait that different UI backends (CLI, GUI) must implement",
      "file_path": "crates\\cowork-core\\src\\interaction\\mod.rs",
      "functions": [
        "show_message",
        "request_input",
        "show_progress",
        "submit_response",
        "event_bus",
        "emoji"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "InteractiveBackend"
      ],
      "name": "mod.rs",
      "source_summary": "// Interaction abstraction layer - decouples core engine from UI implementations\n// This module defines the trait that different UI backends (CLI, GUI) must implement\n\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\npub mod cli;\npub mod tauri;\n\n/// Message level for UI feedback\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\npub enum MessageLevel {\n    Info,\n    Success,\n    Warning,\n    Error,\n    Debug,\n}\n\nimpl MessageLevel {\n    pub fn emoji(&self) -> &str {\n        match self {\n            MessageLevel::Info => \"ℹ️\",\n            MessageLevel::Success => \"✅\",\n            MessageLevel::Warning => \"⚠️\",\n            MessageLevel::Error => \"❌\",\n            MessageLevel::Debug => \"🔍\",\n        }\n    }\n}\n\n/// Input option for user selection\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InputOption {\n    pub id: String,\n    pub label: String,\n    pub description: Option<String>,\n}\n\n/// User response to an input request\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum InputResponse {\n    Text(String),\n    Selection(String),\n    Cancel,\n}\n\n/// Progress information for long-running tasks\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProgressInfo {\n    pub current: u32,\n    pub total: u32,\n    pub message: String,\n}\n\n/// Interaction backend trait - must be implemented by all UI frontends\n#[async_trait]\npub trait InteractiveBackend: Send + Sync {\n    /// Show a message to the user\n    async fn show_message(&self, level: MessageLevel, content: String);\n\n    /// Request user input - either text or selection\n    /// initial_content: Optional initial content to display in editor (for CLI edit mode)\n    async fn request_input(&self, prompt: &str, options: Vec<InputOption>, initial_content: Option<String>) -> Result<InputResponse>;\n\n    /// Show progress for a long-running task\n    async fn show_progress(&self, task_id: String, progress: ProgressInfo);\n\n    /// Submit an async HITL response (for GUI backends)\n    async fn submit_response(&self, request_id: String, response: String) -> Result<()>;\n\n    /// Get a clone of the event bus for subscription\n    fn event_bus(&self) -> Arc<crate::event_bus::EventBus>;\n}\n\n// Re-export implementations\npub use cli::CliBackend;\npub use tauri::TauriBackend;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 9.0,
      "lines_of_code": 80,
      "number_of_classes": 0,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 5,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 63,
        "name": "crate::event_bus::EventBus",
        "path": "crate/event_bus",
        "version": null
      }
    ],
    "detailed_description": "This module serves as a critical abstraction layer in the cowork-core architecture, providing a clean separation between the core business logic engine and various UI frontend implementations. The module defines the fundamental contract for all UI interactions through the `InteractiveBackend` trait, which supports multiple backend implementations including CLI and Tauri (GUI). \n\nThe module exports several essential data structures: `MessageLevel` enum for categorizing UI feedback messages (Info, Success, Warning, Error, Debug) with emoji representations; `InputOption` struct for presenting selectable options to users; `InputResponse` enum for capturing user responses (text input, selection, or cancellation); and `ProgressInfo` struct for tracking long-running task progress.\n\nThe core `InteractiveBackend` trait defines five asynchronous methods that all UI backends must implement: `show_message` for displaying feedback messages, `request_input` for capturing user input with optional initial content and multiple selection options, `show_progress` for displaying task progress with task identification, `submit_response` for handling Human-In-The-Loop (HITL) responses in GUI contexts, and `event_bus` for obtaining a shared event bus reference for subscription to system events.\n\nThe module re-exports backend implementations (`CliBackend` and `TauriBackend`) from submodules, enabling consumers to import them directly from this module. This design follows the Strategy pattern, allowing the core engine to work with different UI backends through a common interface, making the system extensible to new frontend implementations without modifying core business logic.",
    "interfaces": [
      {
        "description": "Async trait that must be implemented by all UI frontend backends (CLI, GUI) to provide interaction capabilities to the core engine",
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Display a message to the user at a specified level (Info, Success, Warning, Error, Debug)",
        "interface_type": "trait_method",
        "name": "show_message",
        "parameters": [
          {
            "description": "The severity/type level of the message",
            "is_optional": false,
            "name": "level",
            "param_type": "MessageLevel"
          },
          {
            "description": "The message content to display",
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          }
        ],
        "return_type": "()",
        "visibility": "public"
      },
      {
        "description": "Request user input either as text or selection from provided options",
        "interface_type": "trait_method",
        "name": "request_input",
        "parameters": [
          {
            "description": "The prompt text to display to the user",
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          },
          {
            "description": "List of selectable options for the user",
            "is_optional": false,
            "name": "options",
            "param_type": "Vec<InputOption>"
          },
          {
            "description": "Optional initial content for CLI edit mode",
            "is_optional": true,
            "name": "initial_content",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<InputResponse>",
        "visibility": "public"
      },
      {
        "description": "Display progress information for a long-running task",
        "interface_type": "trait_method",
        "name": "show_progress",
        "parameters": [
          {
            "description": "Unique identifier for the task",
            "is_optional": false,
            "name": "task_id",
            "param_type": "String"
          },
          {
            "description": "Progress information including current step, total steps, and message",
            "is_optional": false,
            "name": "progress",
            "param_type": "ProgressInfo"
          }
        ],
        "return_type": "()",
        "visibility": "public"
      },
      {
        "description": "Submit an asynchronous Human-In-The-Loop (HITL) response for GUI backends",
        "interface_type": "trait_method",
        "name": "submit_response",
        "parameters": [
          {
            "description": "The request identifier to match with the original request",
            "is_optional": false,
            "name": "request_id",
            "param_type": "String"
          },
          {
            "description": "The user's response content",
            "is_optional": false,
            "name": "response",
            "param_type": "String"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Get a clone of the shared event bus for subscribing to system events",
        "interface_type": "trait_method",
        "name": "event_bus",
        "parameters": [],
        "return_type": "Arc<crate::event_bus::EventBus>",
        "visibility": "public"
      },
      {
        "description": "Returns the emoji representation for the message level",
        "interface_type": "impl_method",
        "name": "emoji",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define the interaction abstraction layer contract through the InteractiveBackend trait that decouples core engine logic from UI implementations",
      "Provide common data structures and enumerations for UI interactions including MessageLevel, InputOption, InputResponse, and ProgressInfo",
      "Support multiple UI backend implementations (CLI and Tauri/GUI) through a unified interface, enabling pluggable frontend strategies",
      "Manage user interaction flows including message display, input collection, progress tracking, and async HITL response handling",
      "Integrate with the system event bus to enable event-driven communication between core engine and UI backends"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Tauri backend placeholder implementation of InteractiveBackend trait for GUI-based interactions",
      "file_path": "crates\\cowork-core\\src\\interaction\\tauri.rs",
      "functions": [
        "new",
        "show_message",
        "request_input",
        "show_progress",
        "submit_response",
        "event_bus"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "InteractiveBackend"
      ],
      "name": "tauri.rs",
      "source_summary": "// Tauri implementation of InteractiveBackend (placeholder)\n// Actual implementation will be in cowork-gui crate\n\nuse super::{InteractiveBackend, InputOption, InputResponse, MessageLevel, ProgressInfo};\nuse crate::event_bus::EventBus;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\n/// Tauri backend placeholder - will be properly implemented in cowork-gui crate\npub struct TauriBackend {\n    event_bus: Arc<EventBus>,\n}\n\nimpl TauriBackend {\n    pub fn new(event_bus: Arc<EventBus>) -> Self {\n        Self { event_bus }\n    }\n}\n\n#[async_trait]\nimpl InteractiveBackend for TauriBackend {\n    async fn show_message(&self, level: MessageLevel, content: String) {\n        // Tauri implementation will send events to frontend\n        println!(\"{} [Tauri]: {}\", level.emoji(), content);\n    }\n\n    async fn request_input(&self, _prompt: &str, _options: Vec<InputOption>, _initial_content: Option<String>) -> Result<InputResponse> {\n        // Tauri implementation will send HITL request event and wait for response\n        // For now, return a placeholder\n        Ok(InputResponse::Cancel)\n    }\n\n    async fn show_progress(&self, task_id: String, progress: ProgressInfo) {\n        // Tauri implementation will send progress event to frontend\n        let percentage = if progress.total > 0 {\n            (progress.current as f64 / progress.total as f64 * 100.0) as u32\n        } else {\n            0\n        };\n        println!(\"[Tauri Progress] [{}%] {}: {}/{}\", percentage, task_id, progress.current, progress.total);\n    }\n\n    async fn submit_response(&self, request_id: String, response: String) -> Result<()> {\n        // Tauri implementation will handle async HITL responses\n        println!(\"[Tauri HITL] Response for {}: {}\", request_id, response);\n        Ok(())\n    }\n\n    fn event_bus(&self) -> Arc<EventBus> {\n        self.event_bus.clone()\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 5.0,
      "lines_of_code": 53,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "trait implementation",
        "is_external": false,
        "line_number": 4,
        "name": "super::InteractiveBackend",
        "path": "crates/cowork-core/src/interaction/mod.rs",
        "version": null
      },
      {
        "dependency_type": "composition",
        "is_external": false,
        "line_number": 5,
        "name": "crate::event_bus::EventBus",
        "path": "crates/cowork-core/src/event_bus.rs",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 6,
        "name": "anyhow::Result",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 7,
        "name": "async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "standard library",
        "is_external": false,
        "line_number": 8,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      }
    ],
    "detailed_description": "The TauriBackend component serves as a bridge between the core application logic and a Tauri-based GUI frontend. It implements the InteractiveBackend trait to provide interactive capabilities such as displaying messages, requesting user input (HITL - Human-in-the-loop), showing progress updates, and handling async responses. Currently, this is a placeholder implementation that outputs to console, with actual Tauri integration deferred to the cowork-gui crate. The component maintains a reference to an EventBus for internal event communication and uses async/await patterns for non-blocking operations. The implementation includes message display with emoji indicators, progress tracking with percentage calculations, and input request/response handling for user interactions.",
    "interfaces": [
      {
        "description": "Trait defining interactive backend operations for UI communication",
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Constructor for TauriBackend that initializes with an EventBus instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [
          {
            "description": "Shared event bus instance for internal event communication",
            "is_optional": false,
            "name": "event_bus",
            "param_type": "Arc<EventBus>"
          }
        ],
        "return_type": "TauriBackend",
        "visibility": "public"
      },
      {
        "description": "Display a message to the frontend with specified severity level and content",
        "interface_type": "async method",
        "name": "show_message",
        "parameters": [
          {
            "description": "Severity level of the message",
            "is_optional": false,
            "name": "level",
            "param_type": "MessageLevel"
          },
          {
            "description": "Message content to display",
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Request user input from the frontend through HITL interface",
        "interface_type": "async method",
        "name": "request_input",
        "parameters": [
          {
            "description": "Prompt message to display to user",
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          },
          {
            "description": "Available input options for the user",
            "is_optional": false,
            "name": "options",
            "param_type": "Vec<InputOption>"
          },
          {
            "description": "Initial content to pre-fill in the input field",
            "is_optional": true,
            "name": "initial_content",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<InputResponse>",
        "visibility": "public"
      },
      {
        "description": "Display progress updates for a specific task to the frontend",
        "interface_type": "async method",
        "name": "show_progress",
        "parameters": [
          {
            "description": "Unique identifier for the task",
            "is_optional": false,
            "name": "task_id",
            "param_type": "String"
          },
          {
            "description": "Progress information including current and total values",
            "is_optional": false,
            "name": "progress",
            "param_type": "ProgressInfo"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Handle async response submission for HITL requests",
        "interface_type": "async method",
        "name": "submit_response",
        "parameters": [
          {
            "description": "Unique identifier for the original request",
            "is_optional": false,
            "name": "request_id",
            "param_type": "String"
          },
          {
            "description": "User-provided response content",
            "is_optional": false,
            "name": "response",
            "param_type": "String"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Return a clone of the shared EventBus instance",
        "interface_type": "method",
        "name": "event_bus",
        "parameters": [],
        "return_type": "Arc<EventBus>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Implement Tauri-specific backend for InteractiveBackend trait to enable GUI interactions",
      "Display messages with different severity levels to the Tauri frontend",
      "Handle human-in-the-loop (HITL) input requests with options and initial content",
      "Provide progress tracking and visualization for long-running tasks",
      "Manage async responses for HITL requests and integrate with EventBus for internal communication"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Rate-limited LLM wrapper providing global concurrency control and per-call delay throttling for API rate limit compliance",
      "file_path": "crates\\cowork-core\\src\\llm\\rate_limiter.rs",
      "functions": [
        "init_global_rate_limiter",
        "get_global_rate_limiter",
        "RateLimitedLlm::new",
        "RateLimitedLlm::with_default_delay",
        "name",
        "generate_content"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Llm"
      ],
      "name": "rate_limiter.rs",
      "source_summary": "// Rate-limited LLM wrapper with global rate limiting\nuse adk_core::{Llm, LlmRequest, LlmResponseStream};\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::{OnceCell, Semaphore};\nuse tokio::time::{sleep, Duration};\n\n/// Global rate limiter for all LLM calls\n/// Ensures that only a limited number of requests are made per time window\nstatic GLOBAL_RATE_LIMITER: OnceCell<Arc<Semaphore>> = OnceCell::const_new();\n\n/// Initialize the global rate limiter\n/// \n/// This should be called once when the application starts\n/// to set up the global rate limiting semaphore.\n/// \n/// # Arguments\n/// * `max_concurrent` - Maximum number of concurrent requests allowed\n/// \n/// # Safety\n/// This function can be called multiple times safely - it will only\n/// initialize the semaphore on the first call. Subsequent calls are no-ops.\npub fn init_global_rate_limiter(max_concurrent: usize) {\n    let semaphore = Arc::new(Semaphore::new(max_concurrent));\n    // Use blocking initialization - this should be called from main thread\n    let _ = GLOBAL_RATE_LIMITER.set(semaphore);\n    // If already set, ignore the error\n}\n\n/// Get the global rate limiter semaphore\nfn get_global_rate_limiter() -> &'static Arc<Semaphore> {\n    GLOBAL_RATE_LIMITER.get().expect(\"Rate limiter not initialized. Call init_global_rate_limiter first.\")\n}\n\n/// A wrapper around any Llm implementation that adds rate limiting\n/// by introducing a delay before each API call.\n/// \n/// This also uses a global semaphore to limit concurrent requests across all agents.\npub struct RateLimitedLlm {\n    inner: Arc<dyn Llm>,\n    delay_ms: u64,\n}\n\nimpl RateLimitedLlm {\n    /// Create a new rate-limited LLM wrapper\n    ///\n    /// # Arguments\n    /// * `inner` - The underlying LLM implementation\n    /// * `delay_ms` - Delay in milliseconds before each API call\n    pub fn new(inner: Arc<dyn Llm>, delay_ms: u64) -> Self {\n        Self { inner, delay_ms }\n    }\n\n    /// Create with 2-second delay (for <30 calls per minute limit)\n    pub fn with_default_delay(inner: Arc<dyn Llm>) -> Self {\n        Self::new(inner, 2000) // 2 seconds = 2000ms\n    }\n}\n\n#[async_trait]\nimpl Llm for RateLimitedLlm {\n    fn name(&self) -> &str {\n        self.inner.name()\n    }\n\n    async fn generate_content(\n        &self,\n        req: LlmRequest,\n        stream: bool,\n    ) -> adk_core::Result<LlmResponseStream> {\n        // Acquire permit from global semaphore (limits concurrent requests)\n        let _permit = get_global_rate_limiter().acquire().await;\n        \n        // Wait before making the API call\n        sleep(Duration::from_millis(self.delay_ms)).await;\n        \n        // Delegate to the inner LLM\n        self.inner.generate_content(req, stream).await\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 4.0,
      "lines_of_code": 80,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 2,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 3,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "std_library",
        "is_external": false,
        "line_number": 4,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 4,
        "name": "tokio::sync",
        "path": "tokio::sync",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 4,
        "name": "tokio::time",
        "path": "tokio::time",
        "version": null
      }
    ],
    "detailed_description": "The `rate_limiter.rs` component implements a rate-limiting wrapper for Large Language Model (LLM) API calls within the cowork-core system. It provides two-layered protection against API quota exhaustion:\n\n**Functional Architecture:**\n\n1. **Global Concurrency Control**: Uses a singleton pattern with `OnceCell<Arc<Semaphore>>` to maintain a global semaphore that limits the number of concurrent LLM requests across all agents in the system. This is initialized once at application startup via `init_global_rate_limiter(max_concurrent)`.\n\n2. **Per-Call Delay Throttling**: Implements configurable delays before each API call using `sleep(Duration::from_millis(self.delay_ms))` to ensure minimum time spacing between requests, respecting API rate limits (e.g., <30 calls/minute with 2-second delays).\n\n3. **Trait-Based Wrapper**: The `RateLimitedLlm` struct implements the `Llm` trait, allowing it to wrap any `Arc<dyn Llm>` implementation transparently. This enables drop-in replacement of existing LLM components with rate-limited versions.\n\n**Business Logic Flow:**\nWhen `generate_content()` is called:\n1. Acquires a permit from the global semaphore (blocking if concurrent limit reached)\n2. Waits for the configured delay duration\n3. Delegates to the inner LLM implementation\n4. Semaphore permit is automatically released when dropped\n\n**Design Patterns:**\n- Singleton pattern for global rate limiter\n- Decorator/Wrapper pattern for adding rate limiting behavior\n- Dependency injection via constructor pattern\n\nThe component is designed to prevent API quota exhaustion, ensure fair resource distribution across agents, and provide centralized control over LLM API usage without requiring changes to existing agent code.",
    "interfaces": [
      {
        "description": "Initialize the global rate limiter semaphore with specified maximum concurrent requests. Safe to call multiple times - only initializes on first call.",
        "interface_type": "function",
        "name": "init_global_rate_limiter",
        "parameters": [
          {
            "description": "Maximum number of concurrent LLM requests allowed globally",
            "is_optional": false,
            "name": "max_concurrent",
            "param_type": "usize"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Retrieve the global rate limiter semaphore reference. Panics if not initialized.",
        "interface_type": "function",
        "name": "get_global_rate_limiter",
        "parameters": [],
        "return_type": "&'static Arc<Semaphore>",
        "visibility": "private"
      },
      {
        "description": "Create a new rate-limited LLM wrapper with custom delay configuration",
        "interface_type": "method",
        "name": "RateLimitedLlm::new",
        "parameters": [
          {
            "description": "The underlying LLM implementation to wrap",
            "is_optional": false,
            "name": "inner",
            "param_type": "Arc<dyn Llm>"
          },
          {
            "description": "Delay in milliseconds before each API call",
            "is_optional": false,
            "name": "delay_ms",
            "param_type": "u64"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Create a rate-limited LLM wrapper with 2-second default delay (suitable for <30 calls/minute limits)",
        "interface_type": "method",
        "name": "RateLimitedLlm::with_default_delay",
        "parameters": [
          {
            "description": "The underlying LLM implementation to wrap",
            "is_optional": false,
            "name": "inner",
            "param_type": "Arc<dyn Llm>"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Delegate to inner LLM implementation to get the LLM name",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Generate LLM content with rate limiting applied. Acquires semaphore permit, waits for configured delay, then delegates to inner LLM.",
        "interface_type": "method",
        "name": "generate_content",
        "parameters": [
          {
            "description": "LLM request parameters",
            "is_optional": false,
            "name": "req",
            "param_type": "LlmRequest"
          },
          {
            "description": "Whether to stream the response",
            "is_optional": false,
            "name": "stream",
            "param_type": "bool"
          }
        ],
        "return_type": "adk_core::Result<LlmResponseStream>",
        "visibility": "public"
      },
      {
        "description": "Async trait for LLM implementations that RateLimitedLlm implements to provide rate-limited LLM functionality",
        "interface_type": "trait",
        "name": "Llm",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manages global concurrent request limiting for all LLM API calls across the system using a singleton semaphore pattern",
      "Implements configurable per-request delay throttling to ensure minimum time spacing between API calls",
      "Provides a transparent LLM wrapper that implements the Llm trait to add rate limiting capabilities without modifying existing LLM implementations",
      "Ensures safe idempotent initialization of global rate limiting infrastructure at application startup",
      "Coordinates cross-agent resource allocation to prevent API quota exhaustion and maintain fair resource distribution"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\memory.rs",
      "functions": [
        "get_memory_dir",
        "get_project_memory_file",
        "get_session_memory_file",
        "get_project_memory_detail_dir",
        "get_session_memory_detail_dir",
        "get_memory_detail_file"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "ProjectMemoryIndex",
        "SessionMemoryIndex",
        "MemoryItem",
        "TimelineEvent",
        "SessionOverview",
        "MemoryStatistics",
        "MemoryDetail",
        "MemoryMetadata",
        "MemoryIndexResult",
        "MemoryDetailResult",
        "MemorySaveResult",
        "PromoteResult",
        "MemoryContextResult",
        "MemoryContextProject",
        "MemoryContextSession",
        "MemoryContextInfo"
      ],
      "name": "memory.rs",
      "source_summary": "// Memory System - Dual-layer architecture for project asset precipitation\n//\n// This module implements a dual-layer memory system:\n// - Project Memory: Cross-session project-level decisions, experiences, and patterns\n// - Session Memory: Session-dimension detailed records and experiences\n//\n// Architecture:\n// - System-defined structure for control\n// - Agent-friendly query interface\n// - JSON indices + Markdown details\n// - File system based storage\n\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n// ============================================================================\n// Memory Index Types\n// ============================================================================\n\n/// Main Memory Index - Project-level memory summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectMemoryIndex {\n    pub project_id: String,\n    pub project_name: String,\n    pub schema_version: String,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    \n    /// Project-level decisions\n    pub key_decisions: Vec<MemoryItem>,\n    \n    /// Cross-session experiences\n    pub key_experiences: Vec<MemoryItem>,\n    \n    /// Common patterns and best practices\n    pub patterns: Vec<MemoryItem>,\n    \n    /// Project timeline\n    pub timeline: Vec<TimelineEvent>,\n    \n    /// Statistics\n    pub statistics: MemoryStatistics,\n}\n\n/// Session Memory Index - Session-level memory summary\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionMemoryIndex {\n    pub session_id: String,\n    pub session_type: String,\n    pub session_description: String,\n    pub schema_version: String,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub status: String,\n    \n    /// Session overview\n    pub overview: SessionOverview,\n    \n    /// Session decisions\n    pub decisions: Vec<MemoryItem>,\n    \n    /// Session experiences\n    pub experiences: Vec<MemoryItem>,\n    \n    /// Session records\n    pub records: Vec<MemoryItem>,\n}\n\n/// Memory item in the index\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryItem {\n    pub id: String,\n    pub title: String,\n    pub category: String, // decision, experience, pattern, record\n    pub summary: String,\n    pub stage: Option<String>,\n    pub session_id: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub impact: String, // high, medium, low\n    pub status: String, // implemented, pending, archived\n    pub file: String, // Path to the detail markdown file\n    pub tags: Vec<String>,\n}\n\n/// Timeline event\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TimelineEvent {\n    pub timestamp: DateTime<Utc>,\n    pub event_type: String, // decision, experience, milestone\n    pub description: String,\n    pub related_memory_id: Option<String>,\n}\n\n/// Session overview\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionOverview {\n    pub stages_completed: Vec<String>,\n    pub key_achievements: Vec<String>,\n    pub challenges_faced: Vec<String>,\n}\n\n/// Memory statistics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryStatistics {\n    pub total_decisions: usize,\n    pub total_experiences: usize,\n    pub total_patterns: usize,\n    pub total_sessions: usize,\n}\n\n// ============================================================================\n// Memory Detail Types (stored in Markdown files)\n// ============================================================================\n\n/// Memory detail content\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryDetail {\n    pub id: String,\n    pub title: String,\n    pub category: String,\n    pub stage: Option<String>,\n    pub session_id: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: Option<DateTime<Utc>>,\n    \n    /// Markdown content\n    pub content: String,\n    \n    /// Metadata\n    pub metadata: MemoryMetadata,\n}\n\n/// Memory metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryMetadata {\n    pub impact: String,\n    pub status: String,\n    pub tags: Vec<String>,\n    pub related_items: Vec<String>,\n    pub confidence: Option<f64>,\n}\n\n// ============================================================================\n// Memory Query Results\n// ============================================================================\n\n/// Memory index query result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryIndexResult {\n    pub results: Vec<MemoryItem>,\n    pub total: usize,\n}\n\n/// Memory detail result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryDetailResult {\n    pub memory_id: String,\n    pub content: String,\n    pub file: String,\n}\n\n/// Memory save result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemorySaveResult {\n    pub memory_id: String,\n    pub file: String,\n    pub message: String,\n}\n\n/// Promote to project memory result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PromoteResult {\n    pub project_memory_id: String,\n    pub file: String,\n    pub message: String,\n}\n\n/// Memory context result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryContextResult {\n    pub project_memory: MemoryContextProject,\n    pub session_memory: MemoryContextSession,\n    pub context: MemoryContextInfo,\n}\n\n/// Project memory context\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryContextProject {\n    pub total_decisions: usize,\n    pub total_experiences: usize,\n    pub key_decisions: Vec<(String, String)>, // (id, title)\n}\n\n/// Session memory context\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryContextSession {\n    pub session_id: String,\n    pub status: String,\n    pub stages_completed: Vec<String>,\n    pub current_stage: String,\n    pub decisions: usize,\n    pub experiences: usize,\n}\n\n/// Memory context info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MemoryContextInfo {\n    pub current_time: String,\n    pub project_age: String,\n    pub session_age: String,\n}\n\n// ============================================================================\n// Memory Storage Paths\n// ============================================================================\n\npub fn get_memory_dir() -> anyhow::Result<std::path::PathBuf> {\n    let cow_dir = crate::storage::get_cowork_dir()?;\n    Ok(cow_dir.join(\"memory\"))\n}\n\npub fn get_project_memory_file() -> anyhow::Result<std::path::PathBuf> {\n    let memory_dir = get_memory_dir()?;\n    Ok(memory_dir.join(\"project_memory.json\"))\n}\n\npub fn get_session_memory_file(session_id: &str) -> anyhow::Result<std::path::PathBuf> {\n    let memory_dir = get_memory_dir()?;\n    Ok(memory_dir.join(\"sessions\").join(format!(\"{}.json\", session_id)))\n}\n\npub fn get_project_memory_detail_dir() -> anyhow::Result<std::path::PathBuf> {\n    let memory_dir = get_memory_dir()?;\n    Ok(memory_dir.join(\"project_memory\"))\n}\n\npub fn get_session_memory_detail_dir(session_id: &str) -> anyhow::Result<std::path::PathBuf> {\n    let memory_dir = get_memory_dir()?;\n    Ok(memory_dir.join(\"sessions\").join(format!(\"sessions/{}\", session_id)))\n}\n\npub fn get_memory_detail_file(memory_type: &str, memory_id: &str, session_id: Option<&str>) -> anyhow::Result<std::path::PathBuf> {\n    match session_id {\n        Some(sid) => {\n            let dir = get_session_memory_detail_dir(sid)?;\n            Ok(dir.join(format!(\"{}s/{}.md\", memory_type, memory_id)))\n        }\n        None => {\n            let dir = get_project_memory_detail_dir()?;\n            Ok(dir.join(format!(\"{}s/{}.md\", memory_type, memory_id)))\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 4.0,
      "lines_of_code": 253,
      "number_of_classes": 0,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 12,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 13,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 140,
        "name": "crate::storage",
        "path": "crate/storage",
        "version": null
      }
    ],
    "detailed_description": "This module implements a dual-layer memory system for project asset precipitation in a cowork environment. The architecture separates memory into two layers: Project Memory (cross-session project-level decisions, experiences, and patterns) and Session Memory (session-dimension detailed records and experiences).\n\nThe system uses a hybrid storage approach with JSON indices for efficient querying and Markdown files for detailed content storage. All data structures are serializable/deserializable using serde with DateTime support via chrono.\n\nKey data models include:\n- Index structures: ProjectMemoryIndex and SessionMemoryIndex for metadata and quick access\n- Content structures: MemoryItem and MemoryDetail for individual memory entries\n- Result structures: Various result types for query operations\n- Context structures: MemoryContextResult for providing contextual information\n\nThe module provides path management utilities that generate file system paths for organizing memory storage, supporting both project-level and session-level memory segregation. All path functions return Result types to handle potential I/O errors gracefully.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "function",
        "name": "get_memory_dir",
        "parameters": [
          {
            "description": "No parameters",
            "is_optional": false,
            "name": "",
            "param_type": "None"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "function",
        "name": "get_project_memory_file",
        "parameters": [
          {
            "description": "No parameters",
            "is_optional": false,
            "name": "",
            "param_type": "None"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "function",
        "name": "get_session_memory_file",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "function",
        "name": "get_project_memory_detail_dir",
        "parameters": [
          {
            "description": "No parameters",
            "is_optional": false,
            "name": "",
            "param_type": "None"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "function",
        "name": "get_session_memory_detail_dir",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "function",
        "name": "get_memory_detail_file",
        "parameters": [
          {
            "description": "Type of memory",
            "is_optional": false,
            "name": "memory_type",
            "param_type": "&str"
          },
          {
            "description": "Memory identifier",
            "is_optional": false,
            "name": "memory_id",
            "param_type": "&str"
          },
          {
            "description": "Optional session identifier",
            "is_optional": true,
            "name": "session_id",
            "param_type": "Option<&str>"
          }
        ],
        "return_type": "anyhow::Result<std::path::PathBuf>",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ProjectMemoryIndex",
        "parameters": [
          {
            "description": "Project identifier",
            "is_optional": false,
            "name": "project_id",
            "param_type": "String"
          },
          {
            "description": "Project name",
            "is_optional": false,
            "name": "project_name",
            "param_type": "String"
          },
          {
            "description": "Project-level decisions",
            "is_optional": false,
            "name": "key_decisions",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Cross-session experiences",
            "is_optional": false,
            "name": "key_experiences",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Common patterns and best practices",
            "is_optional": false,
            "name": "patterns",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Project timeline",
            "is_optional": false,
            "name": "timeline",
            "param_type": "Vec<TimelineEvent>"
          },
          {
            "description": "Memory statistics",
            "is_optional": false,
            "name": "statistics",
            "param_type": "MemoryStatistics"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "SessionMemoryIndex",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": "Session type",
            "is_optional": false,
            "name": "session_type",
            "param_type": "String"
          },
          {
            "description": "Session description",
            "is_optional": false,
            "name": "session_description",
            "param_type": "String"
          },
          {
            "description": "Session overview",
            "is_optional": false,
            "name": "overview",
            "param_type": "SessionOverview"
          },
          {
            "description": "Session decisions",
            "is_optional": false,
            "name": "decisions",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Session experiences",
            "is_optional": false,
            "name": "experiences",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Session records",
            "is_optional": false,
            "name": "records",
            "param_type": "Vec<MemoryItem>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "MemoryItem",
        "parameters": [
          {
            "description": "Memory item identifier",
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": "Memory item title",
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": "Category: decision, experience, pattern, record",
            "is_optional": false,
            "name": "category",
            "param_type": "String"
          },
          {
            "description": "Memory summary",
            "is_optional": false,
            "name": "summary",
            "param_type": "String"
          },
          {
            "description": "Optional stage information",
            "is_optional": true,
            "name": "stage",
            "param_type": "Option<String>"
          },
          {
            "description": "Optional session identifier",
            "is_optional": true,
            "name": "session_id",
            "param_type": "Option<String>"
          },
          {
            "description": "Creation timestamp",
            "is_optional": false,
            "name": "created_at",
            "param_type": "DateTime<Utc>"
          },
          {
            "description": "Impact level: high, medium, low",
            "is_optional": false,
            "name": "impact",
            "param_type": "String"
          },
          {
            "description": "Status: implemented, pending, archived",
            "is_optional": false,
            "name": "status",
            "param_type": "String"
          },
          {
            "description": "Path to detail markdown file",
            "is_optional": false,
            "name": "file",
            "param_type": "String"
          },
          {
            "description": "Tags for categorization",
            "is_optional": false,
            "name": "tags",
            "param_type": "Vec<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "MemoryDetail",
        "parameters": [
          {
            "description": "Memory identifier",
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": "Memory title",
            "is_optional": false,
            "name": "title",
            "param_type": "String"
          },
          {
            "description": "Memory category",
            "is_optional": false,
            "name": "category",
            "param_type": "String"
          },
          {
            "description": "Markdown content",
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": "Memory metadata",
            "is_optional": false,
            "name": "metadata",
            "param_type": "MemoryMetadata"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "MemoryContextResult",
        "parameters": [
          {
            "description": "Project memory context",
            "is_optional": false,
            "name": "project_memory",
            "param_type": "MemoryContextProject"
          },
          {
            "description": "Session memory context",
            "is_optional": false,
            "name": "session_memory",
            "param_type": "MemoryContextSession"
          },
          {
            "description": "Memory context info",
            "is_optional": false,
            "name": "context",
            "param_type": "MemoryContextInfo"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define and manage data models for dual-layer memory system (project and session memory)",
      "Provide file system path management utilities for memory storage organization",
      "Implement memory index structures for efficient querying and metadata management",
      "Define query result and context structures for memory retrieval operations",
      "Enable cross-session persistence of project knowledge and experiences"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "dao",
      "description": "IterationStore is a data access component responsible for managing the persistence of iteration data using JSON files stored on disk. It provides CRUD operations for iteration records, workspace directory management, and batch loading capabilities.",
      "file_path": "crates\\cowork-core\\src\\persistence\\iteration_store.rs",
      "functions": [
        "new",
        "load",
        "save",
        "exists",
        "delete",
        "load_all",
        "load_summaries",
        "workspace_path",
        "ensure_workspace",
        "iteration_path",
        "iteration_file_path"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "IterationStore::load",
        "IterationStore::save",
        "IterationStore::exists",
        "IterationStore::delete",
        "IterationStore::load_all",
        "IterationStore::load_summaries",
        "IterationStore::workspace_path",
        "IterationStore::ensure_workspace",
        "IterationStore::iteration_path"
      ],
      "name": "iteration_store.rs",
      "source_summary": "use std::path::PathBuf;\r\n\r\nuse crate::domain::{Iteration, IterationSummary};\r\n\r\nuse super::get_cowork_dir;\r\n\r\n/// Iteration store for persistence\r\npub struct IterationStore;\r\n\r\nimpl IterationStore {\r\n    pub fn new() -> Self {\r\n        Self\r\n    }\r\n\r\n    /// Load iteration by ID\r\n    pub fn load(&self, iteration_id: &str) -> anyhow::Result<Iteration> {\r\n        let path = self.iteration_file_path(iteration_id)?;\r\n        let content = std::fs::read_to_string(&path)?;\r\n        let iteration: Iteration = serde_json::from_str(&content)?;\r\n        Ok(iteration)\r\n    }\r\n\r\n    /// Save iteration to disk\r\n    pub fn save(&self, iteration: &Iteration) -> anyhow::Result<()> {\r\n        let path = self.iteration_file_path(&iteration.id)?;\r\n        let content = serde_json::to_string_pretty(iteration)?;\r\n        std::fs::write(&path, content)?;\r\n        Ok(())\r\n    }\r\n\r\n    /// Check if iteration exists\r\n    pub fn exists(&self, iteration_id: &str) -> bool {\r\n        self.iteration_file_path(iteration_id)\r\n            .map(|p| p.exists())\r\n            .unwrap_or(false)\r\n    }\r\n\r\n    /// Delete iteration\r\n    pub fn delete(&self, iteration_id: &str) -> anyhow::Result<()> {\r\n        let path = self.iteration_file_path(iteration_id)?;\r\n        if path.exists() {\r\n            std::fs::remove_file(&path)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Load all iterations\r\n    pub fn load_all(&self) -> anyhow::Result<Vec<Iteration>> {\r\n        let dir = get_cowork_dir()?.join(\"iterations\");\r\n        if !dir.exists() {\r\n            return Ok(Vec::new());\r\n        }\r\n\r\n        let mut iterations = Vec::new();\r\n        for entry in std::fs::read_dir(&dir)? {\r\n            let entry = entry?;\r\n            if entry.path().extension().map(|e| e == \"json\").unwrap_or(false) {\r\n                if let Ok(content) = std::fs::read_to_string(entry.path()) {\r\n                    if let Ok(iteration) = serde_json::from_str::<Iteration>(&content) {\r\n                        iterations.push(iteration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort by iteration number\r\n        iterations.sort_by_key(|i| i.number);\r\n        Ok(iterations)\r\n    }\r\n\r\n    /// Load iterations as summaries\r\n    pub fn load_summaries(&self) -> anyhow::Result<Vec<IterationSummary>> {\r\n        let iterations = self.load_all()?;\r\n        Ok(iterations.into_iter().map(|i| i.to_summary()).collect())\r\n    }\r\n\r\n    /// Get workspace path for iteration\r\n    pub fn workspace_path(&self, _iteration_id: &str) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(\"workspace\"))\r\n    }\r\n\r\n    /// Ensure workspace exists\r\n    pub fn ensure_workspace(&self, _iteration_id: &str) -> anyhow::Result<PathBuf> {\r\n        let workspace = get_cowork_dir()?.join(\"workspace\");\r\n        std::fs::create_dir_all(&workspace)?;\r\n        Ok(workspace)\r\n    }\r\n\r\n    /// Get iteration directory path (contains artifacts subdirectory)\r\n    pub fn iteration_path(&self, iteration_id: &str) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(\"iterations\").join(iteration_id))\r\n    }\r\n\r\n    fn iteration_file_path(&self, iteration_id: &str) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(\"iterations\").join(format!(\"{}.json\", iteration_id)))\r\n    }\r\n}\r\n\r\nimpl Default for IterationStore {\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 11.0,
      "lines_of_code": 103,
      "number_of_classes": 1,
      "number_of_functions": 11
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": false,
        "line_number": 1,
        "name": "std::path::PathBuf",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "crate::domain::Iteration",
        "path": "crates/cowork-core/src/domain",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "crate::domain::IterationSummary",
        "path": "crates/cowork-core/src/domain",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The IterationStore is a data access layer component that implements file-based persistence for iteration entities in a cowork system. It utilizes JSON serialization to store and retrieve iteration data, managing a hierarchical directory structure under a centralized cowork directory. The component provides comprehensive CRUD (Create, Read, Update, Delete) operations for individual iterations, batch loading capabilities for retrieving all iterations with sorting by iteration number, and workspace management functions for handling working directories. The store also offers summary loading functionality for efficient data retrieval when full iteration details are not required. All file system operations are wrapped in anyhow error handling for robust error propagation.",
    "interfaces": [
      {
        "description": "Creates a new IterationStore instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Loads a single iteration by ID from JSON file storage",
        "interface_type": "method",
        "name": "load",
        "parameters": [
          {
            "description": "The unique identifier of the iteration to load",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<Iteration>",
        "visibility": "public"
      },
      {
        "description": "Saves an iteration to disk as a formatted JSON file",
        "interface_type": "method",
        "name": "save",
        "parameters": [
          {
            "description": "The iteration object to persist",
            "is_optional": false,
            "name": "iteration",
            "param_type": "&Iteration"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Checks if an iteration file exists for the given ID",
        "interface_type": "method",
        "name": "exists",
        "parameters": [
          {
            "description": "The unique identifier to check for existence",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Deletes the iteration file from disk if it exists",
        "interface_type": "method",
        "name": "delete",
        "parameters": [
          {
            "description": "The unique identifier of the iteration to delete",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Loads all iterations from the iterations directory, parses JSON files, and sorts by iteration number",
        "interface_type": "method",
        "name": "load_all",
        "parameters": [],
        "return_type": "anyhow::Result<Vec<Iteration>>",
        "visibility": "public"
      },
      {
        "description": "Loads all iterations and converts them to summary representations",
        "interface_type": "method",
        "name": "load_summaries",
        "parameters": [],
        "return_type": "anyhow::Result<Vec<IterationSummary>>",
        "visibility": "public"
      },
      {
        "description": "Returns the workspace directory path",
        "interface_type": "method",
        "name": "workspace_path",
        "parameters": [
          {
            "description": "Iteration identifier (currently unused in implementation)",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Creates the workspace directory if it doesn't exist and returns the path",
        "interface_type": "method",
        "name": "ensure_workspace",
        "parameters": [
          {
            "description": "Iteration identifier (currently unused in implementation)",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Returns the directory path for iteration artifacts storage",
        "interface_type": "method",
        "name": "iteration_path",
        "parameters": [
          {
            "description": "The unique identifier of the iteration",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Iteration data persistence and CRUD operations using JSON file storage",
      "File system management including directory creation, file existence checks, and file operations",
      "Workspace directory management ensuring proper working environment for iteration artifacts",
      "Data serialization and deserialization between domain models and JSON format",
      "Batch data processing for loading all iterations with ordering and summary conversion"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "dao",
      "description": "A file-based memory store that provides persistence for project and iteration memory data with flexible querying capabilities",
      "file_path": "crates\\cowork-core\\src\\persistence\\memory_store.rs",
      "functions": [
        "new",
        "load_project_memory",
        "save_project_memory",
        "add_decision",
        "add_pattern",
        "load_iteration_memory",
        "save_iteration_memory",
        "ensure_iteration_memory",
        "query",
        "apply_query_to_project",
        "apply_query_to_iteration",
        "project_memory_path",
        "iteration_memory_path"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "load_project_memory",
        "save_project_memory",
        "add_decision",
        "add_pattern",
        "load_iteration_memory",
        "save_iteration_memory",
        "ensure_iteration_memory",
        "query"
      ],
      "name": "memory_store.rs",
      "source_summary": "use std::path::PathBuf;\r\n\r\nuse crate::domain::{IterationMemory, MemoryQuery, MemoryQueryResult, ProjectMemory};\r\n\r\nuse super::get_cowork_dir;\r\n\r\n/// Memory store for persistence\r\npub struct MemoryStore;\r\n\r\nimpl MemoryStore {\r\n    pub fn new() -> Self {\r\n        Self\r\n    }\r\n\r\n    // Project Memory\r\n\r\n    /// Load project memory\r\n    pub fn load_project_memory(&self) -> anyhow::Result<ProjectMemory> {\r\n        let path = self.project_memory_path()?;\r\n        if !path.exists() {\r\n            return Ok(ProjectMemory::new());\r\n        }\r\n        let content = std::fs::read_to_string(&path)?;\r\n        let memory: ProjectMemory = serde_json::from_str(&content)?;\r\n        Ok(memory)\r\n    }\r\n\r\n    /// Save project memory\r\n    pub fn save_project_memory(&self, memory: &ProjectMemory) -> anyhow::Result<()> {\r\n        let path = self.project_memory_path()?;\r\n        let content = serde_json::to_string_pretty(memory)?;\r\n        std::fs::write(&path, content)?;\r\n        Ok(())\r\n    }\r\n\r\n    /// Add decision to project memory\r\n    pub fn add_decision(&self, decision: crate::domain::Decision) -> anyhow::Result<()> {\r\n        let mut memory = self.load_project_memory()?;\r\n        memory.add_decision(decision);\r\n        self.save_project_memory(&memory)\r\n    }\r\n\r\n    /// Add pattern to project memory\r\n    pub fn add_pattern(&self, pattern: crate::domain::Pattern) -> anyhow::Result<()> {\r\n        let mut memory = self.load_project_memory()?;\r\n        memory.add_pattern(pattern);\r\n        self.save_project_memory(&memory)\r\n    }\r\n\r\n    // Iteration Memory\r\n\r\n    /// Load iteration memory\r\n    pub fn load_iteration_memory(&self, iteration_id: &str) -> anyhow::Result<IterationMemory> {\r\n        let path = self.iteration_memory_path(iteration_id)?;\r\n        if !path.exists() {\r\n            return Ok(IterationMemory::new(iteration_id));\r\n        }\r\n        let content = std::fs::read_to_string(&path)?;\r\n        let memory: IterationMemory = serde_json::from_str(&content)?;\r\n        Ok(memory)\r\n    }\r\n\r\n    /// Save iteration memory\r\n    pub fn save_iteration_memory(&self, memory: &IterationMemory) -> anyhow::Result<()> {\r\n        let path = self.iteration_memory_path(&memory.iteration_id)?;\r\n        let content = serde_json::to_string_pretty(memory)?;\r\n        std::fs::write(&path, content)?;\r\n        Ok(())\r\n    }\r\n\r\n    /// Ensure iteration memory exists\r\n    pub fn ensure_iteration_memory(&self, iteration_id: &str) -> anyhow::Result<IterationMemory> {\r\n        let memory = self.load_iteration_memory(iteration_id)?;\r\n        self.save_iteration_memory(&memory)?;\r\n        Ok(memory)\r\n    }\r\n\r\n    // Query\r\n\r\n    /// Query memory based on scope and type\r\n    pub fn query(&self, query: &MemoryQuery, current_iteration_id: Option<&str>) -> anyhow::Result<MemoryQueryResult> {\r\n        let mut result = MemoryQueryResult {\r\n            decisions: Vec::new(),\r\n            patterns: Vec::new(),\r\n            insights: Vec::new(),\r\n        };\r\n\r\n        match query.scope {\r\n            crate::domain::MemoryScope::Project => {\r\n                let project_memory = self.load_project_memory()?;\r\n                self.apply_query_to_project(&project_memory, query, &mut result);\r\n            }\r\n            crate::domain::MemoryScope::Iteration => {\r\n                if let Some(iter_id) = current_iteration_id {\r\n                    let iter_memory = self.load_iteration_memory(iter_id)?;\r\n                    self.apply_query_to_iteration(&iter_memory, query, &mut result);\r\n                }\r\n            }\r\n            crate::domain::MemoryScope::Smart => {\r\n                // Load both and merge\r\n                let project_memory = self.load_project_memory()?;\r\n                self.apply_query_to_project(&project_memory, query, &mut result);\r\n\r\n                if let Some(iter_id) = current_iteration_id {\r\n                    let iter_memory = self.load_iteration_memory(iter_id)?;\r\n                    self.apply_query_to_iteration(&iter_memory, query, &mut result);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply limit\r\n        if let Some(limit) = query.limit {\r\n            result.decisions.truncate(limit);\r\n            result.patterns.truncate(limit);\r\n            result.insights.truncate(limit);\r\n        }\r\n\r\n        Ok(result)\r\n    }\r\n\r\n    fn apply_query_to_project(&self, memory: &ProjectMemory, query: &MemoryQuery, result: &mut MemoryQueryResult) {\r\n        use crate::domain::MemoryQueryType;\r\n\r\n        match query.query_type {\r\n            MemoryQueryType::Decisions | MemoryQueryType::All => {\r\n                if query.keywords.is_empty() {\r\n                    result.decisions.extend(memory.decisions.clone());\r\n                } else {\r\n                    for keyword in &query.keywords {\r\n                        result.decisions.extend(\r\n                            memory.query_decisions(keyword).into_iter().cloned()\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n\r\n        match query.query_type {\r\n            MemoryQueryType::Patterns | MemoryQueryType::All => {\r\n                if query.keywords.is_empty() {\r\n                    result.patterns.extend(memory.patterns.clone());\r\n                } else {\r\n                    for keyword in &query.keywords {\r\n                        result.patterns.extend(\r\n                            memory.query_patterns(keyword).into_iter().cloned()\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n\r\n    fn apply_query_to_iteration(&self, memory: &IterationMemory, query: &MemoryQuery, result: &mut MemoryQueryResult) {\r\n        use crate::domain::MemoryQueryType;\r\n\r\n        match query.query_type {\r\n            MemoryQueryType::Insights | MemoryQueryType::All => {\r\n                result.insights.extend(memory.insights.clone());\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n\r\n    fn project_memory_path(&self) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(\"memory/project/memory.json\"))\r\n    }\r\n\r\n    fn iteration_memory_path(&self, iteration_id: &str) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(\"memory/iterations\").join(format!(\"{}.json\", iteration_id)))\r\n    }\r\n}\r\n\r\nimpl Default for MemoryStore {\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 16.0,
      "lines_of_code": 179,
      "number_of_classes": 1,
      "number_of_functions": 14
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 1,
        "name": "std::path::PathBuf",
        "path": "std::path",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "std::fs",
        "path": "std::fs",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 3,
        "name": "crate::domain",
        "path": "crate::domain",
        "version": null
      }
    ],
    "detailed_description": "MemoryStore is a Data Access Object (DAO) implementation that provides file-based persistence for AI-assisted development memory data. The component manages two types of memory storage: Project Memory (for decisions and patterns shared across the entire project) and Iteration Memory (for insights specific to individual work iterations). It uses JSON serialization for data persistence and supports complex querying with three scope modes (Project, Iteration, Smart) and four query types (Decisions, Patterns, Insights, All). The component abstracts file system operations through a clean API, handling path management, file existence checks, serialization/deserialization, and error propagation. It implements the Default trait for convenient instantiation and follows the builder pattern for memory modification operations.",
    "interfaces": [
      {
        "description": "Constructor that creates a new MemoryStore instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Loads project memory from disk. Returns empty ProjectMemory if file doesn't exist.",
        "interface_type": "method",
        "name": "load_project_memory",
        "parameters": [],
        "return_type": "anyhow::Result<ProjectMemory>",
        "visibility": "public"
      },
      {
        "description": "Serializes and saves project memory to disk as JSON",
        "interface_type": "method",
        "name": "save_project_memory",
        "parameters": [
          {
            "description": "Reference to the ProjectMemory to persist",
            "is_optional": false,
            "name": "memory",
            "param_type": "&ProjectMemory"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Adds a decision to project memory by loading, modifying, and saving",
        "interface_type": "method",
        "name": "add_decision",
        "parameters": [
          {
            "description": "Decision to add to project memory",
            "is_optional": false,
            "name": "decision",
            "param_type": "Decision"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Adds a pattern to project memory by loading, modifying, and saving",
        "interface_type": "method",
        "name": "add_pattern",
        "parameters": [
          {
            "description": "Pattern to add to project memory",
            "is_optional": false,
            "name": "pattern",
            "param_type": "Pattern"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Loads iteration memory from disk. Returns empty IterationMemory if file doesn't exist.",
        "interface_type": "method",
        "name": "load_iteration_memory",
        "parameters": [
          {
            "description": "Identifier of the iteration to load memory for",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<IterationMemory>",
        "visibility": "public"
      },
      {
        "description": "Serializes and saves iteration memory to disk as JSON",
        "interface_type": "method",
        "name": "save_iteration_memory",
        "parameters": [
          {
            "description": "Reference to the IterationMemory to persist",
            "is_optional": false,
            "name": "memory",
            "param_type": "&IterationMemory"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Ensures iteration memory exists by loading and saving, creating file if needed",
        "interface_type": "method",
        "name": "ensure_iteration_memory",
        "parameters": [
          {
            "description": "Identifier of the iteration to ensure memory exists for",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<IterationMemory>",
        "visibility": "public"
      },
      {
        "description": "Queries memory based on scope (Project/Iteration/Smart) and type, with optional keyword filtering and result limiting",
        "interface_type": "method",
        "name": "query",
        "parameters": [
          {
            "description": "Query parameters including scope, type, keywords, and limit",
            "is_optional": false,
            "name": "query",
            "param_type": "&MemoryQuery"
          },
          {
            "description": "Current iteration ID for iteration-scoped queries",
            "is_optional": true,
            "name": "current_iteration_id",
            "param_type": "Option<&str>"
          }
        ],
        "return_type": "anyhow::Result<MemoryQueryResult>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manage project memory persistence - load, save, and modify project-level decisions and patterns stored as JSON files",
      "Manage iteration memory persistence - load, save, and ensure iteration-specific insights are properly persisted",
      "Provide flexible memory querying with multiple scopes (Project, Iteration, Smart) and types (Decisions, Patterns, Insights, All)",
      "Handle file system operations including path resolution, file existence checking, and JSON serialization/deserialization",
      "Maintain memory storage directory structure with separate locations for project and iteration memory files"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "dao",
      "description": "ProjectStore is a Data Access Layer (DAO) component responsible for managing the persistence of Project data using JSON file-based storage. It provides CRUD operations, project lifecycle management, and iteration tracking capabilities.",
      "file_path": "crates\\cowork-core\\src\\persistence\\project_store.rs",
      "functions": [
        "new",
        "load",
        "save",
        "exists",
        "create",
        "update",
        "add_iteration",
        "set_current_iteration",
        "project_file_path"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "new() -> Self",
        "load(&self) -> anyhow::Result<Option<Project>>",
        "save(&self, project: &Project) -> anyhow::Result<()>",
        "exists(&self) -> bool",
        "create(&self, name: impl Into<String>) -> anyhow::Result<Project>",
        "update(&self, project: &Project) -> anyhow::Result<()>",
        "add_iteration(&self, project: &mut Project, summary: IterationSummary) -> anyhow::Result<()>",
        "set_current_iteration(&self, project: &mut Project, iteration_id: String) -> anyhow::Result<()>"
      ],
      "name": "project_store.rs",
      "source_summary": "use std::path::PathBuf;\r\n\r\nuse crate::domain::{IterationSummary, Project};\r\n\r\nuse super::get_cowork_dir;\r\n\r\nconst PROJECT_FILE: &str = \"project.json\";\r\n#[allow(dead_code)]\r\nconst ITERATIONS_FILE: &str = \"iterations.json\";\r\n\r\n/// Project store for persistence\r\npub struct ProjectStore;\r\n\r\nimpl ProjectStore {\r\n    pub fn new() -> Self {\r\n        Self\r\n    }\r\n\r\n    /// Load project from disk\r\n    pub fn load(&self) -> anyhow::Result<Option<Project>> {\r\n        let path = self.project_file_path()?;\r\n        if !path.exists() {\r\n            return Ok(None);\r\n        }\r\n\r\n        let content = std::fs::read_to_string(&path)?;\r\n        let project: Project = serde_json::from_str(&content)?;\r\n        Ok(Some(project))\r\n    }\r\n\r\n    /// Save project to disk\r\n    pub fn save(&self, project: &Project) -> anyhow::Result<()> {\r\n        let path = self.project_file_path()?;\r\n        let content = serde_json::to_string_pretty(project)?;\r\n        std::fs::write(&path, content)?;\r\n        Ok(())\r\n    }\r\n\r\n    /// Check if project exists\r\n    pub fn exists(&self) -> bool {\r\n        self.project_file_path()\r\n            .map(|p| p.exists())\r\n            .unwrap_or(false)\r\n    }\r\n\r\n    /// Create new project\r\n    pub fn create(&self, name: impl Into<String>) -> anyhow::Result<Project> {\r\n        let project = Project::new(name);\r\n        super::init_project_structure(&project.name)?;\r\n        self.save(&project)?;\r\n        Ok(project)\r\n    }\r\n\r\n    /// Update project\r\n    pub fn update(&self, project: &Project) -> anyhow::Result<()> {\r\n        self.save(project)\r\n    }\r\n\r\n    /// Add iteration summary to project\r\n    pub fn add_iteration(&self, project: &mut Project, summary: IterationSummary) -> anyhow::Result<()> {\r\n        project.add_iteration(summary);\r\n        self.save(project)\r\n    }\r\n\r\n    /// Set current iteration\r\n    pub fn set_current_iteration(&self, project: &mut Project, iteration_id: String) -> anyhow::Result<()> {\r\n        project.set_current_iteration(iteration_id);\r\n        self.save(project)\r\n    }\r\n\r\n    fn project_file_path(&self) -> anyhow::Result<PathBuf> {\r\n        Ok(get_cowork_dir()?.join(PROJECT_FILE))\r\n    }\r\n}\r\n\r\nimpl Default for ProjectStore {\r\n    fn default() -> Self {\r\n        Self::new()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 5.0,
      "lines_of_code": 80,
      "number_of_classes": 1,
      "number_of_functions": 9
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": true,
        "line_number": null,
        "name": "std::path::PathBuf",
        "path": "std",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 3,
        "name": "crate::domain::IterationSummary",
        "path": "crate::domain",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 3,
        "name": "crate::domain::Project",
        "path": "crate::domain",
        "version": null
      },
      {
        "dependency_type": "function",
        "is_external": false,
        "line_number": 4,
        "name": "super::get_cowork_dir",
        "path": "super",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": "serde_json",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": "anyhow",
        "version": null
      }
    ],
    "detailed_description": "## Detailed Functional Description and Business Logic\n\nProjectStore is a lightweight persistence layer component that implements the Repository pattern for Project entities. It manages project data stored as JSON files in a designated cowork directory structure.\n\n**Core Functionalities:**\n\n1. **Project Persistence Operations:**\n   - `load()`: Reads project data from `project.json` file, returns `None` if file doesn't exist\n   - `save()`: Serializes project to JSON with pretty formatting and writes to disk\n   - `exists()`: Checks if project file exists without loading contents\n\n2. **Project Lifecycle Management:**\n   - `create()`: Creates a new Project instance, initializes the project directory structure via `init_project_structure()`, and persists it\n   - `update()`: Updates existing project (currently wraps save operation)\n   - Uses `Default` trait implementation for convenience\n\n3. **Iteration Management:**\n   - `add_iteration()`: Adds iteration summary to project's internal collection and persists changes\n   - `set_current_iteration()`: Updates the current iteration reference and saves\n\n4. **File Path Resolution:**\n   - Private `project_file_path()` method resolves the full path to `project.json` using the cowork directory\n   - Encapsulates path construction logic, isolating file system details\n\n**Design Pattern:** The component follows a simplified Repository pattern with stateless implementation (all methods take `&self`), making it essentially a collection of related persistence operations rather than maintaining internal state.",
    "interfaces": [
      {
        "description": "Factory method to create a new ProjectStore instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Load project from disk, returns None if project file doesn't exist",
        "interface_type": "method",
        "name": "load",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          }
        ],
        "return_type": "anyhow::Result<Option<Project>>",
        "visibility": "public"
      },
      {
        "description": "Save project to disk as JSON with pretty formatting",
        "interface_type": "method",
        "name": "save",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project",
            "param_type": "&Project"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Check if project file exists without loading contents",
        "interface_type": "method",
        "name": "exists",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          }
        ],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Create new project with directory structure initialization and persistence",
        "interface_type": "method",
        "name": "create",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "impl Into<String>"
          }
        ],
        "return_type": "anyhow::Result<Project>",
        "visibility": "public"
      },
      {
        "description": "Update existing project (currently delegates to save method)",
        "interface_type": "method",
        "name": "update",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project",
            "param_type": "&Project"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Add iteration summary to project and persist changes",
        "interface_type": "method",
        "name": "add_iteration",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project",
            "param_type": "&mut Project"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "summary",
            "param_type": "IterationSummary"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Set the current iteration ID for project and persist changes",
        "interface_type": "method",
        "name": "set_current_iteration",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project",
            "param_type": "&mut Project"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          }
        ],
        "return_type": "anyhow::Result<()>",
        "visibility": "public"
      },
      {
        "description": "Private helper to resolve full project.json file path",
        "interface_type": "method",
        "name": "project_file_path",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&Self"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Manage project data persistence using JSON file-based storage, including reading, writing, and file existence validation",
      "Handle complete project lifecycle operations including creation, loading, and updating of Project entities",
      "Provide iteration management capabilities by adding iteration summaries and tracking current iteration state",
      "Resolve and manage file system paths for project storage within the cowork directory structure",
      "Abstract filesystem operations and JSON serialization/deserialization details from higher-level business logic"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "controller",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\executor.rs",
      "functions": [
        "IterationExecutor::new",
        "IterationExecutor::create_genesis_iteration",
        "IterationExecutor::create_evolution_iteration",
        "IterationExecutor::prepare_workspace",
        "IterationExecutor::inherit_from_base",
        "IterationExecutor::copy_non_code_files",
        "IterationExecutor::execute",
        "IterationExecutor::continue_iteration",
        "IterationExecutor::copy_dir_all",
        "InteractionExt::request_confirmation",
        "InteractionExt::request_confirmation_with_artifact",
        "InteractionExt::request_confirmation_with_feedback"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "InteractionExt",
        "InteractiveBackend"
      ],
      "name": "executor.rs",
      "source_summary": "// Iteration Executor - Single entry point for all development cycles\n\nuse std::sync::Arc;\n\nuse crate::domain::{Iteration, IterationStatus, Project};\nuse crate::interaction::InteractiveBackend;\nuse crate::persistence::{IterationStore, ProjectStore};\n\nuse super::{get_stages_from, is_critical_stage, PipelineContext, StageResult};\n\n/// Iteration Executor - Manages the complete iteration lifecycle\npub struct IterationExecutor {\n    project_store: ProjectStore,\n    iteration_store: IterationStore,\n    interaction: Arc<dyn InteractiveBackend>,\n}\n\nimpl IterationExecutor {\n    pub fn new(interaction: Arc<dyn InteractiveBackend>) -> Self {\n        Self {\n            project_store: ProjectStore::new(),\n            iteration_store: IterationStore::new(),\n            interaction,\n        }\n    }\n\n    /// Create a new Genesis iteration (first iteration)\n    pub fn create_genesis_iteration(\n        &self,\n        project: &mut Project,\n        title: impl Into<String>,\n        description: impl Into<String>,\n    ) -> anyhow::Result<Iteration> {\n        let iteration = Iteration::create_genesis(project, title.into(), description.into());\n\n        // Save iteration\n        self.iteration_store.save(&iteration)?;\n\n        // Update project\n        self.project_store.add_iteration(project, iteration.to_summary())?;\n\n        Ok(iteration)\n    }\n\n    /// Create a new Evolution iteration (based on previous iteration)\n    pub fn create_evolution_iteration(\n        &self,\n        project: &mut Project,\n        title: impl Into<String>,\n        description: impl Into<String>,\n        base_iteration_id: impl Into<String>,\n    ) -> anyhow::Result<Iteration> {\n        let iteration = Iteration::create_evolution(\n            project,\n            title.into(),\n            description.into(),\n            base_iteration_id.into(),\n            crate::domain::InheritanceMode::Full,\n        );\n\n        // Save iteration\n        self.iteration_store.save(&iteration)?;\n\n        // Update project\n        self.project_store.add_iteration(project, iteration.to_summary())?;\n\n        Ok(iteration)\n    }\n\n    /// Prepare workspace for iteration execution\n    async fn prepare_workspace(&self, iteration: &Iteration) -> anyhow::Result<std::path::PathBuf> {\n        let workspace = self.iteration_store.ensure_workspace(&iteration.id)?;\n\n        // If evolution, copy base iteration workspace\n        if let Some(base_id) = &iteration.base_iteration_id {\n            self.inherit_from_base(&workspace, base_id).await?;\n        }\n\n        Ok(workspace)\n    }\n\n    /// Inherit workspace from base iteration\n    async fn inherit_from_base(\n        &self,\n        workspace: &std::path::PathBuf,\n        base_iteration_id: &str,\n    ) -> anyhow::Result<()> {\n        use crate::domain::InheritanceMode;\n\n        // Load base iteration\n        let base = self.iteration_store.load(base_iteration_id)?;\n\n        match base.inheritance {\n            InheritanceMode::None => {\n                // No inheritance - start fresh\n                println!(\"[Executor] No inheritance (Genesis iteration)\");\n                Ok(())\n            }\n            InheritanceMode::Full => {\n                // Copy all workspace files from base iteration\n                println!(\"[Executor] Full inheritance - copying all files from base iteration: {}\", base_iteration_id);\n                let base_workspace = self.iteration_store.workspace_path(base_iteration_id)?;\n                if base_workspace.exists() {\n                    self.copy_dir_all(&base_workspace, workspace).await?;\n                    println!(\"[Executor] Copied workspace from {}\", base_workspace.display());\n                } else {\n                    println!(\"[Executor] Warning: Base workspace does not exist: {}\", base_workspace.display());\n                }\n                Ok(())\n            }\n            InheritanceMode::Partial => {\n                // Copy only specific artifacts and configuration files\n                // Don't copy generated code - will regenerate based on artifacts\n                println!(\"[Executor] Partial inheritance - copying artifacts only from base: {}\", base_iteration_id);\n\n                let base_workspace = self.iteration_store.workspace_path(base_iteration_id)?;\n\n                // Copy configuration files and non-code assets\n                if base_workspace.exists() {\n                    self.copy_non_code_files(&base_workspace, workspace).await?;\n                    println!(\"[Executor] Copied non-code files from base workspace\");\n                }\n\n                // Copy artifacts from base iteration's artifact directory\n                let base_iteration_dir = self.iteration_store.iteration_path(base_iteration_id)?;\n                let base_artifacts_dir = base_iteration_dir.join(\"artifacts\");\n                let current_artifacts_dir = workspace.parent()\n                    .map(|p| p.join(\"artifacts\"))\n                    .unwrap_or_else(|| workspace.join(\"artifacts\"));\n\n                if base_artifacts_dir.exists() {\n                    std::fs::create_dir_all(&current_artifacts_dir)?;\n                    self.copy_dir_all(&base_artifacts_dir, &current_artifacts_dir).await?;\n                    println!(\"[Executor] Copied artifacts from base iteration\");\n                }\n\n                Ok(())\n            }\n        }\n    }\n\n    /// Copy only non-code files (config, assets, docs)\n    async fn copy_non_code_files(\n        &self,\n        src: &std::path::Path,\n        dst: &std::path::Path,\n    ) -> anyhow::Result<()> {\n        let code_extensions = [\n            \"rs\", \"js\", \"jsx\", \"ts\", \"tsx\", \"py\", \"java\", \"go\", \"cpp\", \"c\", \"h\", \"hpp\",\n            \"cs\", \"php\", \"rb\", \"swift\", \"kt\", \"scala\", \"r\", \"m\", \"mm\",\n        ];\n\n        if !dst.exists() {\n            tokio::fs::create_dir_all(dst).await?;\n        }\n\n        let mut entries = tokio::fs::read_dir(src).await?;\n        while let Some(entry) = entries.next_entry().await? {\n            let path = entry.path();\n            let file_name = path.file_name().unwrap();\n            let dest_path = dst.join(file_name);\n\n            if path.is_dir() {\n                // Skip node_modules, target, .git, etc.\n                let dir_name = file_name.to_string_lossy();\n                if matches!(dir_name.as_ref(), \"node_modules\" | \"target\" | \".git\" | \"dist\" | \"build\" | \".cowork\" | \".cowork-v2\") {\n                    continue;\n                }\n                Box::pin(self.copy_non_code_files(&path, &dest_path)).await?;\n            } else {\n                // Check if it's a code file\n                let ext = path.extension()\n                    .and_then(|e| e.to_str())\n                    .unwrap_or(\"\");\n\n                if !code_extensions.contains(&ext) {\n                    // Copy non-code files (config, readme, assets, etc.)\n                    tokio::fs::copy(&path, &dest_path).await?;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Execute an iteration\n    pub async fn execute(&self, project: &mut Project, iteration_id: &str) -> anyhow::Result<()> {\n        // Load iteration\n        let mut iteration = self.iteration_store.load(iteration_id)?;\n\n        // Prepare workspace\n        let workspace = self.prepare_workspace(&iteration).await?;\n\n        // Create pipeline context\n        let ctx = PipelineContext::new(project.clone(), iteration.clone(), workspace);\n\n        // Determine starting stage\n        // If iteration has a current_stage (e.g., when resuming), use it\n        // Otherwise determine based on inheritance mode\n        let start_stage = if let Some(ref current) = iteration.current_stage {\n            if iteration.status == crate::domain::IterationStatus::Paused {\n                // Resume from current stage\n                current.clone()\n            } else {\n                iteration.determine_start_stage()\n            }\n        } else {\n            iteration.determine_start_stage()\n        };\n\n        // Get stages to execute\n        let stages = get_stages_from(&start_stage);\n\n        // Start iteration\n        iteration.start();\n        self.iteration_store.save(&iteration)?;\n        self.project_store.set_current_iteration(project, iteration_id.to_string())?;\n\n        // Emit event\n        self.interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                format!(\"Starting iteration '{}' from stage '{}'\", iteration.title, start_stage),\n            )\n            .await;\n\n        // Execute stages with retry logic\n        const MAX_STAGE_RETRIES: u32 = 3;\n        const RETRY_DELAY_MS: u64 = 2000;\n        let total_stages = stages.len();\n\n        for (stage_idx, stage) in stages.into_iter().enumerate() {\n            let stage_name = stage.name().to_string();\n            let stage_num = stage_idx + 1;\n\n            // Update current stage\n            iteration.set_stage(&stage_name);\n            self.iteration_store.save(&iteration)?;\n\n            // Emit stage started event with progress info\n            self.interaction\n                .show_message(\n                    crate::interaction::MessageLevel::Info,\n                    format!(\"🚀 [{}/{}] Starting stage: {}\", stage_num, total_stages, stage.description()),\n                )\n                .await;\n\n                        // Execute stage with retry\n            let mut last_error = None;\n            let mut success = false;\n\n            for attempt in 0..MAX_STAGE_RETRIES {\n                // Emit retry message if needed\n                if attempt > 0 {\n                    self.interaction\n                        .show_message(\n                            crate::interaction::MessageLevel::Warning,\n                            format!(\"🔄 Stage '{}' retry {}/{}...\", stage_name, attempt, MAX_STAGE_RETRIES - 1),\n                        )\n                        .await;\n                    // Wait before retry\n                    tokio::time::sleep(tokio::time::Duration::from_millis(RETRY_DELAY_MS)).await;\n                }\n\n                // Execute stage (with feedback loop for revisions)\n                let mut feedback_loop_count = 0;\n                const MAX_FEEDBACK_LOOPS: u32 = 5;\n                let mut current_feedback: Option<String> = None;\n                \n                loop {\n                    // Execute or re-execute stage\n                    let result = if let Some(ref feedback) = current_feedback {\n                        stage.execute_with_feedback(&ctx, self.interaction.clone(), feedback).await\n                    } else {\n                        stage.execute(&ctx, self.interaction.clone()).await\n                    };\n\n                    match result {\n                        StageResult::Success(artifact_path) => {\n                            // Complete stage\n                            iteration.complete_stage(&stage_name, artifact_path.clone());\n                            self.iteration_store.save(&iteration)?;\n\n                            // Show success message with progress info\n                            let progress_msg = if feedback_loop_count > 0 {\n                                format!(\"✅ [{}/{}] Stage '{}' completed (revision {})\",\n                                    stage_num, total_stages, stage_name, feedback_loop_count)\n                            } else if attempt > 0 {\n                                format!(\"✅ [{}/{}] Stage '{}' completed (after {} retries)\",\n                                    stage_num, total_stages, stage_name, attempt)\n                            } else {\n                                format!(\"✅ [{}/{}] Stage '{}' completed\",\n                                    stage_num, total_stages, stage_name)\n                            };\n\n                            self.interaction\n                                .show_message(\n                                    crate::interaction::MessageLevel::Success,\n                                    progress_msg,\n                                )\n                                .await;\n\n                            // Check if needs human confirmation and feedback loop\n                            if is_critical_stage(&stage_name) {\n                                iteration.pause();\n                                self.iteration_store.save(&iteration)?;\n\n                                // Determine artifact type for viewing\n                                let artifact_type = match stage_name.as_str() {\n                                    \"idea\" => \"idea\",\n                                    \"prd\" => \"requirements\",\n                                    \"design\" => \"design\",\n                                    \"plan\" => \"plan\",\n                                    \"coding\" => \"code\",\n                                    _ => \"artifacts\",\n                                };\n\n                                // Request confirmation with feedback support\n                                let action = self\n                                    .interaction\n                                    .request_confirmation_with_feedback(&format!(\n                                        \"Stage '{}' completed. Please review the generated {} document.{}\",\n                                        stage_name,\n                                        stage_name.to_uppercase(),\n                                        if feedback_loop_count > 0 { \n                                            format!(\" (Revision {})\", feedback_loop_count) \n                                        } else { \n                                            String::new() \n                                        }\n                                    ), artifact_type)\n                                    .await;\n\n                                match action {\n                                    ConfirmationAction::Continue => {\n                                        iteration.resume();\n                                        self.iteration_store.save(&iteration)?;\n                                        success = true;\n                                        break; // Exit feedback loop\n                                    }\n                                    ConfirmationAction::ViewArtifact => {\n                                        // User wants to view artifact, stay in loop\n                                        current_feedback = None;\n                                        continue;\n                                    }\n                                    ConfirmationAction::ProvideFeedback(feedback) => {\n                                        if feedback_loop_count >= MAX_FEEDBACK_LOOPS {\n                                            self.interaction\n                                                .show_message(\n                                                    crate::interaction::MessageLevel::Warning,\n                                                    format!(\"Maximum revision attempts ({}) reached. Proceeding...\", MAX_FEEDBACK_LOOPS),\n                                                )\n                                                .await;\n                                            iteration.resume();\n                                            self.iteration_store.save(&iteration)?;\n                                            success = true;\n                                            break;\n                                        }\n                                        \n                                        feedback_loop_count += 1;\n                                        current_feedback = Some(feedback);\n                                        self.interaction\n                                            .show_message(\n                                                crate::interaction::MessageLevel::Info,\n                                                format!(\"Regenerating {} based on your feedback (revision {} of {})...\", \n                                                    stage_name, feedback_loop_count, MAX_FEEDBACK_LOOPS),\n                                            )\n                                            .await;\n                                        continue; // Re-execute with feedback\n                                    }\n                                    ConfirmationAction::Cancel => {\n                                        return Ok(()); // User cancelled\n                                    }\n                                }\n                            } else {\n                                success = true;\n                                break; // Success, exit retry loop\n                            }\n                        }\n                        StageResult::Failed(error) => {\n                            last_error = Some(error);\n                            // Continue to next retry\n                            break; // Exit feedback loop to retry\n                        }\n                        StageResult::Paused => {\n                            iteration.pause();\n                            self.iteration_store.save(&iteration)?;\n\n                            self.interaction\n                                .show_message(\n                                    crate::interaction::MessageLevel::Info,\n                                    format!(\"Stage '{}' paused. Use 'continue' to resume.\", stage_name),\n                                )\n                            .await;\n\n                            return Ok(());\n                        }\n                        StageResult::NeedsRevision(feedback) => {\n                            // Stage itself is requesting revision\n                            if feedback_loop_count >= MAX_FEEDBACK_LOOPS {\n                                self.interaction\n                                    .show_message(\n                                        crate::interaction::MessageLevel::Warning,\n                                        format!(\"Maximum revision attempts reached. Proceeding...\"),\n                                    )\n                                    .await;\n                                iteration.resume();\n                                self.iteration_store.save(&iteration)?;\n                                success = true;\n                                break;\n                            }\n                            \n                            feedback_loop_count += 1;\n                            current_feedback = Some(feedback);\n                            self.interaction\n                                .show_message(\n                                    crate::interaction::MessageLevel::Info,\n                                    format!(\"Stage '{}' requesting revision ({} of {})...\", \n                                        stage_name, feedback_loop_count, MAX_FEEDBACK_LOOPS),\n                                )\n                                .await;\n                            continue; // Re-execute with feedback\n                        }\n                    }\n                }\n                \n                if success {\n                    break; // Exit retry loop\n                }\n            } // End of for attempt in 0..MAX_STAGE_RETRIES\n\n            // If all retries failed\n            if !success {\n                let error = last_error.unwrap_or_else(|| \"Unknown error after retries\".to_string());\n                iteration.fail();\n                self.iteration_store.save(&iteration)?;\n\n                self.interaction\n                    .show_message(\n                        crate::interaction::MessageLevel::Error,\n                        format!(\"Stage '{}' failed after {} attempts: {}\", stage_name, MAX_STAGE_RETRIES, error),\n                    )\n                    .await;\n\n                return Err(anyhow::anyhow!(\"Iteration failed at stage '{}' after {} retries\", stage_name, MAX_STAGE_RETRIES));\n            }\n        } // End of for stage in stages\n\n        // Complete iteration\n        iteration.complete();\n        self.iteration_store.save(&iteration)?;\n\n        // Update project\n        project.current_iteration_id = Some(iteration_id.to_string());\n        self.project_store.save(project)?;\n\n        self.interaction\n            .show_message(\n                crate::interaction::MessageLevel::Success,\n                format!(\"Iteration '{}' completed successfully!\", iteration.title),\n            )\n            .await;\n\n        Ok(())\n    }\n\n    /// Continue a paused iteration\n    pub async fn continue_iteration(&self, project: &mut Project, iteration_id: &str) -> anyhow::Result<()> {\n        let mut iteration = self.iteration_store.load(iteration_id)?;\n\n        if iteration.status != IterationStatus::Paused {\n            return Err(anyhow::anyhow!(\"Iteration is not paused\"));\n        }\n\n        iteration.resume();\n        self.iteration_store.save(&iteration)?;\n\n        // Resume execution from current stage\n        self.execute(project, iteration_id).await\n    }\n\n    /// Copy directory recursively\n    async fn copy_dir_all(\n        &self,\n        src: &std::path::Path,\n        dst: &std::path::Path,\n    ) -> anyhow::Result<()> {\n        tokio::fs::create_dir_all(dst).await?;\n\n        let mut entries = tokio::fs::read_dir(src).await?;\n        while let Some(entry) = entries.next_entry().await? {\n            let path = entry.path();\n            let file_name = path.file_name().unwrap();\n            let dest_path = dst.join(file_name);\n\n            if path.is_dir() {\n                Box::pin(self.copy_dir_all(&path, &dest_path)).await?;\n            } else {\n                tokio::fs::copy(&path, &dest_path).await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// Confirmation action for user interaction\n#[derive(Debug, Clone)]\npub enum ConfirmationAction {\n    Continue,           // User confirmed to continue\n    ViewArtifact,       // User wants to view the artifact\n    ProvideFeedback(String), // User provided feedback for revision\n    Cancel,             // User cancelled\n}\n\n#[async_trait::async_trait]\npub trait InteractionExt {\n    async fn request_confirmation(&self, prompt: &str) -> bool;\n    async fn request_confirmation_with_artifact(&self, prompt: &str, artifact_type: &str) -> bool;\n    async fn request_confirmation_with_feedback(&self, prompt: &str, artifact_type: &str) -> ConfirmationAction;\n}\n\n#[async_trait::async_trait]\nimpl InteractionExt for dyn InteractiveBackend {\n    async fn request_confirmation(&self, prompt: &str) -> bool {\n        use crate::interaction::{InputOption, InputResponse};\n\n        let options = vec![\n            InputOption {\n                id: \"yes\".to_string(),\n                label: \"Continue\".to_string(),\n                description: Some(\"Proceed to next stage\".to_string()),\n            },\n            InputOption {\n                id: \"no\".to_string(),\n                label: \"Cancel\".to_string(),\n                description: Some(\"Stop the iteration\".to_string()),\n            },\n        ];\n\n        match self.request_input(prompt, options, None).await {\n            Ok(InputResponse::Selection(id)) => id == \"yes\",\n            _ => false,\n        }\n    }\n\n    async fn request_confirmation_with_artifact(&self, prompt: &str, artifact_type: &str) -> bool {\n        use crate::interaction::{InputOption, InputResponse};\n\n        let options = vec![\n            InputOption {\n                id: \"yes\".to_string(),\n                label: \"Continue\".to_string(),\n                description: Some(\"Confirm and proceed to next stage\".to_string()),\n            },\n            InputOption {\n                id: \"view_artifact\".to_string(),\n                label: \"View Artifact\".to_string(),\n                description: Some(format!(\"Open {} tab to review\", artifact_type)),\n            },\n            InputOption {\n                id: \"no\".to_string(),\n                label: \"Cancel\".to_string(),\n                description: Some(\"Stop the iteration\".to_string()),\n            },\n        ];\n\n        let full_prompt = format!(\"{}\\n[ARTIFACT_TYPE:{}]\", prompt, artifact_type);\n\n        match self.request_input(&full_prompt, options, None).await {\n            Ok(InputResponse::Selection(id)) => match id.as_str() {\n                \"yes\" => true,\n                \"view_artifact\" => {\n                    // Emit event to frontend to view artifact\n                    let _ = self.show_message(\n                        crate::interaction::MessageLevel::Info,\n                        format!(\"[VIEW_ARTIFACT:{}]\", artifact_type)\n                    ).await;\n                    // Return false to pause, user will need to continue after viewing\n                    false\n                }\n                _ => false,\n            }\n            _ => false,\n        }\n    }\n\n    async fn request_confirmation_with_feedback(&self, prompt: &str, artifact_type: &str) -> ConfirmationAction {\n        use crate::interaction::{InputOption, InputResponse};\n\n        let options = vec![\n            InputOption {\n                id: \"yes\".to_string(),\n                label: \"Continue\".to_string(),\n                description: Some(\"Confirm and proceed to next stage\".to_string()),\n            },\n            InputOption {\n                id: \"view_artifact\".to_string(),\n                label: \"View Artifact\".to_string(),\n                description: Some(format!(\"Open {} tab to review\", artifact_type)),\n            },\n            InputOption {\n                id: \"feedback\".to_string(),\n                label: \"Provide Feedback\".to_string(),\n                description: Some(\"Enter feedback to regenerate\".to_string()),\n            },\n            InputOption {\n                id: \"no\".to_string(),\n                label: \"Cancel\".to_string(),\n                description: Some(\"Stop the iteration\".to_string()),\n            },\n        ];\n\n        let full_prompt = format!(\"{}\\n[ARTIFACT_TYPE:{}]\", prompt, artifact_type);\n\n        match self.request_input(&full_prompt, options, None).await {\n            Ok(InputResponse::Selection(id)) => match id.as_str() {\n                \"yes\" => ConfirmationAction::Continue,\n                \"view_artifact\" => ConfirmationAction::ViewArtifact,\n                \"feedback\" => {\n                    // Request feedback text\n                    let feedback_options = vec![\n                        InputOption {\n                            id: \"submit\".to_string(),\n                            label: \"Submit Feedback\".to_string(),\n                            description: Some(\"Submit your feedback\".to_string()),\n                        },\n                    ];\n                    \n                    let feedback_prompt = \"Please enter your feedback or suggestions for improvement:\";\n                    \n                    match self.request_input(feedback_prompt, feedback_options, Some(String::new())).await {\n                        Ok(InputResponse::Text(feedback)) => ConfirmationAction::ProvideFeedback(feedback),\n                        Ok(InputResponse::Selection(_)) => ConfirmationAction::ViewArtifact, // If user selects option, go back\n                        _ => ConfirmationAction::Cancel,\n                    }\n                }\n                _ => ConfirmationAction::Cancel,\n            }\n            Ok(InputResponse::Text(feedback)) => ConfirmationAction::ProvideFeedback(feedback),\n            _ => ConfirmationAction::Cancel,\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 50.0,
      "lines_of_code": 643,
      "number_of_classes": 1,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "language_stdlib",
        "is_external": false,
        "line_number": null,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::domain::Iteration",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::domain::IterationStatus",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::domain::Project",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::interaction::InteractiveBackend",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::persistence::IterationStore",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::persistence::ProjectStore",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::get_stages_from",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::is_critical_stage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::PipelineContext",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::StageResult",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "language_stdlib",
        "is_external": false,
        "line_number": null,
        "name": "std::path::PathBuf",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The IterationExecutor is a controller component responsible for orchestrating the complete lifecycle of development iterations in a software project. It manages the creation of genesis and evolution iterations, prepares workspaces with inheritance logic (full, partial, or none), executes stages in a pipeline with retry and feedback mechanisms, and handles user interaction through confirmation and feedback loops. The component coordinates between persistence stores, interactive backend interfaces, and pipeline stages to enable an iterative development workflow where each stage can be reviewed, revised, paused, or resumed based on human feedback. It implements sophisticated retry logic (up to 3 attempts per stage) and feedback loops (up to 5 revisions per stage) to handle cases where AI-generated outputs require refinement before proceeding.",
    "interfaces": [
      {
        "description": "Extension trait for InteractiveBackend to provide confirmation and feedback interaction methods",
        "interface_type": "trait",
        "name": "InteractionExt",
        "parameters": [],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "Interface for interactive backend communication (user input/output)",
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "Enum defining user interaction responses for stage confirmation",
        "interface_type": "enum",
        "name": "ConfirmationAction",
        "parameters": [],
        "return_type": null,
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "Orchestrating iteration lifecycle from creation to completion",
      "Managing workspace inheritance and file copying logic",
      "Executing pipeline stages with retry and feedback mechanisms",
      "Handling human-in-the-loop confirmation and feedback",
      "Coordinating between persistence, interaction, and pipeline components"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\mod.rs",
      "functions": [
        "get_all_stages",
        "get_stages_from",
        "is_critical_stage"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Stage",
        "StageResult",
        "PipelineContext"
      ],
      "name": "mod.rs",
      "source_summary": "// Unified Iteration Pipeline\r\n// Single entry point for all development cycles\r\n\r\nuse std::sync::Arc;\r\n\r\nuse crate::domain::{Iteration, Project};\r\nuse crate::interaction::InteractiveBackend;\r\n\r\npub mod executor;\r\npub mod stages;\r\n\r\npub use executor::*;\r\npub use stages::*;\r\n\r\n/// Stage execution result\n#[derive(Debug)]\npub enum StageResult {\n    Success(Option<String>), // Artifact path\n    Failed(String),          // Error message\n    Paused,                  // Waiting for human confirmation\n    NeedsRevision(String),   // Needs revision with feedback\n}\n\r\n/// Pipeline context for stage execution\r\n#[derive(Debug, Clone)]\r\npub struct PipelineContext {\r\n    pub project: Project,\r\n    pub iteration: Iteration,\r\n    pub workspace_path: std::path::PathBuf,\r\n}\r\n\r\nimpl PipelineContext {\r\n    pub fn new(project: Project, iteration: Iteration, workspace_path: std::path::PathBuf) -> Self {\r\n        Self {\r\n            project,\r\n            iteration,\r\n            workspace_path,\r\n        }\r\n    }\r\n}\r\n\r\n/// Stage trait - all stages implement this\n#[async_trait::async_trait]\npub trait Stage: Send + Sync {\n    fn name(&self) -> &str;\n    fn description(&self) -> &str;\n\n    /// Check if this stage needs human confirmation after completion\n    fn needs_confirmation(&self) -> bool {\n        false\n    }\n\n    /// Execute the stage\n    async fn execute(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n    ) -> StageResult;\n\n    /// Execute the stage with feedback (for revision)\n    async fn execute_with_feedback(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n        _feedback: &str,\n    ) -> StageResult {\n        // Default implementation just calls execute\n        // Stages that support revision should override this\n        self.execute(ctx, interaction).await\n    }\n}\n\r\n/// Get all available stages in order\r\npub fn get_all_stages() -> Vec<Box<dyn Stage>> {\r\n    vec![\r\n        Box::new(stages::IdeaStage),\r\n        Box::new(stages::PrdStage),\r\n        Box::new(stages::DesignStage),\r\n        Box::new(stages::PlanStage),\r\n        Box::new(stages::CodingStage),\r\n        Box::new(stages::CheckStage),\r\n        Box::new(stages::DeliveryStage),\r\n    ]\r\n}\r\n\r\n/// Get stages starting from a specific stage\r\npub fn get_stages_from(start_stage: &str) -> Vec<Box<dyn Stage>> {\r\n    let all = get_all_stages();\r\n    let start_idx = all.iter().position(|s| s.name() == start_stage).unwrap_or(0);\r\n    all.into_iter().skip(start_idx).collect()\r\n}\r\n\r\n/// Determine if a stage needs human confirmation\npub fn is_critical_stage(stage_name: &str) -> bool {\n    matches!(stage_name, \"idea\" | \"prd\" | \"design\" | \"plan\" | \"coding\")\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 7.0,
      "lines_of_code": 96,
      "number_of_classes": 2,
      "number_of_functions": 3
    },
    "dependencies": [
      {
        "dependency_type": "language",
        "is_external": true,
        "line_number": null,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::domain",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::interaction",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This module serves as the central orchestration layer for the development pipeline in the Cowork system. It defines the core abstractions and utilities for executing a sequence of development stages (e.g., Idea, PRD, Design, Coding, etc.) in a structured, ordered workflow. The module exposes a trait `Stage` that all pipeline stages must implement, defining methods for execution, naming, and optional human confirmation. It also defines `PipelineContext` to carry state (project, iteration, workspace) through stage execution and `StageResult` to represent outcomes of each stage. Utility functions `get_all_stages`, `get_stages_from`, and `is_critical_stage` provide stage enumeration and critical stage detection. The module delegates concrete stage implementations to submodules `executor` and `stages`, maintaining separation of concerns while exposing them via `pub use`.",
    "interfaces": [
      {
        "description": "Trait defining the contract for pipeline stages. Includes name, description, execution, and optional feedback handling methods.",
        "interface_type": "trait",
        "name": "Stage",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "_feedback",
            "param_type": "&str"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Enum representing possible outcomes of stage execution: Success (with optional artifact path), Failed (with error message), Paused (waiting for human input), or NeedsRevision (with feedback).",
        "interface_type": "enum",
        "name": "StageResult",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Struct holding the execution context for a pipeline run, including project, iteration, and filesystem workspace path.",
        "interface_type": "struct",
        "name": "PipelineContext",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "project",
            "param_type": "Project"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "iteration",
            "param_type": "Iteration"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "workspace_path",
            "param_type": "std::path::PathBuf"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Orchestrating the sequence of development stages in a pipeline",
      "Defining the Stage trait as the contract for all pipeline stages",
      "Providing context (PipelineContext) to pass state between stages",
      "Enumerating and filtering available stages by name",
      "Determining which stages require human confirmation based on name"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\check.rs",
      "functions": [
        "load_workspace_code",
        "load_plan_document",
        "load_config",
        "execute",
        "name",
        "description"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "execute",
        "name",
        "description",
        "load_workspace_code",
        "load_plan_document",
        "load_config"
      ],
      "name": "check.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\nuse futures::StreamExt;\r\n\r\n/// Check Stage - Quality assurance using LLM\r\npub struct CheckStage;\r\n\r\n#[async_trait::async_trait]\r\nimpl Stage for CheckStage {\r\n    fn name(&self) -> &str {\r\n        \"check\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Check - Quality assurance\"\r\n    }\r\n\r\n    async fn execute(\r\n        &self,\r\n        ctx: &PipelineContext,\r\n        interaction: Arc<dyn InteractiveBackend>,\r\n    ) -> StageResult {\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Running quality checks with AI...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Load LLM config\r\n        let config = match load_config() {\r\n            Ok(cfg) => cfg,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Create LLM client\r\n        let llm = match create_llm_client(&config.llm) {\r\n            Ok(client) => client,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Load generated code\r\n        let code_content = load_workspace_code(ctx);\r\n        let plan_content = load_plan_document(ctx);\r\n\r\n        // Generate code review using LLM\r\n        let prompt = format!(\r\n            r#\"You are a code reviewer. Review the implementation against the requirements and provide a quality report.\r\n\r\n**Iteration:** #{} - {}\r\n\r\n**Requirements:**\r\n{}\r\n\r\n**Implementation:**\r\n{}\r\n\r\nPlease provide a comprehensive code review that includes:\r\n\r\n1. **Overall Assessment** - Does the code meet the requirements?\r\n2. **Code Quality** - Readability, maintainability, best practices\r\n3. **Functionality** - Does it implement all required features?\r\n4. **Error Handling** - Are edge cases handled properly?\r\n5. **Security Issues** - Any potential vulnerabilities?\r\n6. **Performance** - Any obvious performance issues?\r\n7. **Recommendations** - Specific improvements with code examples\r\n\r\nProvide a PASS/FAIL verdict at the end.\"#,\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            plan_content,\r\n            if code_content.len() > 8000 { &code_content[..8000] } else { &code_content }\r\n        );\r\n\r\n        let content = Content::new(\"user\").with_text(prompt);\r\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\r\n        \r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Analyzing code quality...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Call LLM\r\n        let mut stream = match llm.generate_content(request, false).await {\r\n            Ok(resp) => resp,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"LLM review failed: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Collect response from stream\r\n        let mut review_text = String::new();\r\n        while let Some(result) = stream.next().await {\r\n            match result {\r\n                Ok(response) => {\r\n                    if let Some(content) = response.content {\r\n                        for part in content.parts {\r\n                            if let Some(text) = part.text() {\r\n                                review_text.push_str(text);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                Err(_) => break,\r\n            }\r\n        }\r\n\r\n        if review_text.is_empty() {\r\n            review_text = \"# Code Review\\n\\nNo review generated.\".to_string();\r\n        }\r\n\r\n        // Determine if passed\r\n        let passed = review_text.to_uppercase().contains(\"PASS\") || \r\n                     review_text.to_uppercase().contains(\"APPROVED\");\r\n\r\n        // Write review to file\r\n        let artifact_path = format!(\r\n            \"{}/.cowork-v2/iterations/{}/artifacts/check_report.md\",\r\n            std::env::current_dir().unwrap().display(),\r\n            ctx.iteration.id\r\n        );\r\n\r\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\r\n            let _ = std::fs::create_dir_all(parent);\r\n        }\r\n\r\n        let verdict = if passed { \"✅ PASS\" } else { \"⚠️ NEEDS IMPROVEMENT\" };\r\n        let report = format!(\r\n            \"# Code Quality Report\\n\\n**Iteration:** #{} - {}\\n\\n**Verdict:** {}\\n\\n**Generated:** {}\\n\\n---\\n\\n{}\",\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            verdict,\r\n            chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\r\n            review_text\r\n        );\r\n\r\n        if let Err(e) = std::fs::write(&artifact_path, report) {\r\n            return StageResult::Failed(format!(\"Failed to write check report: {}\", e));\r\n        }\r\n\r\n        if passed {\r\n            interaction\r\n                .show_message(\r\n                    crate::interaction::MessageLevel::Success,\r\n                    \"Quality check passed!\".to_string(),\r\n                )\r\n                .await;\r\n        } else {\r\n            interaction\r\n                .show_message(\r\n                    crate::interaction::MessageLevel::Warning,\r\n                    \"Quality check completed with recommendations\".to_string(),\r\n                )\r\n                .await;\r\n        }\r\n\r\n        // Check stage always succeeds but reports issues\r\n        StageResult::Success(Some(artifact_path))\r\n    }\r\n}\r\n\r\n/// Load code from workspace\r\nfn load_workspace_code(ctx: &PipelineContext) -> String {\r\n    let mut all_code = String::new();\r\n    \r\n    if let Ok(entries) = std::fs::read_dir(&ctx.workspace_path) {\r\n        for entry in entries.flatten() {\r\n            let path = entry.path();\r\n            if path.is_file() {\r\n                if let Ok(content) = std::fs::read_to_string(&path) {\r\n                    all_code.push_str(&format!(\"\\n\\n// File: {}\\n{}\", \r\n                        path.file_name().unwrap_or_default().to_string_lossy(),\r\n                        content));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if all_code.is_empty() {\r\n        all_code = \"// No code files found in workspace\".to_string();\r\n    }\r\n\r\n    all_code\r\n}\r\n\r\n/// Load plan document\r\nfn load_plan_document(ctx: &PipelineContext) -> String {\r\n    let plan_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/plan.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    match std::fs::read_to_string(&plan_path) {\r\n        Ok(content) => content,\r\n        Err(_) => ctx.iteration.description.clone(),\r\n    }\r\n}\r\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 26.0,
      "lines_of_code": 227,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "std::sync::Arc",
        "path": "std",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "crate::interaction::InteractiveBackend",
        "path": "crates\\cowork-core\\src\\interaction",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 5,
        "name": "crate::pipeline::{PipelineContext, Stage, StageResult}",
        "path": "crates\\cowork-core\\src\\pipeline",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 6,
        "name": "crate::llm::{ModelConfig, create_llm_client}",
        "path": "crates\\cowork-core\\src\\llm",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 7,
        "name": "adk_core::{Content, LlmRequest}",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 8,
        "name": "futures::StreamExt",
        "path": "futures",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 11,
        "name": "async_trait::async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 112,
        "name": "chrono::Local",
        "path": "chrono",
        "version": null
      }
    ],
    "detailed_description": "The CheckStage component is a quality assurance pipeline stage that leverages Large Language Models (LLM) to perform automated code review and quality assessment of generated code artifacts. The component implements the Stage trait and serves as an intelligent quality gate within the pipeline architecture.\n\n**Core Business Logic Flow:**\n\n1. **Initialization Phase**: Displays an informational message to users indicating quality checks are being performed with AI assistance.\n\n2. **Configuration Loading**: Loads LLM configuration through the `load_config()` function, which supports multiple fallback strategies - first checking for 'config.toml' in the current directory, then checking alongside the executable, and finally falling back to environment variables.\n\n3. **LLM Client Creation**: Instantiates an LLM client using the loaded configuration to enable AI-powered code analysis.\n\n4. **Artifact Collection**: \n   - Loads generated code files from the workspace directory via `load_workspace_code()`, which iterates through all files and concatenates their content with file headers\n   - Loads the plan document via `load_plan_document()` which reads from the artifact directory or falls back to the iteration description\n\n5. **Prompt Engineering**: Constructs a comprehensive prompt that includes iteration metadata, requirements, and implementation code (truncated to 8000 characters to avoid token limits). The prompt requests detailed analysis across 7 dimensions: overall assessment, code quality, functionality, error handling, security, performance, and recommendations with a PASS/FAIL verdict.\n\n6. **AI Review Generation**: Sends the constructed prompt to the LLM and processes the streaming response, accumulating review text from the content parts.\n\n7. **Verdict Determination**: Determines whether the code passed quality checks by searching for \"PASS\" or \"APPROVED\" keywords in the review (case-insensitive).\n\n8. **Report Generation**: Creates a structured markdown report file stored in the iteration artifacts directory, including iteration metadata, verdict (with emoji indicators), timestamp, and full review content.\n\n9. **User Feedback**: Displays success or warning messages through the interactive backend based on the verdict.\n\n10. **Completion**: Returns a successful StageResult with the path to the generated report artifact, ensuring the pipeline continues regardless of the review verdict.\n\nThe component follows a fail-safe design where quality checks are informative rather than blocking, allowing the pipeline to proceed while providing valuable feedback for improvement.",
    "interfaces": [
      {
        "description": "Returns the stage identifier name 'check'",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns a human-readable description 'Check - Quality assurance'",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Main execution method that orchestrates the entire quality assurance process including config loading, LLM invocation, review generation, and report persistence. Returns StageResult with the report artifact path on success, or failure message on error.",
        "interface_type": "async_method",
        "name": "execute",
        "parameters": [
          {
            "description": "Pipeline context containing iteration metadata and workspace path",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": "Interactive backend for user communication",
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Reads all files from the workspace directory and concatenates them into a single string with file headers. Returns placeholder message if no files found.",
        "interface_type": "function",
        "name": "load_workspace_code",
        "parameters": [
          {
            "description": "Pipeline context containing workspace path",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Loads the plan document from the iteration artifacts directory. Falls back to iteration description if file cannot be read.",
        "interface_type": "function",
        "name": "load_plan_document",
        "parameters": [
          {
            "description": "Pipeline context containing iteration ID",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Loads LLM configuration with three-tier fallback: current directory config.toml, executable directory config.toml, or environment variables. Returns error if all sources fail.",
        "interface_type": "function",
        "name": "load_config",
        "parameters": [],
        "return_type": "anyhow::Result<ModelConfig>",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "AI-powered code quality assurance - Using LLM to perform comprehensive code review against requirements, analyzing 7 quality dimensions including functionality, security, performance, and best practices",
      "Code review orchestration - Managing the entire review process from artifact collection (workspace code and plan documents) through prompt construction, LLM invocation, streaming response handling, to verdict determination",
      "Review report generation and persistence - Creating structured markdown reports with iteration metadata, PASS/FAIL verdicts, timestamps, and storing them in the iteration artifacts directory",
      "Configuration management - Loading LLM configuration with multi-source fallback strategy supporting config files (current directory and executable directory) and environment variables",
      "Interactive user feedback - Communicating quality check progress and results through the InteractiveBackend, providing clear status messages and verdict indicators"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\coding.rs",
      "functions": [
        "name",
        "description",
        "needs_confirmation",
        "execute",
        "load_plan_document",
        "parse_file_list",
        "is_valid_file_path",
        "extract_files_from_text",
        "extract_code",
        "validate_code_syntax",
        "generate_code_summary",
        "load_config"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "name() -> &str",
        "description() -> &str",
        "needs_confirmation() -> bool",
        "execute(&self, ctx: &PipelineContext, interaction: Arc<dyn InteractiveBackend>) -> StageResult",
        "load_plan_document(ctx: &PipelineContext) -> String",
        "parse_file_list(text: &str) -> Vec<(String, String)>",
        "is_valid_file_path(path: &str) -> bool",
        "extract_files_from_text(text: &str) -> Vec<(String, String)>",
        "extract_code(text: &str) -> String",
        "validate_code_syntax(file_path: &str, code: &str) -> Vec<String>",
        "generate_code_summary(workspace_path: &Path) -> String",
        "load_config() -> anyhow::Result<ModelConfig>"
      ],
      "name": "coding.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\nuse futures::StreamExt;\r\n\r\n/// Coding Stage - Generate and write actual code using LLM\r\npub struct CodingStage;\r\n\r\n#[async_trait::async_trait]\r\nimpl Stage for CodingStage {\r\n    fn name(&self) -> &str {\r\n        \"coding\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Coding - Generate and write code\"\r\n    }\r\n\r\n    fn needs_confirmation(&self) -> bool {\r\n        true\r\n    }\r\n\r\n    async fn execute(\r\n        &self,\r\n        ctx: &PipelineContext,\r\n        interaction: Arc<dyn InteractiveBackend>,\r\n    ) -> StageResult {\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Generating code with AI...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Load LLM config\r\n        let config = match load_config() {\r\n            Ok(cfg) => cfg,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Create LLM client\r\n        let llm = match create_llm_client(&config.llm) {\r\n            Ok(client) => client,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Load implementation plan\r\n        let plan_content = load_plan_document(ctx);\r\n\r\n        // Ensure workspace directory exists\r\n        let workspace_path = &ctx.workspace_path;\r\n        if let Err(e) = std::fs::create_dir_all(workspace_path) {\r\n            return StageResult::Failed(format!(\"Failed to create workspace directory: {}\", e));\r\n        }\r\n\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                format!(\"Generating code in: {}\", workspace_path.display()),\r\n            )\r\n            .await;\r\n\r\n        // Generate code structure first\r\n        let structure_prompt = format!(\r\n            r#\"You are a senior software engineer. Based on the implementation plan, generate a complete file structure for the project.\r\n\r\n**Iteration:** #{} - {}\r\n\r\n{}\r\n\r\nPlease provide:\r\n1. List of all files to create with their full paths\r\n2. Brief description of what each file contains\r\n\r\nFormat your response as:\r\n```\r\nFILES:\r\n- path/to/file1.ext: description\r\n- path/to/file2.ext: description\r\n...\r\n```\"#,\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            plan_content\r\n        );\r\n\r\n        let structure_content = Content::new(\"user\").with_text(structure_prompt);\r\n        let structure_request = LlmRequest::new(&config.llm.model_name, vec![structure_content]);\r\n        \r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Analyzing requirements and generating file structure...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        let mut structure_stream = match llm.generate_content(structure_request, false).await {\r\n            Ok(resp) => resp,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"LLM structure generation failed: {}\", e));\r\n            }\r\n        };\r\n\r\n        let mut structure_text = String::new();\r\n        while let Some(result) = structure_stream.next().await {\r\n            match result {\r\n                Ok(response) => {\r\n                    if let Some(content) = response.content {\r\n                        for part in content.parts {\r\n                            if let Some(text) = part.text() {\r\n                                structure_text.push_str(text);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                Err(_) => break,\r\n            }\r\n        }\r\n\r\n        // Parse file list from response\r\n        let files_to_generate = parse_file_list(&structure_text);\r\n\r\n        if files_to_generate.is_empty() {\r\n            // Fallback: generate a single main file\r\n            let main_file_path = workspace_path.join(\"main.rs\");\r\n            \r\n            interaction\r\n                .show_message(\r\n                    crate::interaction::MessageLevel::Info,\r\n                    \"Generating main implementation file...\".to_string(),\r\n                )\r\n                .await;\r\n\r\n            let code_prompt = format!(\r\n                r#\"You are a senior software engineer. Generate a complete, working implementation based on the plan.\r\n\r\n**Iteration:** #{} - {}\r\n\r\n{}\r\n\r\nGenerate a complete, working code implementation. The code should be:\r\n- Fully functional and compilable\r\n- Well-commented\r\n- Following best practices\r\n- Include error handling where appropriate\r\n\r\nProvide the complete code for the main implementation.\"#,\r\n                ctx.iteration.number,\r\n                ctx.iteration.title,\r\n                plan_content\r\n            );\r\n\r\n            let code_content = Content::new(\"user\").with_text(code_prompt);\r\n            let code_request = LlmRequest::new(&config.llm.model_name, vec![code_content]);\r\n            \r\n            let mut code_stream = match llm.generate_content(code_request, false).await {\r\n                Ok(resp) => resp,\r\n                Err(e) => {\r\n                    return StageResult::Failed(format!(\"LLM code generation failed: {}\", e));\r\n                }\r\n            };\r\n\r\n            let mut generated_code = String::new();\r\n            while let Some(result) = code_stream.next().await {\r\n                match result {\r\n                    Ok(response) => {\r\n                        if let Some(content) = response.content {\r\n                            for part in content.parts {\r\n                                if let Some(text) = part.text() {\r\n                                    generated_code.push_str(text);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    Err(_) => break,\r\n                }\r\n            }\r\n\r\n            if generated_code.is_empty() {\r\n                generated_code = \"// Code generation failed\".to_string();\r\n            }\r\n\r\n            // Extract code from markdown code blocks if present\r\n            let clean_code = extract_code(&generated_code);\r\n\r\n            if let Err(e) = std::fs::write(&main_file_path, clean_code) {\r\n                return StageResult::Failed(format!(\"Failed to write main file: {}\", e));\r\n            }\r\n\r\n            interaction\r\n                .show_message(\r\n                    crate::interaction::MessageLevel::Success,\r\n                    format!(\"Generated: {}\", main_file_path.display()),\r\n                )\r\n                .await;\r\n        } else {\r\n            // Generate each file\r\n            for (file_path, description) in &files_to_generate {\r\n                let full_path = workspace_path.join(file_path);\r\n                \r\n                // Ensure parent directory exists\r\n                if let Some(parent) = full_path.parent() {\r\n                    let _ = std::fs::create_dir_all(parent);\r\n                }\r\n\r\n                interaction\r\n                    .show_message(\r\n                        crate::interaction::MessageLevel::Info,\r\n                        format!(\"Generating: {}\", file_path),\r\n                    )\r\n                    .await;\r\n\r\n                let file_prompt = format!(\r\n                    r#\"You are a senior software engineer. Generate the complete code for this specific file.\r\n\r\n**File:** {}\r\n**Description:** {}\r\n\r\n**Project Context:**\r\n{}\r\n\r\nGenerate complete, working code for this file only. The code should be:\r\n- Fully functional\r\n- Well-commented\r\n- Following best practices\r\n- Properly integrated with the rest of the project\r\n\r\nProvide ONLY the code for this file, no explanations.\"#,\r\n                    file_path,\r\n                    description,\r\n                    plan_content\r\n                );\r\n\r\n                let file_content = Content::new(\"user\").with_text(file_prompt);\r\n                let file_request = LlmRequest::new(&config.llm.model_name, vec![file_content]);\r\n                \r\n                let mut file_stream = match llm.generate_content(file_request, false).await {\r\n                    Ok(resp) => resp,\r\n                    Err(e) => {\r\n                        interaction\r\n                            .show_message(\r\n                                crate::interaction::MessageLevel::Error,\r\n                                format!(\"Failed to generate {}: {}\", file_path, e),\r\n                            )\r\n                            .await;\r\n                        continue;\r\n                    }\r\n                };\r\n\r\n                let mut generated_code = String::new();\r\n                while let Some(result) = file_stream.next().await {\r\n                    match result {\r\n                        Ok(response) => {\r\n                            if let Some(content) = response.content {\r\n                                for part in content.parts {\r\n                                    if let Some(text) = part.text() {\r\n                                        generated_code.push_str(text);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        Err(_) => break,\r\n                    }\r\n                }\r\n\r\n                if generated_code.is_empty() {\r\n                    generated_code = format!(\"// Failed to generate {}\", file_path);\r\n                }\r\n\r\n                let clean_code = extract_code(&generated_code);\r\n\r\n                // Validate code syntax\r\n                let issues = validate_code_syntax(file_path, &clean_code);\r\n                if !issues.is_empty() {\r\n                    interaction\r\n                        .show_message(\r\n                            crate::interaction::MessageLevel::Warning,\r\n                            format!(\"Code validation warnings for {}: {}\", file_path, issues.join(\", \")),\r\n                        )\r\n                        .await;\r\n                }\r\n\r\n                // Create parent directory\r\n                if let Some(parent) = full_path.parent() {\r\n                    if let Err(e) = std::fs::create_dir_all(parent) {\r\n                        interaction\r\n                            .show_message(\r\n                                crate::interaction::MessageLevel::Error,\r\n                                format!(\"Failed to create directory for {}: {}\", file_path, e),\r\n                            )\r\n                            .await;\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if let Err(e) = std::fs::write(&full_path, &clean_code) {\r\n                    interaction\r\n                        .show_message(\r\n                            crate::interaction::MessageLevel::Error,\r\n                            format!(\"Failed to write {}: {}\", file_path, e),\r\n                        )\r\n                        .await;\r\n                } else {\r\n                    interaction\r\n                        .show_message(\r\n                            crate::interaction::MessageLevel::Success,\r\n                            format!(\"Generated {} ({} bytes)\", file_path, clean_code.len()),\r\n                        )\r\n                        .await;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Write a summary file of generated code\r\n        let summary_path = workspace_path.join(\".generated_files.txt\");\r\n        let summary = generate_code_summary(workspace_path);\r\n        let _ = std::fs::write(&summary_path, summary);\r\n\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Success,\r\n                format!(\"Code generation complete in: {}\", workspace_path.display()),\r\n            )\r\n            .await;\r\n\r\n        // Coding stage doesn't produce an artifact file, it writes to workspace\r\n        StageResult::Success(None)\r\n    }\r\n}\r\n\r\n/// Load plan document\r\nfn load_plan_document(ctx: &PipelineContext) -> String {\r\n    let plan_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/plan.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    let design_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/design.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    let mut result = String::new();\r\n\r\n    if let Ok(content) = std::fs::read_to_string(&plan_path) {\r\n        result.push_str(&format!(\"**Implementation Plan:**\\n{}\\n\\n\", content));\r\n    }\r\n\r\n    if let Ok(content) = std::fs::read_to_string(&design_path) {\r\n        result.push_str(&format!(\"**Design Document:**\\n{}\\n\\n\", content));\r\n    }\r\n\r\n    if result.is_empty() {\r\n        result = format!(\r\n            \"**Requirements:**\\nIteration #{} - {}\\nDescription: {}\",\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            ctx.iteration.description\r\n        );\r\n    }\r\n\r\n    result\r\n}\r\n\r\n/// Parse file list from LLM response (improved to handle multiple formats)\r\nfn parse_file_list(text: &str) -> Vec<(String, String)> {\r\n    let mut files = Vec::new();\r\n    let mut in_files_section = false;\r\n\r\n    for line in text.lines() {\r\n        let trimmed = line.trim();\r\n        \r\n        // Detect file section start\r\n        if trimmed.starts_with(\"FILES:\") \r\n            || trimmed.starts_with(\"File Structure:\")\r\n            || trimmed.starts_with(\"## Files\")\r\n            || trimmed.starts_with(\"### Files\")\r\n            || trimmed.to_lowercase().starts_with(\"file list:\")\r\n            || trimmed.to_lowercase().starts_with(\"project structure:\") {\r\n            in_files_section = true;\r\n            continue;\r\n        }\r\n\r\n        // Detect section end (next header or empty line after files)\r\n        if in_files_section && trimmed.starts_with(\"#\") && !trimmed.starts_with(\"##\") {\r\n            in_files_section = false;\r\n            continue;\r\n        }\r\n\r\n        if in_files_section && (trimmed.starts_with(\"-\") || trimmed.starts_with(\"*\")) {\r\n            // Parse line like: - path/to/file.rs: description\r\n            // or: - `path/to/file.rs`: description\r\n            let content = trimmed.trim_start_matches(\"-\").trim_start_matches(\"*\").trim();\r\n            \r\n            // Remove backticks if present\r\n            let content = content.trim_matches('`');\r\n            \r\n            if let Some(pos) = content.find(':') {\r\n                let path = content[..pos].trim().trim_matches('`').to_string();\r\n                let desc = content[pos + 1..].trim().to_string();\r\n                if is_valid_file_path(&path) {\r\n                    files.push((path, desc));\r\n                }\r\n            } else if let Some(pos) = content.find('|') {\r\n                let path = content[..pos].trim().trim_matches('`').to_string();\r\n                let desc = content[pos + 1..].trim().to_string();\r\n                if is_valid_file_path(&path) {\r\n                    files.push((path, desc));\r\n                }\r\n            } else if is_valid_file_path(content) {\r\n                // Just a file path without description\r\n                files.push((content.to_string(), \"Generated file\".to_string()));\r\n            }\r\n        }\r\n\r\n        // Also try to detect file paths in code blocks or plain text\r\n        if !in_files_section && trimmed.contains('.') {\r\n            // Try to extract file paths like src/main.rs or path/to/file.js\r\n            let words: Vec<&str> = trimmed.split_whitespace().collect();\r\n            for word in words {\r\n                let clean = word.trim_matches(|c| c == '`' || c == '\"' || c == '\\'' || c == '(' || c == ')' || c == ',' || c == '.');\r\n                if is_valid_file_path(clean) && !files.iter().any(|(p, _)| p == clean) {\r\n                    files.push((clean.to_string(), \"Generated file\".to_string()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // If no files found in structured format, try regex-like extraction\r\n    if files.is_empty() {\r\n        files = extract_files_from_text(text);\r\n    }\r\n\r\n    files\r\n}\r\n\r\n/// Check if a string looks like a valid file path\r\nfn is_valid_file_path(path: &str) -> bool {\r\n    // Must have a file extension\r\n    let has_extension = path.contains('.') && !path.ends_with('.');\r\n    \r\n    // Must not contain invalid characters\r\n    let invalid_chars = ['<', '>', '|', '?', '*', '\\0'];\r\n    let no_invalid = !invalid_chars.iter().any(|&c| path.contains(c));\r\n    \r\n    // Should look like a path (contains / or is a simple filename)\r\n    let looks_like_path = path.contains('/') || !path.contains(' ');\r\n    \r\n    has_extension && no_invalid && looks_like_path && path.len() > 2\r\n}\r\n\r\n/// Extract file paths from unstructured text\r\nfn extract_files_from_text(text: &str) -> Vec<(String, String)> {\r\n    let mut files = Vec::new();\r\n    let common_patterns = [\r\n        (r\"(?:^|\\s)([\\w\\-/]+\\.\\w+)\\s*[:\\-]\", \"code\"),  // path.ext: description\r\n        (r\"`([^`]+\\.\\w+)`\", \"markdown\"),                 // `path.ext`\r\n    ];\r\n\r\n    for line in text.lines() {\r\n        for (_pattern, _p_type) in &common_patterns {\r\n            // Simple pattern matching without regex crate\r\n            if let Some(start) = line.find(\"/\") {\r\n                if let Some(end) = line[start..].find(' ') {\r\n                    let candidate = &line[start..start+end];\r\n                    if is_valid_file_path(candidate) {\r\n                        let desc = line[end..].trim_start_matches(|c| c == ':' || c == '-').trim();\r\n                        files.push((candidate.to_string(), desc.to_string()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    files\r\n}\r\n\r\n/// Extract code from markdown code blocks (improved)\r\nfn extract_code(text: &str) -> String {\r\n    let mut result = String::new();\r\n    let mut in_code_block = false;\r\n    let mut code_block_content = String::new();\r\n\r\n    for line in text.lines() {\r\n        let trimmed = line.trim();\r\n        \r\n        if trimmed.starts_with(\"```\") {\r\n            if in_code_block {\r\n                // End of code block\r\n                if !result.is_empty() {\r\n                    result.push('\\n');\r\n                }\r\n                result.push_str(&code_block_content);\r\n                code_block_content.clear();\r\n                in_code_block = false;\r\n            } else {\r\n                // Start of code block - skip the language identifier\r\n                in_code_block = true;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if in_code_block {\r\n            code_block_content.push_str(line);\r\n            code_block_content.push('\\n');\r\n        }\r\n    }\r\n\r\n    // If still in code block at end, include the content\r\n    if in_code_block && !code_block_content.is_empty() {\r\n        if !result.is_empty() {\r\n            result.push('\\n');\r\n        }\r\n        result.push_str(&code_block_content);\r\n    }\r\n\r\n    if result.is_empty() {\r\n        // No code blocks found, return entire text (but clean it up)\r\n        text.trim()\r\n            .trim_start_matches(|c| c == '`')\r\n            .trim_end_matches(|c| c == '`')\r\n            .to_string()\r\n    } else {\r\n        result.trim_end().to_string()\r\n    }\r\n}\r\n\r\n/// Validate generated code has basic syntax correctness\r\nfn validate_code_syntax(file_path: &str, code: &str) -> Vec<String> {\r\n    let mut issues = Vec::new();\r\n    let ext = std::path::Path::new(file_path)\r\n        .extension()\r\n        .and_then(|e| e.to_str())\r\n        .unwrap_or(\"\");\r\n\r\n    // Check for unclosed braces/parentheses (basic check)\r\n    let open_braces = code.matches('{').count();\r\n    let close_braces = code.matches('}').count();\r\n    if open_braces != close_braces {\r\n        issues.push(format!(\"Unbalanced braces: {} open, {} close\", open_braces, close_braces));\r\n    }\r\n\r\n    let open_parens = code.matches('(').count();\r\n    let close_parens = code.matches(')').count();\r\n    if open_parens != close_parens {\r\n        issues.push(format!(\"Unbalanced parentheses: {} open, {} close\", open_parens, close_parens));\r\n    }\r\n\r\n    // Language-specific checks\r\n    match ext {\r\n        \"rs\" => {\r\n            // Rust: check for fn main or lib structure\r\n            if !code.contains(\"fn \") && !code.contains(\"struct \") && !code.contains(\"enum \") {\r\n                issues.push(\"No function or type definitions found\".to_string());\r\n            }\r\n        }\r\n        \"js\" | \"ts\" | \"jsx\" | \"tsx\" => {\r\n            // JavaScript/TypeScript: check for basic structure\r\n            if !code.contains(\"function\") && !code.contains(\"const\") && !code.contains(\"export\") {\r\n                issues.push(\"No JavaScript/TypeScript constructs found\".to_string());\r\n            }\r\n        }\r\n        \"py\" => {\r\n            // Python: check for def or class\r\n            if !code.contains(\"def \") && !code.contains(\"class \") {\r\n                issues.push(\"No function or class definitions found\".to_string());\r\n            }\r\n        }\r\n        _ => {}\r\n    }\r\n\r\n    // Check for placeholder comments that indicate incomplete generation\r\n    let placeholder_patterns = [\r\n        \"TODO:\", \"FIXME:\", \"// ...\", \"// ...\", \"/* ...\", \"# ...\",\r\n        \"// implementation\", \"// your code here\", \"// add your logic\",\r\n    ];\r\n    for pattern in &placeholder_patterns {\r\n        if code.to_lowercase().contains(&pattern.to_lowercase()) {\r\n            issues.push(format!(\"Contains placeholder: {}\", pattern));\r\n        }\r\n    }\r\n\r\n    issues\r\n}\r\n\r\n/// Generate a summary of generated code files\r\nfn generate_code_summary(workspace_path: &std::path::Path) -> String {\r\n    let mut summary = String::from(\"# Generated Code Files\\n\\n\");\r\n    summary.push_str(&format!(\"Generated at: {}\\n\\n\", chrono::Utc::now().to_rfc3339()));\r\n\r\n    let mut total_files = 0;\r\n    let mut total_lines = 0;\r\n\r\n    if let Ok(entries) = std::fs::read_dir(workspace_path) {\r\n        for entry in entries.flatten() {\r\n            let path = entry.path();\r\n            if path.is_file() && path.extension().is_some() {\r\n                let file_name = path.file_name().unwrap().to_string_lossy();\r\n                if file_name.starts_with('.') {\r\n                    continue; // Skip hidden files\r\n                }\r\n\r\n                if let Ok(content) = std::fs::read_to_string(&path) {\r\n                    let lines = content.lines().count();\r\n                    total_lines += lines;\r\n                    total_files += 1;\r\n                    summary.push_str(&format!(\"- {} ({} lines)\\n\", file_name, lines));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    summary.push_str(&format!(\"\\n## Summary\\n\"));\r\n    summary.push_str(&format!(\"- Total files: {}\\n\", total_files));\r\n    summary.push_str(&format!(\"- Total lines: {}\\n\", total_lines));\r\n\r\n    summary\r\n}\r\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 93.0,
      "lines_of_code": 646,
      "number_of_classes": 1,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "trait",
        "is_external": false,
        "line_number": 3,
        "name": "crate::interaction::InteractiveBackend",
        "path": "crate::interaction",
        "version": null
      },
      {
        "dependency_type": "types/trait",
        "is_external": false,
        "line_number": 4,
        "name": "crate::pipeline::{PipelineContext, Stage, StageResult}",
        "path": "crate::pipeline",
        "version": null
      },
      {
        "dependency_type": "types/function",
        "is_external": false,
        "line_number": 5,
        "name": "crate::llm::{ModelConfig, create_llm_client}",
        "path": "crate::llm",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 6,
        "name": "adk_core::{Content, LlmRequest}",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 7,
        "name": "futures::StreamExt",
        "path": "futures",
        "version": null
      },
      {
        "dependency_type": "std library",
        "is_external": true,
        "line_number": 1,
        "name": "std::sync::Arc",
        "path": "std::sync",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": null,
        "name": "async_trait::async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 641,
        "name": "anyhow",
        "path": "anyhow",
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 595,
        "name": "chrono::Utc",
        "path": "chrono",
        "version": null
      }
    ],
    "detailed_description": "The CodingStage is a critical pipeline component in a coworking AI-assisted development system responsible for transforming abstract implementation plans and design documents into concrete, executable code artifacts. It implements the Stage trait to integrate seamlessly into the pipeline workflow and serves as the primary code generation engine of the system.\n\n## Core Business Logic Flow\n\nThe component operates through a sophisticated multi-phase process:\n\n1. **Initialization & Configuration**: Upon execution, the stage displays progress messages and loads LLM configuration from either a config.toml file or environment variables, then creates an LLM client instance for subsequent interactions.\n\n2. **Context Preparation**: Loads the implementation plan (plan.md) and design document (design.md) from previous iteration artifacts, combining them into a comprehensive context for the code generation process. It also ensures the workspace directory structure exists.\n\n3. **Structure Analysis Phase**: First requests the LLM to generate a complete file structure for the project, which includes a list of all files to create with their paths and descriptions. This structural planning ensures organized, maintainable code output.\n\n4. **File List Parsing**: Implements robust parsing logic to extract file paths and descriptions from the LLM response, supporting multiple formats including markdown lists, bullet points, and code blocks. It includes fallback strategies to handle various response structures.\n\n5. **Code Generation Phase**: For each identified file, generates complete, functional code using the LLM with tailored prompts that include the file path, description, and project context. The generation process handles streaming responses and accumulates the complete output.\n\n6. **Code Extraction & Cleaning**: Extracts code from markdown code blocks (handling ``` fences), cleans up formatting, and removes extraneous markers to produce clean source code.\n\n7. **Code Validation**: Performs basic syntax validation on generated code, including balanced braces/parentheses checks, language-specific structure validation (checking for functions, structs, classes based on file extension), and placeholder detection (TODO, FIXME, etc.).\n\n8. **File Persistence**: Creates necessary parent directories and writes validated code to the workspace, with proper error handling and user feedback for each file operation.\n\n9. **Summary Generation**: Creates a .generated_files.txt summary document listing all generated files with their line counts and generation timestamp.\n\n## Key Design Patterns\n\n- **Two-Phase Generation**: Separates structural planning from actual code generation to improve output quality\n- **Fallback Strategy**: If file list parsing fails, falls back to generating a single main.rs file\n- **Streaming Response Handling**: Processes LLM streaming responses incrementally for better user experience\n- **Error Resilience**: Continues processing even if individual file generations fail, reporting errors without aborting the entire operation\n- **Multi-format Parsing**: Supports various LLM response formats to handle non-deterministic AI outputs",
    "interfaces": [
      {
        "description": "Returns the stage identifier name 'coding'",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns a human-readable description of the stage's purpose",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns true indicating this stage requires user confirmation before execution",
        "interface_type": "method",
        "name": "needs_confirmation",
        "parameters": [],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Main execution method that orchestrates the entire code generation workflow from configuration loading to file writing",
        "interface_type": "async method",
        "name": "execute",
        "parameters": [
          {
            "description": "Pipeline execution context containing iteration details and workspace path",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": "Backend for displaying messages and interacting with the user",
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Loads and combines implementation plan and design documents from previous iteration artifacts into a single context string",
        "interface_type": "helper function",
        "name": "load_plan_document",
        "parameters": [
          {
            "description": "Pipeline context containing iteration information",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Parses file paths and descriptions from LLM response supporting multiple formats (markdown lists, bullet points, code blocks)",
        "interface_type": "helper function",
        "name": "parse_file_list",
        "parameters": [
          {
            "description": "LLM response text containing file structure information",
            "is_optional": false,
            "name": "text",
            "param_type": "&str"
          }
        ],
        "return_type": "Vec<(String, String)>",
        "visibility": "private"
      },
      {
        "description": "Validates whether a string looks like a valid file path by checking for extensions, invalid characters, and path structure",
        "interface_type": "helper function",
        "name": "is_valid_file_path",
        "parameters": [
          {
            "description": "String to validate as a file path",
            "is_optional": false,
            "name": "path",
            "param_type": "&str"
          }
        ],
        "return_type": "bool",
        "visibility": "private"
      },
      {
        "description": "Fallback extraction method that attempts to find file paths in unstructured text using pattern matching",
        "interface_type": "helper function",
        "name": "extract_files_from_text",
        "parameters": [
          {
            "description": "Text to extract file paths from",
            "is_optional": false,
            "name": "text",
            "param_type": "&str"
          }
        ],
        "return_type": "Vec<(String, String)>",
        "visibility": "private"
      },
      {
        "description": "Extracts clean code from markdown code blocks (``` fences) with fallback to return entire text if no blocks found",
        "interface_type": "helper function",
        "name": "extract_code",
        "parameters": [
          {
            "description": "LLM response containing code in markdown blocks",
            "is_optional": false,
            "name": "text",
            "param_type": "&str"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Performs basic syntax validation checking balanced braces/parentheses, language-specific structures, and placeholder patterns",
        "interface_type": "helper function",
        "name": "validate_code_syntax",
        "parameters": [
          {
            "description": "File path used to determine file extension for language-specific checks",
            "is_optional": false,
            "name": "file_path",
            "param_type": "&str"
          },
          {
            "description": "Generated code to validate",
            "is_optional": false,
            "name": "code",
            "param_type": "&str"
          }
        ],
        "return_type": "Vec<String>",
        "visibility": "private"
      },
      {
        "description": "Generates a markdown summary document listing all generated files with line counts and metadata",
        "interface_type": "helper function",
        "name": "generate_code_summary",
        "parameters": [
          {
            "description": "Path to workspace directory containing generated files",
            "is_optional": false,
            "name": "workspace_path",
            "param_type": "&std::path::Path"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Loads LLM configuration from config.toml file or environment variables with fallback strategies",
        "interface_type": "helper function",
        "name": "load_config",
        "parameters": [],
        "return_type": "anyhow::Result<ModelConfig>",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Orchestrate LLM-driven code generation by structuring requests, managing streaming responses, and transforming implementation plans into executable code artifacts",
      "Parse and manage file structure extraction from LLM responses, supporting multiple formats and implementing robust fallback strategies for non-deterministic AI outputs",
      "Perform code quality validation including syntax checks, language-specific structure verification, and placeholder detection to ensure generated code meets basic quality standards",
      "Handle workspace file system operations including directory creation, file writing, and artifact persistence with comprehensive error handling",
      "Integrate with the pipeline system by implementing the Stage trait, managing user interactions through progress messages, and coordinating with InteractiveBackend for status reporting"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\delivery.rs",
      "functions": [
        "DeliveryStage::name",
        "DeliveryStage::description",
        "DeliveryStage::execute",
        "load_artifact",
        "summarize_code",
        "load_config",
        "deliver_code_to_project",
        "deliver_recursive"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Stage",
        "InteractiveBackend"
      ],
      "name": "delivery.rs",
      "source_summary": "use std::sync::Arc;\n\nuse crate::interaction::InteractiveBackend;\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\nuse crate::llm::{ModelConfig, create_llm_client};\nuse adk_core::{Content, LlmRequest};\nuse futures::StreamExt;\n\n/// Delivery Stage - Generate final delivery report using LLM\npub struct DeliveryStage;\n\n#[async_trait::async_trait]\nimpl Stage for DeliveryStage {\n    fn name(&self) -> &str {\n        \"delivery\"\n    }\n\n    fn description(&self) -> &str {\n        \"Delivery - Generate completion report\"\n    }\n\n    async fn execute(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n    ) -> StageResult {\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"📦 Starting delivery phase...\".to_string(),\n            )\n            .await;\n\n        // Load LLM config\n        let config = match load_config() {\n            Ok(cfg) => cfg,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\n            }\n        };\n\n        // Create LLM client\n        let llm = match create_llm_client(&config.llm) {\n            Ok(client) => client,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\n            }\n        };\n\n        // Gather all artifacts\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"📚 Gathering artifacts from all stages...\".to_string(),\n            )\n            .await;\n\n        let idea_content = load_artifact(ctx, \"idea.md\");\n        let prd_content = load_artifact(ctx, \"prd.md\");\n        let design_content = load_artifact(ctx, \"design.md\");\n        let plan_content = load_artifact(ctx, \"plan.md\");\n        let check_content = load_artifact(ctx, \"check_report.md\");\n        let code_summary = summarize_code(ctx);\n\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"🤖 Generating delivery report with AI...\".to_string(),\n            )\n            .await;\n\n        // Generate delivery report using LLM\n        let prompt = format!(\n            r#\"You are a project manager. Create a comprehensive delivery report summarizing the completed iteration.\n\n**Iteration:** #{} - {}\n\n**Original Request:**\n{}\n\n**Idea:**\n{}\n\n**Requirements:**\n{}\n\n**Design:**\n{}\n\n**Implementation:**\n{}\n\n**Quality Check:**\n{}\n\n**Generated Files:**\n{}\n\nPlease create a comprehensive Delivery Report that includes:\n\n1. **Executive Summary** - What was accomplished in this iteration\n2. **Requirements Fulfilled** - List of completed requirements\n3. **Technical Implementation** - Summary of the solution\n4. **Key Features** - What functionality was implemented\n5. **Known Limitations** - Any known issues or incomplete features\n6. **Next Steps** - Recommendations for future iterations\n7. **Files Delivered** - List of all generated files with descriptions\n\nFormat as a professional project delivery document.\"#,\n            ctx.iteration.number,\n            ctx.iteration.title,\n            ctx.iteration.description,\n            idea_content,\n            prd_content,\n            design_content,\n            plan_content,\n            check_content,\n            code_summary\n        );\n\n        let content = Content::new(\"user\").with_text(prompt);\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\n        \n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"Generating delivery report...\".to_string(),\n            )\n            .await;\n\n        // Call LLM\n        let mut stream = match llm.generate_content(request, false).await {\n            Ok(resp) => resp,\n            Err(e) => {\n                return StageResult::Failed(format!(\"LLM report generation failed: {}\", e));\n            }\n        };\n\n        // Collect response from stream\n        let mut report_text = String::new();\n        while let Some(result) = stream.next().await {\n            match result {\n                Ok(response) => {\n                    if let Some(content) = response.content {\n                        for part in content.parts {\n                            if let Some(text) = part.text() {\n                                report_text.push_str(text);\n                            }\n                        }\n                    }\n                }\n                Err(_) => break,\n            }\n        }\n\n        if report_text.is_empty() {\n            report_text = \"# Delivery Report\\n\\nNo content generated.\".to_string();\n        }\n\n        // Write report to file\n        let artifact_path = format!(\n            \"{}/.cowork-v2/iterations/{}/artifacts/delivery_report.md\",\n            std::env::current_dir().unwrap().display(),\n            ctx.iteration.id\n        );\n\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\n            if let Err(e) = std::fs::create_dir_all(parent) {\n                return StageResult::Failed(format!(\"Failed to create directory: {}\", e));\n            }\n        }\n\n        let report = format!(\n            \"# Delivery Report\\n\\n**Iteration:** #{} - {}\\n\\n**Status:** ✅ Completed\\n\\n**Generated:** {}\\n\\n---\\n\\n{}\",\n            ctx.iteration.number,\n            ctx.iteration.title,\n            chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\n            report_text\n        );\n\n        if let Err(e) = std::fs::write(&artifact_path, report) {\n            return StageResult::Failed(format!(\"Failed to write delivery report: {}\", e));\n        }\n\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Success,\n                format!(\"📝 Delivery report generated: {}\", artifact_path),\n            )\n            .await;\n\n        // Deliver code to project directory\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"🚚 Delivering generated code to project directory...\".to_string(),\n            )\n            .await;\n\n        match deliver_code_to_project(&ctx.workspace_path).await {\n            Ok(delivered_files) => {\n                interaction\n                    .show_message(\n                        crate::interaction::MessageLevel::Success,\n                        format!(\"✅ Delivered {} files to project directory\", delivered_files),\n                    )\n                    .await;\n            }\n            Err(e) => {\n                interaction\n                    .show_message(\n                        crate::interaction::MessageLevel::Warning,\n                        format!(\"⚠️ Failed to deliver code to project directory: {}\", e),\n                    )\n                    .await;\n            }\n        }\n\n        // Final completion message\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Success,\n                format!(\"🎉 Iteration #{} '{}' completed successfully! All artifacts have been generated and delivered.\",\n                    ctx.iteration.number, ctx.iteration.title),\n            )\n            .await;\n\n        StageResult::Success(Some(artifact_path))\n    }\n}\n\n/// Load artifact content\nfn load_artifact(ctx: &PipelineContext, filename: &str) -> String {\n    let path = format!(\n        \"{}/.cowork-v2/iterations/{}/artifacts/{}\",\n        std::env::current_dir().unwrap().display(),\n        ctx.iteration.id,\n        filename\n    );\n\n    match std::fs::read_to_string(&path) {\n        Ok(content) => content,\n        Err(_) => format!(\"_{} not found_\", filename),\n    }\n}\n\n/// Summarize generated code\nfn summarize_code(ctx: &PipelineContext) -> String {\n    let mut summary = String::new();\n    \n    if let Ok(entries) = std::fs::read_dir(&ctx.workspace_path) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_file() {\n                let filename = path.file_name().unwrap_or_default().to_string_lossy();\n                let size = entry.metadata().map(|m| m.len()).unwrap_or(0);\n                summary.push_str(&format!(\"- {} ({} bytes)\\n\", filename, size));\n            }\n        }\n    }\n\n    if summary.is_empty() {\n        summary = \"_No code files generated_\".to_string();\n    }\n\n    summary\n}\n\n/// Load config from file or environment\nfn load_config() -> anyhow::Result<ModelConfig> {\n    use std::path::Path;\n    \n    if Path::new(\"config.toml\").exists() {\n        ModelConfig::from_file(\"config.toml\")\n    } else if let Ok(exe_path) = std::env::current_exe() {\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\n        let config_path = exe_dir.join(\"config.toml\");\n        if config_path.exists() {\n            ModelConfig::from_file(config_path.to_str().unwrap())\n        } else {\n            ModelConfig::from_env()\n        }\n    } else {\n        ModelConfig::from_env()\n    }\n}\n\n/// Deliver code from workspace to project root directory\nasync fn deliver_code_to_project(workspace_path: &std::path::Path) -> anyhow::Result<usize> {\n    let project_root = std::env::current_dir()?;\n    let mut delivered_count = 0;\n    \n    // Directories and files to exclude from delivery\n    let exclude_dirs: &[&str] = &[\n        \".cowork-v2\",\n        \".cowork\",\n        \".git\",\n        \"node_modules\",\n        \"target\",\n        \"dist\",\n        \"build\",\n        \".idea\",\n        \".vscode\",\n    ];\n    \n    let exclude_files: &[&str] = &[\n        \".DS_Store\",\n        \"Thumbs.db\",\n        \".gitignore\",\n    ];\n    \n    if !workspace_path.exists() {\n        return Ok(0);\n    }\n    \n    deliver_recursive(\n        workspace_path,\n        &project_root,\n        exclude_dirs,\n        exclude_files,\n        &mut delivered_count,\n    ).await?;\n    \n    Ok(delivered_count)\n}\n\nasync fn deliver_recursive(\n    src: &std::path::Path,\n    dst: &std::path::Path,\n    exclude_dirs: &[&str],\n    exclude_files: &[&str],\n    count: &mut usize,\n) -> anyhow::Result<()> {\n    use tokio::fs;\n    \n    let mut entries = fs::read_dir(src).await?;\n    \n    while let Some(entry) = entries.next_entry().await? {\n        let src_path = entry.path();\n        let file_name = entry.file_name();\n        let file_name_str = file_name.to_string_lossy();\n        \n        // Skip excluded directories and files\n        if src_path.is_dir() && exclude_dirs.contains(&file_name_str.as_ref()) {\n            continue;\n        }\n        \n        if src_path.is_file() && exclude_files.contains(&file_name_str.as_ref()) {\n            continue;\n        }\n        \n        let dst_path = dst.join(&file_name);\n        \n        if src_path.is_dir() {\n            // Create directory if it doesn't exist\n            if !dst_path.exists() {\n                fs::create_dir_all(&dst_path).await?;\n            }\n            // Recursively process subdirectory\n            Box::pin(deliver_recursive(\n                &src_path,\n                &dst_path,\n                exclude_dirs,\n                exclude_files,\n                count,\n            )).await?;\n        } else {\n            // Copy file\n            fs::copy(&src_path, &dst_path).await?;\n            *count += 1;\n        }\n    }\n    \n    Ok(())\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 31.0,
      "lines_of_code": 375,
      "number_of_classes": 1,
      "number_of_functions": 8
    },
    "dependencies": [
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::interaction::InteractiveBackend",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::PipelineContext",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::Stage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::StageResult",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::llm::ModelConfig",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "crate::llm::create_llm_client",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "adk_core::Content",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "adk_core::LlmRequest",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "futures::StreamExt",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "async_trait::async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "tokio::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "std::env",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "std::path",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The DeliveryStage component is responsible for generating a comprehensive AI-powered delivery report after a development iteration and delivering the generated code artifacts to the project directory. It orchestrates the entire delivery workflow by first gathering artifacts from previous stages (idea.md, prd.md, design.md, plan.md, check_report.md), summarizing generated code files, then using an LLM to generate a professional delivery report based on a structured prompt. The generated report is written to a designated file path with metadata about the iteration. Finally, it recursively copies all generated code files from the workspace directory to the project root directory while excluding common system and build artifacts. The stage provides real-time feedback through an interactive backend, showing progress messages at each step. This component acts as the final output generator and delivery mechanism in the pipeline.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "trait",
        "name": "Stage",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Generate AI-powered delivery report using LLM based on gathered iteration artifacts",
      "Write the generated report to a structured file path with metadata",
      "Recursively deliver generated code files from workspace to project root directory",
      "Handle errors gracefully with user-friendly feedback via interactive backend",
      "Manage configuration loading from file or environment variables"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\design.rs",
      "functions": [
        "load_prd_document",
        "load_config"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "name",
        "description",
        "needs_confirmation",
        "execute"
      ],
      "name": "design.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\nuse futures::StreamExt;\r\n\r\n/// Design Stage - Create technical design using LLM\r\npub struct DesignStage;\r\n\r\n#[async_trait::async_trait]\r\nimpl Stage for DesignStage {\r\n    fn name(&self) -> &str {\r\n        \"design\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Design - Create technical architecture\"\r\n    }\r\n\r\n    fn needs_confirmation(&self) -> bool {\r\n        true\r\n    }\r\n\r\n    async fn execute(\r\n        &self,\r\n        ctx: &PipelineContext,\r\n        interaction: Arc<dyn InteractiveBackend>,\r\n    ) -> StageResult {\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Creating technical design with AI...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Load LLM config\r\n        let config = match load_config() {\r\n            Ok(cfg) => cfg,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Create LLM client\r\n        let llm = match create_llm_client(&config.llm) {\r\n            Ok(client) => client,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Load PRD document\r\n        let prd_content = load_prd_document(ctx);\r\n\r\n        // Prepare artifact path\r\n        let artifact_path = format!(\r\n            \"{}/.cowork-v2/iterations/{}/artifacts/design.md\",\r\n            std::env::current_dir().unwrap().display(),\r\n            ctx.iteration.id\r\n        );\r\n\r\n        // Ensure directory exists\r\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\r\n            if let Err(e) = std::fs::create_dir_all(parent) {\r\n                return StageResult::Failed(format!(\"Failed to create directory: {}\", e));\r\n            }\r\n        }\r\n\r\n        // Generate Design using LLM\r\n        let prompt = format!(\r\n            r#\"You are a software architect. Create a comprehensive technical design document based on the PRD.\r\n\r\n**Iteration:** #{} - {}\r\n\r\n{}\r\n\r\nPlease create a detailed Technical Design Document that includes:\r\n\r\n1. **Architecture Overview** - High-level system architecture\r\n2. **Component Design** - Key components and their responsibilities\r\n3. **Data Model** - Database schemas, entities, relationships\r\n4. **API Design** - REST/GraphQL endpoints, request/response formats\r\n5. **Technology Stack** - Recommended technologies and frameworks\r\n6. **Security Design** - Authentication, authorization, data protection\r\n7. **Performance Considerations** - Caching, optimization strategies\r\n8. **Integration Points** - External services and APIs\r\n9. **Deployment Architecture** - Infrastructure requirements\r\n\r\nWrite the response in professional Markdown format with code examples where appropriate.\"#,\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            prd_content\r\n        );\r\n\r\n        let content = Content::new(\"user\").with_text(prompt);\r\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\r\n        \r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Generating design document...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Call LLM\r\n        let mut stream = match llm.generate_content(request, false).await {\r\n            Ok(resp) => resp,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"LLM generation failed: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Collect response from stream\r\n        let mut generated_text = String::new();\r\n        while let Some(result) = stream.next().await {\r\n            match result {\r\n                Ok(response) => {\r\n                    if let Some(content) = response.content {\r\n                        for part in content.parts {\r\n                            if let Some(text) = part.text() {\r\n                                generated_text.push_str(text);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                Err(_) => break,\r\n            }\r\n        }\r\n\r\n        if generated_text.is_empty() {\r\n            generated_text = \"# Design\\n\\nNo content generated.\".to_string();\r\n        }\r\n\r\n        // Write to file\r\n        let design_content = format!(\r\n            \"# Technical Design Document\\n\\n**Iteration:** #{} - {}\\n\\n**Generated:** {}\\n\\n---\\n\\n{}\",\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\r\n            generated_text\r\n        );\r\n\r\n        if let Err(e) = std::fs::write(&artifact_path, design_content) {\r\n            return StageResult::Failed(format!(\"Failed to write design file: {}\", e));\r\n        }\r\n\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Success,\r\n                format!(\"Design document generated: {}\", artifact_path),\r\n            )\r\n            .await;\r\n\r\n        StageResult::Success(Some(artifact_path))\r\n    }\r\n}\r\n\r\n/// Load PRD document\r\nfn load_prd_document(ctx: &PipelineContext) -> String {\r\n    let prd_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/prd.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    match std::fs::read_to_string(&prd_path) {\r\n        Ok(content) => format!(\"**PRD Document:**\\n{}\", content),\r\n        Err(_) => {\r\n            // Fallback to description if PRD not found\r\n            format!(\r\n                \"**Requirements:**\\nBased on: {}\",\r\n                ctx.iteration.description\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 197,
      "number_of_classes": 1,
      "number_of_functions": 2
    },
    "dependencies": [
      {
        "dependency_type": "standard_library",
        "is_external": true,
        "line_number": 1,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 3,
        "name": "crate::interaction",
        "path": "crates/cowork-core/src/interaction",
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 4,
        "name": "crate::pipeline",
        "path": "crates/cowork-core/src/pipeline",
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 5,
        "name": "crate::llm",
        "path": "crates/cowork-core/src/llm",
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 6,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 7,
        "name": "futures",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 11,
        "name": "async_trait",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The DesignStage component is a pipeline stage responsible for automatically generating comprehensive technical design documents using Large Language Models (LLMs). It transforms Product Requirements Documents (PRDs) created in earlier pipeline stages into detailed technical design specifications.\n\nThe component implements the Stage trait from the pipeline framework and orchestrates a complete design generation workflow:\n1. Initialization: Displays progress messages to users through the interactive backend\n2. Configuration Loading: Retrieves LLM configuration from config.toml or environment variables with fallback mechanisms\n3. LLM Client Creation: Instantiates an LLM client using the loaded configuration\n4. PRD Document Loading: Reads the PRD markdown file from the previous pipeline stage's artifacts, with fallback to iteration description if unavailable\n5. Artifact Preparation: Ensures the output directory exists and prepares the artifact path for design.md\n6. Prompt Construction: Builds a comprehensive prompt requesting the LLM to create architecture overview, component design, data models, API design, technology stack recommendations, security considerations, performance strategies, integration points, and deployment architecture\n7. LLM Generation: Calls the LLM with the prepared prompt and streams the response\n8. Response Collection: Accumulates the generated text from the streaming response\n9. Artifact Persistence: Writes the formatted design document with metadata (iteration number, title, generation timestamp) to the artifact file\n10. Completion: Provides success feedback to users with the artifact path\n\nThe component requires user confirmation before execution and follows a structured markdown format for output, ensuring consistency with other pipeline stages.",
    "interfaces": [
      {
        "description": "Returns the stage identifier 'design'",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns the stage description 'Design - Create technical architecture'",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns true indicating this stage requires user confirmation before execution",
        "interface_type": "method",
        "name": "needs_confirmation",
        "parameters": [],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Main execution method that orchestrates the design document generation workflow",
        "interface_type": "async_method",
        "name": "execute",
        "parameters": [
          {
            "description": "Pipeline context containing iteration information",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": "Interactive backend for user communication",
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Loads PRD document from artifacts or falls back to iteration description",
        "interface_type": "function",
        "name": "load_prd_document",
        "parameters": [
          {
            "description": "Pipeline context for iteration ID",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Loads LLM configuration from config.toml file or environment variables with multiple fallback strategies",
        "interface_type": "function",
        "name": "load_config",
        "parameters": [],
        "return_type": "anyhow::Result<ModelConfig>",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Generate technical design documents using LLM capabilities by transforming PRD requirements into comprehensive technical specifications",
      "Manage document lifecycle including loading PRD artifacts from previous stages, creating output directories, and persisting generated design documents with metadata",
      "Handle LLM integration including configuration management from multiple sources (file and environment), client creation, prompt engineering, and streaming response processing",
      "Provide user interaction and feedback through the interactive backend, including progress messages, status updates, and completion notifications",
      "Implement comprehensive error handling for configuration loading, LLM client creation, file system operations, and LLM generation failures"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\idea.rs",
      "functions": [
        "IdeaStage::name",
        "IdeaStage::description",
        "IdeaStage::execute",
        "IdeaStage::execute_with_feedback",
        "IdeaStage::generate_idea",
        "load_config"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Stage",
        "InteractiveBackend",
        "PipelineContext",
        "ModelConfig",
        "LlmRequest",
        "Content"
      ],
      "name": "idea.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\n\r\n/// Idea Stage - Capture and structure user requirements using LLM\r\npub struct IdeaStage;\r\n\r\n#[async_trait::async_trait]\nimpl Stage for IdeaStage {\n    fn name(&self) -> &str {\n        \"idea\"\n    }\n\n    fn description(&self) -> &str {\n        \"Idea - Capture and structure requirements\"\n    }\n\n    async fn execute(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n    ) -> StageResult {\n        self.generate_idea(ctx, interaction, None).await\n    }\n\n    async fn execute_with_feedback(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n        feedback: &str,\n    ) -> StageResult {\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"Regenerating idea document based on your feedback...\".to_string(),\n            )\n            .await;\n        self.generate_idea(ctx, interaction, Some(feedback)).await\n    }\n}\n\nimpl IdeaStage {\n    async fn generate_idea(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n        feedback: Option<&str>,\n    ) -> StageResult {\n        // Load LLM config\n        let config = match load_config() {\n            Ok(cfg) => cfg,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\n            }\n        };\n\n        // Create LLM client\n        let llm = match create_llm_client(&config.llm) {\n            Ok(client) => client,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\n            }\n        };\n\n        // Prepare artifact path\n        let artifact_path = format!(\n            \"{}/.cowork-v2/iterations/{}/artifacts/idea.md\",\n            std::env::current_dir().unwrap().display(),\n            ctx.iteration.id\n        );\n\n        // Ensure directory exists\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\n            if let Err(e) = std::fs::create_dir_all(parent) {\n                return StageResult::Failed(format!(\"Failed to create directory: {}\", e));\n            }\n        }\n\n        // Build prompt\n        let prompt = if let Some(feedback_text) = feedback {\n            format!(\n                r#\"You are a product analyst. Please REVISE the idea document based on the following user feedback.\n\n**Original Request:**\n{}\n\n**User Feedback for Revision:**\n{}\n\nPlease create an IMPROVED idea document addressing the feedback. Include:\n1. Problem Statement - What problem are we solving?\n2. Target Users - Who will use this?\n3. Core Features - What are the main features?\n4. Success Criteria - How do we measure success?\n5. Constraints - Any limitations or requirements?\n\nWrite the response in Markdown format.\"#,\n                ctx.iteration.description,\n                feedback_text\n            )\n        } else {\n            format!(\n                r#\"You are a product analyst. Based on the following user request, create a structured idea document.\n\nUser Request: {}\n\nPlease analyze this request and create a comprehensive idea document that includes:\n1. Problem Statement - What problem are we solving?\n2. Target Users - Who will use this?\n3. Core Features - What are the main features?\n4. Success Criteria - How do we measure success?\n5. Constraints - Any limitations or requirements?\n\nWrite the response in Markdown format.\"#,\n                ctx.iteration.description\n            )\n        };\n\n        let content = Content::new(\"user\").with_text(prompt);\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\n        \n        let status_msg = if feedback.is_some() {\n            \"Regenerating idea document with your feedback...\"\n        } else {\n            \"Generating idea document...\"\n        };\n        \n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                status_msg.to_string(),\n            )\n            .await;\n\n        // Call LLM\n        let mut stream = match llm.generate_content(request, false).await {\n            Ok(resp) => resp,\n            Err(e) => {\n                return StageResult::Failed(format!(\"LLM generation failed: {}\", e));\n            }\n        };\n\n        // Collect response from stream\n        use futures::StreamExt;\n        let mut generated_text = String::new();\n        while let Some(result) = stream.next().await {\n            match result {\n                Ok(response) => {\n                    if let Some(content) = response.content {\n                        for part in content.parts {\n                            if let Some(text) = part.text() {\n                                generated_text.push_str(text);\n                            }\n                        }\n                    }\n                }\n                Err(_) => break,\n            }\n        }\n\n        if generated_text.is_empty() {\n            generated_text = \"# Idea\\n\\nNo content generated.\".to_string();\n        }\n\n        // Write to file\n        let header = if feedback.is_some() {\n            format!(\"# Idea Document (Revised)\\n\\n**Iteration:** #{} - {}\\n\\n**Original Request:**\\n{}\\n\\n**Applied Feedback:**\\n{}\\n\\n---\\n\\n\", \n                ctx.iteration.number,\n                ctx.iteration.title,\n                ctx.iteration.description,\n                feedback.unwrap()\n            )\n        } else {\n            format!(\"# Idea Document\\n\\n**Iteration:** #{} - {}\\n\\n**Original Request:**\\n{}\\n\\n---\\n\\n\", \n                ctx.iteration.number,\n                ctx.iteration.title,\n                ctx.iteration.description\n            )\n        };\n        \n        let idea_content = format!(\"{}{}\", header, generated_text);\n\n        if let Err(e) = std::fs::write(&artifact_path, idea_content) {\n            return StageResult::Failed(format!(\"Failed to write idea file: {}\", e));\n        }\n\n        let success_msg = if feedback.is_some() {\n            format!(\"Idea document revised: {}\", artifact_path)\n        } else {\n            format!(\"Idea document generated: {}\", artifact_path)\n        };\n        \n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Success,\n                success_msg,\n            )\n            .await;\n\n        StageResult::Success(Some(artifact_path))\n    }\n}\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    // Try loading from config.toml\r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 22.0,
      "lines_of_code": 225,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "language_stdlib",
        "is_external": true,
        "line_number": null,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 6,
        "name": "crate::interaction::InteractiveBackend",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 7,
        "name": "crate::pipeline::PipelineContext",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 7,
        "name": "crate::pipeline::Stage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 7,
        "name": "crate::pipeline::StageResult",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 8,
        "name": "crate::llm::ModelConfig",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 8,
        "name": "crate::llm::create_llm_client",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 9,
        "name": "adk_core::Content",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal_module",
        "is_external": false,
        "line_number": 9,
        "name": "adk_core::LlmRequest",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 11,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 156,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external_crate",
        "is_external": true,
        "line_number": 133,
        "name": "futures",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "language_stdlib",
        "is_external": true,
        "line_number": 41,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "language_stdlib",
        "is_external": true,
        "line_number": 157,
        "name": "std::path",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "language_stdlib",
        "is_external": true,
        "line_number": 40,
        "name": "std::env",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The IdeaStage component is responsible for generating or revising a structured idea document using an LLM (Large Language Model) based on user input. It captures the user's initial request or feedback, formats it into a detailed prompt, invokes an LLM client to generate a comprehensive Markdown document covering problem statement, target users, core features, success criteria, and constraints. The generated content is then saved to a file in the project's iteration artifacts directory with appropriate headers and metadata. This component acts as a bridge between user requirements and structured documentation, enabling automated requirement elicitation and documentation in a product development pipeline.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "trait",
        "name": "Stage",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "show_message",
            "param_type": "MessageLevel"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "message",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "PipelineContext",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "iteration",
            "param_type": "Iteration"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ModelConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "llm",
            "param_type": "LlmConfig"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "LlmRequest",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model_name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "Vec<Content>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "Content",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "role",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "text",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Generate structured idea document from user request using LLM",
      "Revise existing idea document based on user feedback",
      "Handle file system operations for artifact storage",
      "Manage LLM client lifecycle and error handling",
      "Provide user feedback via interactive backend"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\plan.rs",
      "functions": [
        "execute",
        "load_design_document",
        "load_config",
        "name",
        "description",
        "needs_confirmation"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Stage",
        "InteractiveBackend"
      ],
      "name": "plan.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\nuse futures::StreamExt;\r\n\r\n/// Plan Stage - Create implementation plan using LLM\r\npub struct PlanStage;\r\n\r\n#[async_trait::async_trait]\r\nimpl Stage for PlanStage {\r\n    fn name(&self) -> &str {\r\n        \"plan\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Plan - Create implementation tasks\"\r\n    }\r\n\r\n    fn needs_confirmation(&self) -> bool {\r\n        true\r\n    }\r\n\r\n    async fn execute(\r\n        &self,\r\n        ctx: &PipelineContext,\r\n        interaction: Arc<dyn InteractiveBackend>,\r\n    ) -> StageResult {\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Creating implementation plan with AI...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Load LLM config\r\n        let config = match load_config() {\r\n            Ok(cfg) => cfg,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Create LLM client\r\n        let llm = match create_llm_client(&config.llm) {\r\n            Ok(client) => client,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Load design document\r\n        let design_content = load_design_document(ctx);\r\n\r\n        // Prepare artifact path\r\n        let artifact_path = format!(\r\n            \"{}/.cowork-v2/iterations/{}/artifacts/plan.md\",\r\n            std::env::current_dir().unwrap().display(),\r\n            ctx.iteration.id\r\n        );\r\n\r\n        // Ensure directory exists\r\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\r\n            if let Err(e) = std::fs::create_dir_all(parent) {\r\n                return StageResult::Failed(format!(\"Failed to create directory: {}\", e));\r\n            }\r\n        }\r\n\r\n        // Generate Implementation Plan using LLM\r\n        let prompt = format!(\r\n            r#\"You are a technical lead. Create a detailed implementation plan based on the design document.\r\n\r\n**Iteration:** #{} - {}\r\n\r\n{}\r\n\r\nPlease create a comprehensive Implementation Plan that includes:\r\n\r\n1. **Overview** - Summary of what needs to be built\r\n2. **Task Breakdown** - Detailed list of development tasks\r\n   - Task ID, Description, Estimated effort\r\n   - Dependencies between tasks\r\n3. **File Structure** - Recommended project structure with file paths\r\n4. **Implementation Order** - Sequence of tasks with priorities\r\n5. **Key Algorithms/Logic** - Pseudocode or logic description for complex parts\r\n6. **Testing Strategy** - How to verify each component\r\n7. **Risk Mitigation** - Potential issues and solutions\r\n8. **Definition of Done** - Criteria for completing this iteration\r\n\r\nFormat the plan as a Markdown document with clear sections and checklists.\"#,\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            design_content\r\n        );\r\n\r\n        let content = Content::new(\"user\").with_text(prompt);\r\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\r\n        \r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Info,\r\n                \"Generating implementation plan...\".to_string(),\r\n            )\r\n            .await;\r\n\r\n        // Call LLM\r\n        let mut stream = match llm.generate_content(request, false).await {\r\n            Ok(resp) => resp,\r\n            Err(e) => {\r\n                return StageResult::Failed(format!(\"LLM generation failed: {}\", e));\r\n            }\r\n        };\r\n\r\n        // Collect response from stream\r\n        let mut generated_text = String::new();\r\n        while let Some(result) = stream.next().await {\r\n            match result {\r\n                Ok(response) => {\r\n                    if let Some(content) = response.content {\r\n                        for part in content.parts {\r\n                            if let Some(text) = part.text() {\r\n                                generated_text.push_str(text);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                Err(_) => break,\r\n            }\r\n        }\r\n\r\n        if generated_text.is_empty() {\r\n            generated_text = \"# Implementation Plan\\n\\nNo content generated.\".to_string();\r\n        }\r\n\r\n        // Write to file\r\n        let plan_content = format!(\r\n            \"# Implementation Plan\\n\\n**Iteration:** #{} - {}\\n\\n**Generated:** {}\\n\\n---\\n\\n{}\",\r\n            ctx.iteration.number,\r\n            ctx.iteration.title,\r\n            chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\r\n            generated_text\r\n        );\r\n\r\n        if let Err(e) = std::fs::write(&artifact_path, plan_content) {\r\n            return StageResult::Failed(format!(\"Failed to write plan file: {}\", e));\r\n        }\r\n\r\n        interaction\r\n            .show_message(\r\n                crate::interaction::MessageLevel::Success,\r\n                format!(\"Implementation plan generated: {}\", artifact_path),\r\n            )\r\n            .await;\r\n\r\n        StageResult::Success(Some(artifact_path))\r\n    }\r\n}\r\n\r\n/// Load design document\r\nfn load_design_document(ctx: &PipelineContext) -> String {\r\n    let design_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/design.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    let prd_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/prd.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    let mut result = String::new();\r\n\r\n    if let Ok(content) = std::fs::read_to_string(&design_path) {\r\n        result.push_str(&format!(\"**Design Document:**\\n{}\\n\\n\", content));\r\n    }\r\n\r\n    if let Ok(content) = std::fs::read_to_string(&prd_path) {\r\n        result.push_str(&format!(\"**PRD Document:**\\n{}\\n\\n\", content));\r\n    }\r\n\r\n    if result.is_empty() {\r\n        result = format!(\"**Requirements:**\\n{}\", ctx.iteration.description);\r\n    }\r\n\r\n    result\r\n}\r\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 22.0,
      "lines_of_code": 209,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "standard-library",
        "is_external": true,
        "line_number": 1,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal-module",
        "is_external": false,
        "line_number": 3,
        "name": "crate::interaction",
        "path": "interaction",
        "version": null
      },
      {
        "dependency_type": "internal-module",
        "is_external": false,
        "line_number": 4,
        "name": "crate::pipeline",
        "path": "pipeline",
        "version": null
      },
      {
        "dependency_type": "internal-module",
        "is_external": false,
        "line_number": 5,
        "name": "crate::llm",
        "path": "llm",
        "version": null
      },
      {
        "dependency_type": "external-crate",
        "is_external": true,
        "line_number": 6,
        "name": "adk_core",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "external-crate",
        "is_external": true,
        "line_number": 7,
        "name": "futures",
        "path": "futures",
        "version": null
      },
      {
        "dependency_type": "external-crate",
        "is_external": true,
        "line_number": 10,
        "name": "async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "external-crate",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": "chrono",
        "version": null
      }
    ],
    "detailed_description": "The PlanStage is a critical pipeline stage responsible for generating comprehensive implementation plans using Large Language Models (LLM). It operates within a pipeline architecture where it receives design documents and PRDs from previous stages, orchestrates an AI-driven planning process, and produces detailed markdown-formatted implementation artifacts.\n\n## Functional Description\n\nThe component's main workflow consists of:\n1. **Configuration Loading**: Dynamically loads LLM configuration from config.toml files or environment variables, with fallback logic checking multiple potential file locations\n2. **Design Context Assembly**: Retrieves and combines design.md and prd.md artifacts from previous pipeline iterations, or falls back to iteration descriptions if artifacts don't exist\n3. **LLM Prompt Engineering**: Constructs a detailed, structured prompt requesting the AI to create implementation plans with specific sections (overview, task breakdown, file structure, implementation order, algorithms, testing strategy, risk mitigation, and definition of done)\n4. **Streaming Response Handling**: Manages asynchronous streaming responses from the LLM client, collecting text chunks incrementally\n5. **Artifact Generation**: Writes formatted markdown artifacts to the filesystem under .cowork-v2/iterations/{id}/artifacts/plan.md with metadata including iteration number, title, and generation timestamp\n6. **Interactive Feedback**: Provides real-time status updates to users through an interactive backend interface\n\nThe stage requires user confirmation before execution and can fail gracefully with descriptive error messages at any stage of the process.",
    "interfaces": [
      {
        "description": "Pipeline stage trait requiring name, description, needs_confirmation, and execute methods",
        "interface_type": "trait",
        "name": "Stage",
        "parameters": [
          {
            "description": "Shared pipeline context containing iteration information",
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": "Interactive backend for user communication",
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Main execution method implementing the plan generation workflow",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "interaction",
            "param_type": "Arc<dyn InteractiveBackend>"
          }
        ],
        "return_type": "StageResult",
        "visibility": "public"
      },
      {
        "description": "Loads design.md and prd.md artifacts or returns iteration description as fallback",
        "interface_type": "function",
        "name": "load_design_document",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "ctx",
            "param_type": "&PipelineContext"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      },
      {
        "description": "Loads ModelConfig from config.toml or environment variables with fallback logic",
        "interface_type": "function",
        "name": "load_config",
        "parameters": [],
        "return_type": "anyhow::Result<ModelConfig>",
        "visibility": "private"
      },
      {
        "description": "Returns stage identifier string",
        "interface_type": "method",
        "name": "name",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns stage description string",
        "interface_type": "method",
        "name": "description",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Indicates whether stage requires user confirmation before execution",
        "interface_type": "method",
        "name": "needs_confirmation",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "bool",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Generate AI-driven implementation plans using LLM integration",
      "Load and combine design artifacts (design.md, prd.md) as planning context",
      "Manage LLM configuration from multiple sources (file, environment)",
      "Create and persist structured implementation plan artifacts",
      "Provide real-time user feedback during plan generation process"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\prd.rs",
      "functions": [
        "PrdStage::name",
        "PrdStage::description",
        "PrdStage::needs_confirmation",
        "PrdStage::execute",
        "PrdStage::execute_with_feedback",
        "PrdStage::generate_prd",
        "load_idea_document",
        "load_config"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Stage",
        "InteractiveBackend"
      ],
      "name": "prd.rs",
      "source_summary": "use std::sync::Arc;\r\n\r\nuse crate::interaction::InteractiveBackend;\r\nuse crate::pipeline::{PipelineContext, Stage, StageResult};\r\nuse crate::llm::{ModelConfig, create_llm_client};\r\nuse adk_core::{Content, LlmRequest};\r\nuse futures::StreamExt;\r\n\r\n/// PRD Stage - Generate Product Requirements Document using LLM\r\npub struct PrdStage;\r\n\r\n#[async_trait::async_trait]\nimpl Stage for PrdStage {\n    fn name(&self) -> &str {\n        \"prd\"\n    }\n\n    fn description(&self) -> &str {\n        \"PRD - Generate product requirements\"\n    }\n\n    fn needs_confirmation(&self) -> bool {\n        true\n    }\n\n    async fn execute(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n    ) -> StageResult {\n        self.generate_prd(ctx, interaction, None).await\n    }\n\n    async fn execute_with_feedback(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n        feedback: &str,\n    ) -> StageResult {\n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                \"Regenerating PRD based on your feedback...\".to_string(),\n            )\n            .await;\n        self.generate_prd(ctx, interaction, Some(feedback)).await\n    }\n}\n\nimpl PrdStage {\n    async fn generate_prd(\n        &self,\n        ctx: &PipelineContext,\n        interaction: Arc<dyn InteractiveBackend>,\n        feedback: Option<&str>,\n    ) -> StageResult {\n        // Load LLM config\n        let config = match load_config() {\n            Ok(cfg) => cfg,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to load config: {}\", e));\n            }\n        };\n\n        // Create LLM client\n        let llm = match create_llm_client(&config.llm) {\n            Ok(client) => client,\n            Err(e) => {\n                return StageResult::Failed(format!(\"Failed to create LLM client: {}\", e));\n            }\n        };\n\n        // Load idea document if exists\n        let idea_content = load_idea_document(ctx);\n\n        // Prepare artifact path\n        let artifact_path = format!(\n            \"{}/.cowork-v2/iterations/{}/artifacts/prd.md\",\n            std::env::current_dir().unwrap().display(),\n            ctx.iteration.id\n        );\n\n        // Ensure directory exists\n        if let Some(parent) = std::path::Path::new(&artifact_path).parent() {\n            if let Err(e) = std::fs::create_dir_all(parent) {\n                return StageResult::Failed(format!(\"Failed to create directory: {}\", e));\n            }\n        }\n\n        // Build prompt\n        let prompt = if let Some(feedback_text) = feedback {\n            format!(\n                r#\"You are a product manager. Please REVISE the Product Requirements Document (PRD) based on the following user feedback.\n\n**Iteration:** #{} - {}\n\n**Original Request:**\n{}\n\n{}\n\n**User Feedback for Revision:**\n{}\n\nPlease create an IMPROVED PRD addressing the feedback. Include:\n\n1. **Overview** - Brief summary of the product/feature\n2. **Goals** - What we want to achieve\n3. **User Stories** - As a [user], I want [feature] so that [benefit]\n4. **Functional Requirements** - Detailed list of features and behaviors\n5. **Non-Functional Requirements** - Performance, security, usability requirements\n6. **UI/UX Requirements** - Interface guidelines and user experience expectations\n7. **Data Requirements** - Data models, storage needs\n8. **API Requirements** - External/internal API specifications\n9. **Open Questions** - Issues that need clarification\n\nWrite the response in professional Markdown format suitable for a technical team.\"#,\n                ctx.iteration.number,\n                ctx.iteration.title,\n                ctx.iteration.description,\n                idea_content,\n                feedback_text\n            )\n        } else {\n            format!(\n                r#\"You are a product manager. Create a comprehensive Product Requirements Document (PRD) based on the following information.\n\n**Iteration:** #{} - {}\n\n**Original Request:**\n{}\n\n{}\n\nPlease create a detailed PRD that includes:\n\n1. **Overview** - Brief summary of the product/feature\n2. **Goals** - What we want to achieve\n3. **User Stories** - As a [user], I want [feature] so that [benefit]\n4. **Functional Requirements** - Detailed list of features and behaviors\n5. **Non-Functional Requirements** - Performance, security, usability requirements\n6. **UI/UX Requirements** - Interface guidelines and user experience expectations\n7. **Data Requirements** - Data models, storage needs\n8. **API Requirements** - External/internal API specifications\n9. **Open Questions** - Issues that need clarification\n\nWrite the response in professional Markdown format suitable for a technical team.\"#,\n                ctx.iteration.number,\n                ctx.iteration.title,\n                ctx.iteration.description,\n                idea_content\n            )\n        };\n\n        let content = Content::new(\"user\").with_text(prompt);\n        let request = LlmRequest::new(&config.llm.model_name, vec![content]);\n        \n        let status_msg = if feedback.is_some() {\n            \"Regenerating PRD with your feedback...\"\n        } else {\n            \"Generating PRD...\"\n        };\n        \n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Info,\n                status_msg.to_string(),\n            )\n            .await;\n\n        // Call LLM\n        let mut stream = match llm.generate_content(request, false).await {\n            Ok(resp) => resp,\n            Err(e) => {\n                return StageResult::Failed(format!(\"LLM generation failed: {}\", e));\n            }\n        };\n\n        // Collect response from stream\n        let mut generated_text = String::new();\n        while let Some(result) = stream.next().await {\n            match result {\n                Ok(response) => {\n                    if let Some(content) = response.content {\n                        for part in content.parts {\n                            if let Some(text) = part.text() {\n                                generated_text.push_str(text);\n                            }\n                        }\n                    }\n                }\n                Err(_) => break,\n            }\n        }\n\n        if generated_text.is_empty() {\n            generated_text = \"# PRD\\n\\nNo content generated.\".to_string();\n        }\n\n        // Write to file\n        let header = if feedback.is_some() {\n            format!(\"# Product Requirements Document (PRD) - Revised\\n\\n**Iteration:** #{} - {}\\n\\n**Generated:** {}\\n\\n**Applied Feedback:**\\n{}\\n\\n---\\n\\n\",\n                ctx.iteration.number,\n                ctx.iteration.title,\n                chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\n                feedback.unwrap()\n            )\n        } else {\n            format!(\"# Product Requirements Document (PRD)\\n\\n**Iteration:** #{} - {}\\n\\n**Generated:** {}\\n\\n---\\n\\n\",\n                ctx.iteration.number,\n                ctx.iteration.title,\n                chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\")\n            )\n        };\n        \n        let prd_content = format!(\"{}{}\", header, generated_text);\n\n        if let Err(e) = std::fs::write(&artifact_path, prd_content) {\n            return StageResult::Failed(format!(\"Failed to write PRD file: {}\", e));\n        }\n\n        let success_msg = if feedback.is_some() {\n            format!(\"PRD revised: {}\", artifact_path)\n        } else {\n            format!(\"PRD generated: {}\", artifact_path)\n        };\n        \n        interaction\n            .show_message(\n                crate::interaction::MessageLevel::Success,\n                success_msg,\n            )\n            .await;\n\n        StageResult::Success(Some(artifact_path))\n    }\n}\n\r\n/// Load idea document if exists\r\nfn load_idea_document(ctx: &PipelineContext) -> String {\r\n    let idea_path = format!(\r\n        \"{}/.cowork-v2/iterations/{}/artifacts/idea.md\",\r\n        std::env::current_dir().unwrap().display(),\r\n        ctx.iteration.id\r\n    );\r\n\r\n    if let Ok(content) = std::fs::read_to_string(&idea_path) {\r\n        format!(\"\\n**Idea Document:**\\n{}\", content)\r\n    } else {\r\n        String::new()\r\n    }\r\n}\r\n\r\n/// Load config from file or environment\r\nfn load_config() -> anyhow::Result<ModelConfig> {\r\n    use std::path::Path;\r\n    \r\n    if Path::new(\"config.toml\").exists() {\r\n        ModelConfig::from_file(\"config.toml\")\r\n    } else if let Ok(exe_path) = std::env::current_exe() {\r\n        let exe_dir = exe_path.parent().unwrap_or(&exe_path);\r\n        let config_path = exe_dir.join(\"config.toml\");\r\n        if config_path.exists() {\r\n            ModelConfig::from_file(config_path.to_str().unwrap())\r\n        } else {\r\n            ModelConfig::from_env()\r\n        }\r\n    } else {\r\n        ModelConfig::from_env()\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 27.0,
      "lines_of_code": 271,
      "number_of_classes": 1,
      "number_of_functions": 8
    },
    "dependencies": [
      {
        "dependency_type": "language",
        "is_external": true,
        "line_number": null,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "futures",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::interaction::InteractiveBackend",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::PipelineContext",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::pipeline::Stage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::llm::ModelConfig",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::llm::create_llm_client",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The PRD stage is responsible for generating or revising a Product Requirements Document (PRD) using a Large Language Model (LLM). It retrieves iteration context, optionally loads an existing idea document, constructs a detailed prompt based on whether feedback is provided, sends the prompt to an LLM client, streams the response, formats it with metadata headers, and writes the final PRD to a file in the project's artifacts directory. The component supports both initial generation and iterative revision based on user feedback, and integrates with the broader pipeline system through the Stage trait.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "trait",
        "name": "Stage",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ModelConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "PipelineContext",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "LlmRequest",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "Content",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "StageResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "MessageLevel",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Generate PRD from iteration context and LLM",
      "Revise PRD based on user feedback",
      "Manage file I/O for PRD artifacts",
      "Handle LLM communication and response streaming",
      "Format and structure PRD output with metadata"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "dao",
      "description": "Storage layer for .cowork/ directory implementing session-scoped architecture. Provides file system abstraction for project metadata, session state, artifacts, and configuration persistence. Acts as the single source of truth for all disk-based operations in the cowork-core crate.",
      "file_path": "crates\\cowork-core\\src\\storage\\mod.rs",
      "functions": [
        "get_cowork_dir",
        "get_session_dir",
        "get_project_root",
        "cowork_dir_exists",
        "is_project_initialized",
        "load_project_index",
        "save_project_index",
        "init_project_index",
        "save_session_input",
        "load_session_input",
        "save_change_request",
        "load_change_request",
        "artifact_path",
        "save_idea",
        "load_idea",
        "save_prd_doc",
        "save_design_doc",
        "save_delivery_report",
        "state_path",
        "state_file_exists",
        "has_requirements",
        "has_design_spec",
        "has_implementation_plan",
        "has_code_metadata",
        "has_code_files",
        "save_requirements",
        "load_requirements",
        "save_feature_list",
        "load_feature_list",
        "save_design_spec",
        "load_design_spec",
        "save_implementation_plan",
        "load_implementation_plan",
        "save_code_metadata",
        "load_code_metadata",
        "save_session_meta",
        "load_session_meta",
        "save_feedback_history",
        "load_feedback_history",
        "append_feedback",
        "save_patch_metadata",
        "load_patch_metadata",
        "init_session_from_base",
        "generate_id",
        "get_latest_successful_session",
        "mark_session_completed",
        "mark_session_failed",
        "update_feature_status_if_needed"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "get_cowork_dir",
        "get_session_dir",
        "get_project_root",
        "cowork_dir_exists",
        "is_project_initialized",
        "load_project_index",
        "save_project_index",
        "init_project_index",
        "save_session_input",
        "load_session_input",
        "save_change_request",
        "load_change_request",
        "save_idea",
        "load_idea",
        "save_prd_doc",
        "save_design_doc",
        "save_delivery_report",
        "state_file_exists",
        "has_requirements",
        "has_design_spec",
        "has_implementation_plan",
        "has_code_metadata",
        "has_code_files",
        "save_requirements",
        "load_requirements",
        "save_feature_list",
        "load_feature_list",
        "save_design_spec",
        "load_design_spec",
        "save_implementation_plan",
        "load_implementation_plan",
        "save_code_metadata",
        "load_code_metadata",
        "save_session_meta",
        "load_session_meta",
        "save_feedback_history",
        "load_feedback_history",
        "append_feedback",
        "save_patch_metadata",
        "load_patch_metadata",
        "init_session_from_base",
        "generate_id",
        "get_latest_successful_session",
        "mark_session_completed",
        "mark_session_failed",
        "update_feature_status_if_needed"
      ],
      "name": "mod.rs",
      "source_summary": "// Storage layer for .cowork/ directory - Session-scoped architecture\r\nuse crate::data::*;\r\nuse anyhow::{Context, Result};\r\nuse std::fs;\r\nuse std::path::{Path, PathBuf};\r\n\r\n#[cfg(test)]\r\nmod storage_test;\r\n\r\nconst COWORK_DIR: &str = \".cowork\";\r\nconst INDEX_FILE: &str = \"index.json\";\r\nconst SESSIONS_DIR: &str = \"sessions\";\r\n\r\n// ============================================================================\r\n// Core Directory Structure\r\n// ============================================================================\r\n\r\n/// Get the .cowork directory path, create if not exists\r\npub fn get_cowork_dir() -> Result<PathBuf> {\r\n    let path = PathBuf::from(COWORK_DIR);\r\n    \r\n    // Create main directory and subdirectories\r\n    fs::create_dir_all(&path)\r\n        .with_context(|| format!(\"Failed to create .cowork directory at {:?}\", path))?;\r\n    fs::create_dir_all(path.join(SESSIONS_DIR))?;\r\n    \r\n    Ok(path)\r\n}\r\n\r\n/// Get path for a specific session directory\r\npub fn get_session_dir(session_id: &str) -> Result<PathBuf> {\r\n    let cowork_dir = get_cowork_dir()?;\r\n    let session_path = cowork_dir.join(SESSIONS_DIR).join(session_id);\r\n    \r\n    // Create session subdirectories\r\n    fs::create_dir_all(&session_path)?;\r\n    fs::create_dir_all(session_path.join(\"artifacts\"))?;\r\n    fs::create_dir_all(session_path.join(\"state\"))?;\r\n    fs::create_dir_all(session_path.join(\"patch\"))?;\r\n    fs::create_dir_all(session_path.join(\"logs\"))?;\r\n    \r\n    Ok(session_path)\r\n}\r\n\r\n/// Get the project root directory (where .cowork/ is located)\r\n/// This is the actual workspace where code files are written\r\npub fn get_project_root() -> Result<PathBuf> {\r\n    let current_dir = std::env::current_dir()\r\n        .with_context(|| \"Failed to get current directory\")?;\r\n    Ok(current_dir)\r\n}\r\n\r\n/// Check if .cowork directory exists\r\npub fn cowork_dir_exists() -> bool {\r\n    Path::new(COWORK_DIR).exists()\r\n}\r\n\r\n/// Check if project has been initialized (has index.json)\r\npub fn is_project_initialized() -> bool {\r\n    Path::new(COWORK_DIR).join(INDEX_FILE).exists()\r\n}\r\n\r\n// ============================================================================\r\n// Project Index (index.json at root of .cowork/)\r\n// ============================================================================\r\n\r\npub fn load_project_index() -> Result<ProjectIndex> {\r\n    let path = PathBuf::from(COWORK_DIR).join(INDEX_FILE);\r\n    if !path.exists() {\r\n        anyhow::bail!(\"Project not initialized. Run 'cowork new' first.\");\r\n    }\r\n    let content = fs::read_to_string(&path)\r\n        .with_context(|| format!(\"Failed to read {:?}\", path))?;\r\n    let index: ProjectIndex = serde_json::from_str(&content)\r\n        .with_context(|| \"Failed to parse index.json\")?;\r\n    Ok(index)\r\n}\r\n\r\npub fn save_project_index(index: &ProjectIndex) -> Result<()> {\r\n    let cowork_dir = get_cowork_dir()?;\r\n    let path = cowork_dir.join(INDEX_FILE);\r\n    let content = serde_json::to_string_pretty(index)?;\r\n    fs::write(&path, content)\r\n        .with_context(|| format!(\"Failed to write {:?}\", path))?;\r\n    Ok(())\r\n}\r\n\r\npub fn init_project_index(project_name: String) -> Result<ProjectIndex> {\r\n    if is_project_initialized() {\r\n        anyhow::bail!(\".cowork directory already initialized\");\r\n    }\r\n    let index = ProjectIndex::new(project_name);\r\n    save_project_index(&index)?;\r\n    Ok(index)\r\n}\r\n\r\n// ============================================================================\r\n// Session Input (sessions/<id>/input.json)\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\r\npub struct SessionInput {\r\n    pub session_id: String,\r\n    pub session_type: SessionType,\r\n    pub description: String,\r\n    pub base_session_id: Option<String>,\r\n    pub created_at: chrono::DateTime<chrono::Utc>,\r\n}\r\n\r\npub fn save_session_input(session_id: &str, input: &SessionInput) -> Result<()> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"input.json\");\r\n    let content = serde_json::to_string_pretty(input)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_session_input(session_id: &str) -> Result<SessionInput> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"input.json\");\r\n    if !path.exists() {\r\n        anyhow::bail!(\"Session input not found for session {}\", session_id);\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let input: SessionInput = serde_json::from_str(&content)?;\r\n    Ok(input)\r\n}\r\n\r\n// ============================================================================\r\n// Change Request (sessions/<id>/change_request.json - only for modify sessions)\r\n// ============================================================================\r\n\r\npub fn save_change_request(session_id: &str, change_request: &ChangeRequest) -> Result<()> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"change_request.json\");\r\n    let content = serde_json::to_string_pretty(change_request)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_change_request(session_id: &str) -> Result<ChangeRequest> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"change_request.json\");\r\n    if !path.exists() {\r\n        anyhow::bail!(\"Change request not found for session {}\", session_id);\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let cr: ChangeRequest = serde_json::from_str(&content)?;\r\n    Ok(cr)\r\n}\r\n\r\n// ============================================================================\r\n// Session-scoped Artifacts (sessions/<id>/artifacts/)\r\n// ============================================================================\r\n\r\nfn artifact_path(session_id: &str, filename: &str) -> Result<PathBuf> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    Ok(session_dir.join(\"artifacts\").join(filename))\r\n}\r\n\r\npub fn save_idea(session_id: &str, content: &str) -> Result<()> {\r\n    let path = artifact_path(session_id, \"idea.md\")?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_idea(session_id: &str) -> Result<String> {\r\n    let path = artifact_path(session_id, \"idea.md\")?;\r\n    if !path.exists() {\r\n        return Ok(String::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    Ok(content)\r\n}\r\n\r\npub fn save_prd_doc(session_id: &str, content: &str) -> Result<()> {\r\n    let path = artifact_path(session_id, \"prd.md\")?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn save_design_doc(session_id: &str, content: &str) -> Result<()> {\r\n    let path = artifact_path(session_id, \"design.md\")?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn save_delivery_report(session_id: &str, content: &str) -> Result<()> {\r\n    let path = artifact_path(session_id, \"delivery_report.md\")?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Session-scoped State (sessions/<id>/state/)\r\n// ============================================================================\r\n\r\nfn state_path(session_id: &str, filename: &str) -> Result<PathBuf> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    Ok(session_dir.join(\"state\").join(filename))\r\n}\r\n\r\npub fn state_file_exists(session_id: &str, filename: &str) -> Result<bool> {\r\n    Ok(state_path(session_id, filename)?.exists())\r\n}\r\n\r\npub fn has_requirements(session_id: &str) -> Result<bool> {\r\n    state_file_exists(session_id, \"requirements.json\")\r\n}\r\n\r\npub fn has_design_spec(session_id: &str) -> Result<bool> {\r\n    state_file_exists(session_id, \"design_spec.json\")\r\n}\r\n\r\npub fn has_implementation_plan(session_id: &str) -> Result<bool> {\r\n    state_file_exists(session_id, \"implementation_plan.json\")\r\n}\r\n\r\npub fn has_code_metadata(session_id: &str) -> Result<bool> {\r\n    state_file_exists(session_id, \"code_metadata.json\")\r\n}\r\n\r\n/// Check if coding stage has made progress (has written files)\r\npub fn has_code_files(session_id: &str) -> Result<bool> {\r\n    if !has_code_metadata(session_id)? {\r\n        return Ok(false);\r\n    }\r\n    \r\n    let metadata = load_code_metadata(session_id)?;\r\n    Ok(!metadata.files.is_empty())\r\n}\r\n\r\npub fn save_requirements(session_id: &str, requirements: &Requirements) -> Result<()> {\r\n    let path = state_path(session_id, \"requirements.json\")?;\r\n    let content = serde_json::to_string_pretty(requirements)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_requirements(session_id: &str) -> Result<Requirements> {\r\n    let path = state_path(session_id, \"requirements.json\")?;\r\n    if !path.exists() {\r\n        return Ok(Requirements::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let requirements: Requirements = serde_json::from_str(&content)?;\r\n    Ok(requirements)\r\n}\r\n\r\npub fn save_feature_list(session_id: &str, features: &FeatureList) -> Result<()> {\r\n    let path = state_path(session_id, \"feature_list.json\")?;\r\n    let content = serde_json::to_string_pretty(features)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_feature_list(session_id: &str) -> Result<FeatureList> {\r\n    let path = state_path(session_id, \"feature_list.json\")?;\r\n    if !path.exists() {\r\n        return Ok(FeatureList::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let features: FeatureList = serde_json::from_str(&content)?;\r\n    Ok(features)\r\n}\r\n\r\npub fn save_design_spec(session_id: &str, design: &DesignSpec) -> Result<()> {\r\n    let path = state_path(session_id, \"design_spec.json\")?;\r\n    let content = serde_json::to_string_pretty(design)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_design_spec(session_id: &str) -> Result<DesignSpec> {\r\n    let path = state_path(session_id, \"design_spec.json\")?;\r\n    if !path.exists() {\r\n        return Ok(DesignSpec::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let design: DesignSpec = serde_json::from_str(&content)?;\r\n    Ok(design)\r\n}\r\n\r\npub fn save_implementation_plan(session_id: &str, plan: &ImplementationPlan) -> Result<()> {\r\n    let path = state_path(session_id, \"implementation_plan.json\")?;\r\n    let content = serde_json::to_string_pretty(plan)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_implementation_plan(session_id: &str) -> Result<ImplementationPlan> {\r\n    let path = state_path(session_id, \"implementation_plan.json\")?;\r\n    if !path.exists() {\r\n        return Ok(ImplementationPlan::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let plan: ImplementationPlan = serde_json::from_str(&content)?;\r\n    Ok(plan)\r\n}\r\n\r\npub fn save_code_metadata(session_id: &str, metadata: &CodeMetadata) -> Result<()> {\r\n    let path = state_path(session_id, \"code_metadata.json\")?;\r\n    let content = serde_json::to_string_pretty(metadata)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_code_metadata(session_id: &str) -> Result<CodeMetadata> {\r\n    let path = state_path(session_id, \"code_metadata.json\")?;\r\n    if !path.exists() {\r\n        return Ok(CodeMetadata::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let metadata: CodeMetadata = serde_json::from_str(&content)?;\r\n    Ok(metadata)\r\n}\r\n\r\n// ============================================================================\r\n// Session Metadata (sessions/<id>/state/meta.json)\r\n// ============================================================================\r\n\r\npub fn save_session_meta(session_id: &str, meta: &SessionMeta) -> Result<()> {\r\n    let path = state_path(session_id, \"meta.json\")?;\r\n    let content = serde_json::to_string_pretty(meta)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_session_meta(session_id: &str) -> Result<Option<SessionMeta>> {\r\n    let path = state_path(session_id, \"meta.json\")?;\r\n    if !path.exists() {\r\n        return Ok(None);\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let meta: SessionMeta = serde_json::from_str(&content)?;\r\n    Ok(Some(meta))\r\n}\r\n\r\n// ============================================================================\r\n// Feedback History (sessions/<id>/state/feedback.json)\r\n// ============================================================================\r\n\r\npub fn save_feedback_history(session_id: &str, history: &FeedbackHistory) -> Result<()> {\r\n    let path = state_path(session_id, \"feedback.json\")?;\r\n    let content = serde_json::to_string_pretty(history)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_feedback_history(session_id: &str) -> Result<FeedbackHistory> {\r\n    let path = state_path(session_id, \"feedback.json\")?;\r\n    if !path.exists() {\r\n        return Ok(FeedbackHistory::new());\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let history: FeedbackHistory = serde_json::from_str(&content)?;\r\n    Ok(history)\r\n}\r\n\r\npub fn append_feedback(session_id: &str, feedback: &Feedback) -> Result<()> {\r\n    let mut history = load_feedback_history(session_id)?;\r\n    history.feedbacks.push(feedback.clone());\r\n    save_feedback_history(session_id, &history)?;\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Patch Metadata (sessions/<id>/patch/metadata.json - for modify sessions)\r\n// ============================================================================\r\n\r\npub fn save_patch_metadata(session_id: &str, patch: &PatchMetadata) -> Result<()> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"patch\").join(\"metadata.json\");\r\n    let content = serde_json::to_string_pretty(patch)?;\r\n    fs::write(&path, content)?;\r\n    Ok(())\r\n}\r\n\r\npub fn load_patch_metadata(session_id: &str) -> Result<PatchMetadata> {\r\n    let session_dir = get_session_dir(session_id)?;\r\n    let path = session_dir.join(\"patch\").join(\"metadata.json\");\r\n    if !path.exists() {\r\n        anyhow::bail!(\"Patch metadata not found for session {}\", session_id);\r\n    }\r\n    let content = fs::read_to_string(&path)?;\r\n    let patch: PatchMetadata = serde_json::from_str(&content)?;\r\n    Ok(patch)\r\n}\r\n\r\n// ============================================================================\r\n// Session Inheritance / Bootstrap\r\n// ============================================================================\r\n\r\n/// Initialize a new session by copying state/artifacts from a base session.\r\n///\r\n/// This is critical for `modify` / `revert` / `resume` flows: a fresh session directory\r\n/// should not start with empty state, otherwise agents will see empty requirements/design/plan.\r\n///\r\n/// What we copy:\r\n/// - state/*.json (requirements, feature_list, design_spec, implementation_plan, code_metadata, feedback, meta)\r\n/// - artifacts/*.md (idea, prd, design, delivery_report) if present\r\n///\r\n/// Notes:\r\n/// - This function does NOT copy code files in the project root.\r\n/// - Missing files are skipped.\r\npub fn init_session_from_base(new_session_id: &str, base_session_id: &str) -> Result<()> {\r\n    let base_dir = get_session_dir(base_session_id)?;\r\n    let new_dir = get_session_dir(new_session_id)?;\r\n\r\n    // helper to copy a file if it exists\r\n    fn copy_if_exists(src: &Path, dst: &Path) -> Result<()> {\r\n        if !src.exists() {\r\n            return Ok(());\r\n        }\r\n        if let Some(parent) = dst.parent() {\r\n            fs::create_dir_all(parent)?;\r\n        }\r\n        fs::copy(src, dst).with_context(|| format!(\"Failed to copy {:?} -> {:?}\", src, dst))?;\r\n        Ok(())\r\n    }\r\n\r\n    // state files\r\n    let state_files = [\r\n        \"requirements.json\",\r\n        \"feature_list.json\",\r\n        \"design_spec.json\",\r\n        \"implementation_plan.json\",\r\n        \"code_metadata.json\",\r\n        // \"feedback.json\",  // Don't copy feedback history to new session\r\n        \"meta.json\",\r\n    ];\r\n\r\n    for name in state_files {\r\n        let src = base_dir.join(\"state\").join(name);\r\n        let dst = new_dir.join(\"state\").join(name);\r\n        copy_if_exists(&src, &dst)?;\r\n    }\r\n\r\n    // artifact files\r\n    let artifact_files = [\"idea.md\", \"prd.md\", \"design.md\", \"delivery_report.md\"]; \r\n    for name in artifact_files {\r\n        let src = base_dir.join(\"artifacts\").join(name);\r\n        let dst = new_dir.join(\"artifacts\").join(name);\r\n        copy_if_exists(&src, &dst)?;\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Helper utilities\r\n// ============================================================================\r\n\r\n/// Generate ID with prefix and counter\r\npub fn generate_id(prefix: &str, counter: usize) -> String {\r\n    format!(\"{}-{:03}\", prefix, counter + 1)\r\n}\r\n\r\n/// Get the latest successful session ID from index\r\npub fn get_latest_successful_session() -> Result<Option<String>> {\r\n    if !is_project_initialized() {\r\n        return Ok(None);\r\n    }\r\n    let index = load_project_index()?;\r\n    Ok(index.latest_successful_session)\r\n}\r\n\r\n/// Mark a session as completed successfully\r\npub fn mark_session_completed(session_id: &str) -> Result<()> {\r\n    let mut index = load_project_index()?;\r\n    \r\n    // Update session record\r\n    for session in &mut index.sessions {\r\n        if session.session_id == session_id {\r\n            session.status = SessionStatus::Completed;\r\n            session.completed_at = Some(chrono::Utc::now());\r\n            break;\r\n        }\r\n    }\r\n    \r\n    // Update latest successful session\r\n    index.update_latest_successful(session_id.to_string());\r\n    save_project_index(&index)?;\r\n    Ok(())\r\n}\r\n\r\n/// Mark a session as failed\r\npub fn mark_session_failed(session_id: &str) -> Result<()> {\r\n    let mut index = load_project_index()?;\r\n    \r\n    for session in &mut index.sessions {\r\n        if session.session_id == session_id {\r\n            session.status = SessionStatus::Failed;\r\n            session.completed_at = Some(chrono::Utc::now());\r\n            break;\r\n        }\r\n    }\r\n    \r\n    save_project_index(&index)?;\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Feature Status Auto-Update Logic\r\n// ============================================================================\r\n\r\n/// Update feature status based on its tasks' completion status\r\n/// Called automatically when a task is marked as completed\r\npub fn update_feature_status_if_needed(session_id: &str, feature_id: &str) -> Result<()> {\r\n    let plan = load_implementation_plan(session_id)?;\r\n    let mut features = load_feature_list(session_id)?;\r\n    \r\n    // Find the feature\r\n    let feature_idx = match features.features.iter().position(|f| f.id == feature_id) {\r\n        Some(idx) => idx,\r\n        None => {\r\n            // Feature not found, maybe it's an old task - just skip\r\n            return Ok(());\r\n        }\r\n    };\r\n    \r\n    // Get all tasks for this feature\r\n    let feature_tasks: Vec<&Task> = plan.tasks.iter()\r\n        .filter(|t| t.feature_id == feature_id)\r\n        .collect();\r\n    \r\n    if feature_tasks.is_empty() {\r\n        // No tasks for this feature - keep as pending\r\n        return Ok(());\r\n    }\r\n    \r\n    // Check task statuses\r\n    let all_completed = feature_tasks.iter().all(|t| t.status == TaskStatus::Completed);\r\n    let any_in_progress = feature_tasks.iter().any(|t| t.status == TaskStatus::InProgress);\r\n    let any_blocked = feature_tasks.iter().any(|t| t.status == TaskStatus::Blocked);\r\n    \r\n    // Determine new feature status\r\n    let new_status = if all_completed {\r\n        FeatureStatus::Completed\r\n    } else if any_blocked {\r\n        FeatureStatus::Blocked\r\n    } else if any_in_progress {\r\n        FeatureStatus::InProgress\r\n    } else {\r\n        FeatureStatus::Pending\r\n    };\r\n    \r\n    // Update feature if status changed\r\n    let feature = &mut features.features[feature_idx];\r\n    if feature.status != new_status {\r\n        let old_status = feature.status;\r\n        feature.status = new_status;\r\n        \r\n        // Set completed_at if transitioning to completed\r\n        if new_status == FeatureStatus::Completed {\r\n            feature.completed_at = Some(chrono::Utc::now());\r\n            println!(\"✅ Feature {} completed: {}\", feature_id, feature.name);\r\n        }\r\n        \r\n        // Clear completed_at if moving away from completed\r\n        if old_status == FeatureStatus::Completed && new_status != FeatureStatus::Completed {\r\n            feature.completed_at = None;\r\n        }\r\n        \r\n        save_feature_list(session_id, &features)?;\r\n        \r\n        if new_status != FeatureStatus::Completed {\r\n            println!(\"ℹ️  Feature {} status: {:?} → {:?}\", feature_id, old_status, new_status);\r\n        }\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 52.0,
      "lines_of_code": 573,
      "number_of_classes": 1,
      "number_of_functions": 46
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::data::*",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "error_handling",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "stdlib",
        "is_external": false,
        "line_number": null,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "stdlib",
        "is_external": false,
        "line_number": null,
        "name": "std::path",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component implements the Data Access Layer (DAO) for the cowork project management system. It provides a session-scoped file storage architecture where all project metadata and session-specific data is organized under a `.cowork/` directory.\n\n**Core Architecture**: The storage follows a hierarchical structure:\n- `.cowork/index.json` - Project-level metadata and session registry\n- `.cowork/sessions/<id>/` - Session-scoped directories containing:\n  - `input.json` - Session initialization parameters\n  - `change_request.json` - Modification requests for existing sessions\n  - `artifacts/` - Documentation artifacts (idea.md, prd.md, design.md, delivery_report.md)\n  - `state/` - JSON-serialized structured data (requirements, design specs, implementation plans, code metadata, session meta, feedback)\n  - `patch/` - Patch metadata for modification sessions\n\n**Key Functional Areas**:\n1. **Directory Management**: Creates and validates the .cowork directory structure with proper subdirectories (sessions/, artifacts/, state/, patch/, logs/)\n2. **Session Lifecycle**: Manages session creation, initialization from base sessions (inheritance pattern), and status tracking (completed/failed)\n3. **State Persistence**: Generic load/save operations for typed JSON structures with graceful handling of missing files\n4. **Workflow Support**: Implements the modify/revert/resume flows through `init_session_from_base()` which copies state and artifacts between sessions\n5. **Feature Tracking**: Auto-updates feature status based on task completion states\n\n**Error Handling**: Uses anyhow for context-rich error propagation with descriptive messages for file operations. The pattern of returning default empty structures for missing files (e.g., `Requirements::new()`) provides idempotent read operations.\n\n**Concurrency**: While not explicitly async, the component uses atomic file write operations (fs::write) which provide basic safety. The session inheritance logic handles cross-directory copying with proper parent directory creation.",
    "interfaces": [
      {
        "description": "Returns PathBuf to .cowork directory, creating it and subdirectories if necessary",
        "interface_type": "function",
        "name": "get_cowork_dir",
        "parameters": [],
        "return_type": "Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Returns PathBuf to specific session directory, creating session subdirs",
        "interface_type": "function",
        "name": "get_session_dir",
        "parameters": [
          {
            "description": "Unique session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Returns current working directory as project root",
        "interface_type": "function",
        "name": "get_project_root",
        "parameters": [],
        "return_type": "Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Checks if .cowork directory exists without creating it",
        "interface_type": "function",
        "name": "cowork_dir_exists",
        "parameters": [],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Checks if project has been initialized (has index.json)",
        "interface_type": "function",
        "name": "is_project_initialized",
        "parameters": [],
        "return_type": "bool",
        "visibility": "public"
      },
      {
        "description": "Loads ProjectIndex from index.json",
        "interface_type": "function",
        "name": "load_project_index",
        "parameters": [],
        "return_type": "Result<ProjectIndex>",
        "visibility": "public"
      },
      {
        "description": "Serializes and saves ProjectIndex to index.json",
        "interface_type": "function",
        "name": "save_project_index",
        "parameters": [
          {
            "description": "Project index to persist",
            "is_optional": false,
            "name": "index",
            "param_type": "&ProjectIndex"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Creates new ProjectIndex and initializes storage",
        "interface_type": "function",
        "name": "init_project_index",
        "parameters": [
          {
            "description": "Project name",
            "is_optional": false,
            "name": "project_name",
            "param_type": "String"
          }
        ],
        "return_type": "Result<ProjectIndex>",
        "visibility": "public"
      },
      {
        "description": "Serializes SessionInput to session's input.json",
        "interface_type": "function",
        "name": "save_session_input",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Session input struct",
            "is_optional": false,
            "name": "input",
            "param_type": "&SessionInput"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes SessionInput from session's input.json",
        "interface_type": "function",
        "name": "load_session_input",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<SessionInput>",
        "visibility": "public"
      },
      {
        "description": "Serializes ChangeRequest to session's change_request.json",
        "interface_type": "function",
        "name": "save_change_request",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Change request data",
            "is_optional": false,
            "name": "change_request",
            "param_type": "&ChangeRequest"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes ChangeRequest from session's change_request.json",
        "interface_type": "function",
        "name": "load_change_request",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<ChangeRequest>",
        "visibility": "public"
      },
      {
        "description": "Computes path to artifact file within session",
        "interface_type": "function",
        "name": "artifact_path",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Filename within artifacts folder",
            "is_optional": false,
            "name": "filename",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<PathBuf>",
        "visibility": "private"
      },
      {
        "description": "Writes idea content to idea.md",
        "interface_type": "function",
        "name": "save_idea",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Markdown content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Reads idea.md content or returns empty string if missing",
        "interface_type": "function",
        "name": "load_idea",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<String>",
        "visibility": "public"
      },
      {
        "description": "Writes PRD document to prd.md",
        "interface_type": "function",
        "name": "save_prd_doc",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Markdown content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Writes design document to design.md",
        "interface_type": "function",
        "name": "save_design_doc",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Markdown content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Writes delivery report to delivery_report.md",
        "interface_type": "function",
        "name": "save_delivery_report",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Markdown content",
            "is_optional": false,
            "name": "content",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Computes path to state file within session",
        "interface_type": "function",
        "name": "state_path",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "State filename",
            "is_optional": false,
            "name": "filename",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<PathBuf>",
        "visibility": "private"
      },
      {
        "description": "Checks existence of state file",
        "interface_type": "function",
        "name": "state_file_exists",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "State filename",
            "is_optional": false,
            "name": "filename",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Checks if requirements.json exists",
        "interface_type": "function",
        "name": "has_requirements",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Checks if design_spec.json exists",
        "interface_type": "function",
        "name": "has_design_spec",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Checks if implementation_plan.json exists",
        "interface_type": "function",
        "name": "has_implementation_plan",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Checks if code_metadata.json exists",
        "interface_type": "function",
        "name": "has_code_metadata",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Checks if any code files have been written",
        "interface_type": "function",
        "name": "has_code_files",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<bool>",
        "visibility": "public"
      },
      {
        "description": "Serializes Requirements to requirements.json",
        "interface_type": "function",
        "name": "save_requirements",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Requirements struct",
            "is_optional": false,
            "name": "requirements",
            "param_type": "&Requirements"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes Requirements or returns empty Requirements if missing",
        "interface_type": "function",
        "name": "load_requirements",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Requirements>",
        "visibility": "public"
      },
      {
        "description": "Serializes FeatureList to feature_list.json",
        "interface_type": "function",
        "name": "save_feature_list",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Feature list",
            "is_optional": false,
            "name": "features",
            "param_type": "&FeatureList"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes FeatureList or returns empty FeatureList if missing",
        "interface_type": "function",
        "name": "load_feature_list",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<FeatureList>",
        "visibility": "public"
      },
      {
        "description": "Serializes DesignSpec to design_spec.json",
        "interface_type": "function",
        "name": "save_design_spec",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Design specification",
            "is_optional": false,
            "name": "design",
            "param_type": "&DesignSpec"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes DesignSpec or returns empty DesignSpec if missing",
        "interface_type": "function",
        "name": "load_design_spec",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<DesignSpec>",
        "visibility": "public"
      },
      {
        "description": "Serializes ImplementationPlan to implementation_plan.json",
        "interface_type": "function",
        "name": "save_implementation_plan",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Implementation plan",
            "is_optional": false,
            "name": "plan",
            "param_type": "&ImplementationPlan"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes ImplementationPlan or returns empty ImplementationPlan if missing",
        "interface_type": "function",
        "name": "load_implementation_plan",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<ImplementationPlan>",
        "visibility": "public"
      },
      {
        "description": "Serializes CodeMetadata to code_metadata.json",
        "interface_type": "function",
        "name": "save_code_metadata",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Code metadata",
            "is_optional": false,
            "name": "metadata",
            "param_type": "&CodeMetadata"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes CodeMetadata or returns empty CodeMetadata if missing",
        "interface_type": "function",
        "name": "load_code_metadata",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<CodeMetadata>",
        "visibility": "public"
      },
      {
        "description": "Serializes SessionMeta to meta.json",
        "interface_type": "function",
        "name": "save_session_meta",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Session metadata",
            "is_optional": false,
            "name": "meta",
            "param_type": "&SessionMeta"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes SessionMeta or returns None if missing",
        "interface_type": "function",
        "name": "load_session_meta",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<Option<SessionMeta>>",
        "visibility": "public"
      },
      {
        "description": "Serializes FeedbackHistory to feedback.json",
        "interface_type": "function",
        "name": "save_feedback_history",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Feedback history",
            "is_optional": false,
            "name": "history",
            "param_type": "&FeedbackHistory"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes FeedbackHistory or returns empty FeedbackHistory if missing",
        "interface_type": "function",
        "name": "load_feedback_history",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<FeedbackHistory>",
        "visibility": "public"
      },
      {
        "description": "Appends single Feedback to history and persists",
        "interface_type": "function",
        "name": "append_feedback",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Feedback to append",
            "is_optional": false,
            "name": "feedback",
            "param_type": "&Feedback"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Serializes PatchMetadata to patch/metadata.json",
        "interface_type": "function",
        "name": "save_patch_metadata",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Patch metadata",
            "is_optional": false,
            "name": "patch",
            "param_type": "&PatchMetadata"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Deserializes PatchMetadata from patch/metadata.json",
        "interface_type": "function",
        "name": "load_patch_metadata",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<PatchMetadata>",
        "visibility": "public"
      },
      {
        "description": "Inherits state and artifacts from base session to new session",
        "interface_type": "function",
        "name": "init_session_from_base",
        "parameters": [
          {
            "description": "New session ID to create",
            "is_optional": false,
            "name": "new_session_id",
            "param_type": "&str"
          },
          {
            "description": "Base session ID to copy from",
            "is_optional": false,
            "name": "base_session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Generates sequential ID with prefix",
        "interface_type": "function",
        "name": "generate_id",
        "parameters": [
          {
            "description": "ID prefix",
            "is_optional": false,
            "name": "prefix",
            "param_type": "&str"
          },
          {
            "description": "Zero-indexed counter",
            "is_optional": false,
            "name": "counter",
            "param_type": "usize"
          }
        ],
        "return_type": "String",
        "visibility": "public"
      },
      {
        "description": "Retrieves latest successful session from project index",
        "interface_type": "function",
        "name": "get_latest_successful_session",
        "parameters": [],
        "return_type": "Result<Option<String>>",
        "visibility": "public"
      },
      {
        "description": "Marks session as completed in project index",
        "interface_type": "function",
        "name": "mark_session_completed",
        "parameters": [
          {
            "description": "Session ID to mark",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Marks session as failed in project index",
        "interface_type": "function",
        "name": "mark_session_failed",
        "parameters": [
          {
            "description": "Session ID to mark",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Updates feature status based on task completion states",
        "interface_type": "function",
        "name": "update_feature_status_if_needed",
        "parameters": [
          {
            "description": "Session ID",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          },
          {
            "description": "Feature ID to evaluate",
            "is_optional": false,
            "name": "feature_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Directory structure management and initialization for .cowork/ workspace",
      "Session-scoped data persistence with JSON serialization/deserialization",
      "Project and session lifecycle state management (init, complete, fail)",
      "Cross-session state inheritance for modify/revert/resume workflows",
      "Feature status auto-update based on task completion aggregation"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Artifact operation tools for Delivery Agent providing session-scoped document management capabilities including saving delivery reports, PRD documents, design documents, and loading feedback history.",
      "file_path": "crates\\cowork-core\\src\\tools\\artifact_tools.rs",
      "functions": [
        "name",
        "description",
        "parameters_schema",
        "execute",
        "new"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "SaveDeliveryReportTool",
        "SavePrdDocTool",
        "SaveDesignDocTool",
        "LoadFeedbackHistoryTool",
        "Tool"
      ],
      "name": "artifact_tools.rs",
      "source_summary": "// Artifact operation tools for Delivery Agent (Session-scoped)\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext};\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\n// ============================================================================\r\n// SaveDeliveryReportTool\r\n// ============================================================================\r\n\r\npub struct SaveDeliveryReportTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl SaveDeliveryReportTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for SaveDeliveryReportTool {\r\n    fn name(&self) -> &str {\r\n        \"save_delivery_report\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Save the delivery report markdown document.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"content\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Markdown content of the delivery report\"\r\n                }\r\n            },\r\n            \"required\": [\"content\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let content = args[\"content\"].as_str()\r\n            .or_else(|| args[\" content\"].as_str()) // Handle LLM adding space before key\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'content' parameter\".to_string()))?;\r\n        \r\n        save_delivery_report(&self.session_id, content)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"message\": \"Delivery report saved successfully\"\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// SavePrdDocTool\r\n// ============================================================================\r\n\r\npub struct SavePrdDocTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl SavePrdDocTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for SavePrdDocTool {\r\n    fn name(&self) -> &str {\r\n        \"save_prd_doc\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Save the PRD (Product Requirements Document) markdown file.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"content\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Markdown content of the PRD document\"\r\n                }\r\n            },\r\n            \"required\": [\"content\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let content = args[\"content\"].as_str()\r\n            .or_else(|| args[\" content\"].as_str()) // Handle LLM adding space before key\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'content' parameter\".to_string()))?;\r\n        \r\n        save_prd_doc(&self.session_id, content)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"message\": \"PRD document saved successfully\"\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// SaveDesignDocTool\r\n// ============================================================================\r\n\r\npub struct SaveDesignDocTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl SaveDesignDocTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for SaveDesignDocTool {\r\n    fn name(&self) -> &str {\r\n        \"save_design_doc\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Save the Design Document markdown file.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"content\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Markdown content of the design document\"\r\n                }\r\n            },\r\n            \"required\": [\"content\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let content = args[\"content\"].as_str()\r\n            .or_else(|| args[\" content\"].as_str()) // Handle LLM adding space before key\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'content' parameter\".to_string()))?;\r\n        \r\n        save_design_doc(&self.session_id, content)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"message\": \"Design document saved successfully\"\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// LoadFeedbackHistoryTool\r\n// ============================================================================\r\n\r\npub struct LoadFeedbackHistoryTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl LoadFeedbackHistoryTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for LoadFeedbackHistoryTool {\r\n    fn name(&self) -> &str {\r\n        \"load_feedback_history\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Load the feedback history from all development stages.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {}\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let history = load_feedback_history(&self.session_id)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(serde_json::to_value(history)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?)\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 6.0,
      "lines_of_code": 202,
      "number_of_classes": 4,
      "number_of_functions": 16
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": false,
        "line_number": 2,
        "name": "crate::storage::*",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 4,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 5,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": true,
        "line_number": 6,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component provides four specialized tool implementations for the Delivery Agent system, all session-scoped for multi-tenant isolation. Each tool implements the `Tool` trait from `adk_core` enabling integration with an agent framework:\n\n1. **SaveDeliveryReportTool**: Persists delivery report markdown documents with session-based storage isolation.\n2. **SavePrdDocTool**: Handles saving Product Requirements Document (PRD) markdown content to persistent storage.\n3. **SaveDesignDocTool**: Manages saving Design Document markdown files within a session context.\n4. **LoadFeedbackHistoryTool**: Retrieves aggregated feedback history across all development stages for a given session.\n\nAll save tools follow an identical pattern: extract the 'content' parameter (with a fallback to handle LLM-generated keys with leading spaces), validate presence, delegate to storage functions (save_delivery_report, save_prd_doc, save_design_doc), and return a standardized success JSON response. The load tool has no parameters and returns serialized feedback history data.\n\nThe tools share a common architectural pattern: session_id-based instantiation, JSON schema parameter definition for LLM integration, async execution context via Arc<dyn ToolContext>, and consistent error mapping to adk_core::AdkError::Tool variants.",
    "interfaces": [
      {
        "description": "Returns the tool identifier string for LLM/agent routing",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns human-readable description of tool purpose",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON Schema defining expected parameters",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Executes the tool's core logic with given context and arguments",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments containing tool parameters",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Constructor for SaveDeliveryReportTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for storage isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for SavePrdDocTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for storage isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for SaveDesignDocTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for storage isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for LoadFeedbackHistoryTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for storage isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Provide session-scoped document persistence tools for delivery reports, PRD documents, and design documents",
      "Enable retrieval of aggregated feedback history across development stages",
      "Bridge between LLM/agent framework and underlying storage layer through standardized Tool trait implementation",
      "Handle parameter validation and error mapping for document operations",
      "Support multi-tenant isolation through session_id-based tool instantiation"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Session-scoped control tools for providing feedback, requesting replanning, querying users, and requesting human review within the cowork-core system. Implements the Tool trait from adk_core to provide interactive control mechanisms for agent workflows.",
      "file_path": "crates\\cowork-core\\src\\tools\\control_tools.rs",
      "functions": [
        "ProvideFeedbackTool::new",
        "RequestReplanningTool::new",
        "RequestHumanReviewTool::new",
        "Tool::name",
        "Tool::description",
        "Tool::parameters_schema",
        "Tool::execute",
        "execute_feedback",
        "execute_replanning",
        "execute_ask_user",
        "execute_human_review"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "ProvideFeedbackTool",
        "RequestReplanningTool",
        "AskUserTool",
        "RequestHumanReviewTool"
      ],
      "name": "control_tools.rs",
      "source_summary": "// Control tools - provide_feedback, ask_user, etc. (Session-scoped)\r\nuse crate::data::*;\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext};\r\n\r\nuse async_trait::async_trait;\r\nuse dialoguer::{Confirm, Input};\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\n// ============================================================================\r\n// ProvideFeedbackTool\r\n// ============================================================================\r\n\r\npub struct ProvideFeedbackTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl ProvideFeedbackTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// RequestReplanningTool\r\n// ============================================================================\r\n\r\npub struct RequestReplanningTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl RequestReplanningTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for RequestReplanningTool {\r\n    fn name(&self) -> &str {\r\n        \"request_replanning\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Request replanning when you discover fundamental issues with the current plan \\\r\n         during implementation. This records the request and provides guidance to revisit \\\r\n         the planning phase. Use this for major architectural issues, not minor task adjustments.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"issue_type\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"design_flaw\", \"missing_dependency\", \"architecture_conflict\", \"requirement_mismatch\"],\r\n                    \"description\": \"Type of issue requiring replanning\"\r\n                },\r\n                \"severity\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"critical\", \"major\", \"moderate\"],\r\n                    \"description\": \"How severe is this issue\"\r\n                },\r\n                \"details\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Detailed description of the problem\"\r\n                },\r\n                \"affected_features\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"Feature IDs affected by this issue\"\r\n                },\r\n                \"suggested_approach\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Your suggested approach to resolve this (optional)\"\r\n                }\r\n            },\r\n            \"required\": [\"issue_type\", \"severity\", \"details\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        use crate::data::{Feedback, FeedbackType, Severity};\r\n        use crate::storage::append_feedback;\r\n\r\n        let issue_type = args.get(\"issue_type\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'issue_type'\".to_string()))?;\r\n\r\n        let severity_str = args.get(\"severity\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'severity'\".to_string()))?;\r\n\r\n        let details = args.get(\"details\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'details'\".to_string()))?;\r\n\r\n        let severity = match severity_str {\r\n            \"critical\" => Severity::Critical,\r\n            \"major\" => Severity::Major,\r\n            _ => Severity::Minor,\r\n        };\r\n\r\n        let affected_features: Vec<String> = args.get(\"affected_features\")\r\n            .and_then(|v| v.as_array())\r\n            .map(|arr| arr.iter()\r\n                .filter_map(|v| v.as_str().map(String::from))\r\n                .collect())\r\n            .unwrap_or_default();\r\n\r\n        let suggested_approach = args.get(\"suggested_approach\")\r\n            .and_then(|v| v.as_str());\r\n\r\n        // Compose detailed feedback message\r\n        let mut feedback_details = format!(\r\n            \"REPLANNING REQUEST\\n\\\r\n             Issue Type: {}\\n\\\r\n             Severity: {}\\n\\\r\n             Details: {}\\n\",\r\n            issue_type, severity_str, details\r\n        );\r\n\r\n        if !affected_features.is_empty() {\r\n            feedback_details.push_str(&format!(\"Affected Features: {}\\n\", affected_features.join(\", \")));\r\n        }\r\n\r\n        if let Some(approach) = suggested_approach {\r\n            feedback_details.push_str(&format!(\"Suggested Approach: {}\\n\", approach));\r\n        }\r\n\r\n        // Record as critical feedback\r\n        let feedback = Feedback {\r\n            feedback_type: FeedbackType::MissingRequirement, // Use this to indicate planning issue\r\n            severity,\r\n            details: feedback_details.clone(),\r\n            suggested_fix: suggested_approach.map(String::from),\r\n            timestamp: chrono::Utc::now(),\r\n        };\r\n\r\n        append_feedback(&self.session_id, &feedback)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        // Print warning to console\r\n        println!(\"\\n⚠️  REPLANNING REQUESTED ⚠️\");\r\n        println!(\"Type: {} | Severity: {}\", issue_type, severity_str);\r\n        println!(\"Details: {}\", details);\r\n        if !affected_features.is_empty() {\r\n            println!(\"Affected: {}\", affected_features.join(\", \"));\r\n        }\r\n        println!();\r\n\r\n        let message = format!(\r\n            \"Replanning request recorded with {} severity. \\\r\n             The coding loop will continue, but this issue should be addressed. \\\r\n             Consider using 'goto_stage' in the check phase if fundamental changes are needed.\",\r\n            severity_str\r\n        );\r\n\r\n        Ok(json!({\r\n            \"status\": \"replanning_requested\",\r\n            \"issue_type\": issue_type,\r\n            \"severity\": severity_str,\r\n            \"affected_features\": affected_features,\r\n            \"message\": message,\r\n            \"guidance\": \"Continue with current implementation if possible, or mark tasks as blocked. \\\r\n                        The Check Agent will review this request and may trigger goto_stage if needed.\"\r\n        }))\r\n    }\r\n}\r\n\r\n\r\n#[async_trait]\r\nimpl Tool for ProvideFeedbackTool {\r\n    fn name(&self) -> &str {\r\n        \"provide_feedback\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Provide structured feedback to the Actor agent. \\\r\n         This feedback will be visible to the Actor in the next iteration.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"feedback_type\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"build_error\", \"quality_issue\", \"missing_requirement\", \"suggestion\"],\r\n                },\r\n                \"severity\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"critical\", \"major\", \"minor\"],\r\n                },\r\n                \"details\": {\"type\": \"string\"},\r\n                \"suggested_fix\": {\"type\": \"string\"}\r\n            },\r\n            \"required\": [\"feedback_type\", \"severity\", \"details\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let feedback_type_str = args.get(\"feedback_type\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing required parameter 'feedback_type'\".to_string()))?;\r\n        \r\n        let feedback_type = match feedback_type_str {\r\n            \"build_error\" => FeedbackType::BuildError,\r\n            \"quality_issue\" => FeedbackType::QualityIssue,\r\n            \"missing_requirement\" => FeedbackType::MissingRequirement,\r\n            _ => FeedbackType::Suggestion,\r\n        };\r\n\r\n        let severity_str = args.get(\"severity\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing required parameter 'severity'\".to_string()))?;\r\n        \r\n        let severity = match severity_str {\r\n            \"critical\" => Severity::Critical,\r\n            \"major\" => Severity::Major,\r\n            _ => Severity::Minor,\r\n        };\r\n\r\n        let details = args.get(\"details\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing required parameter 'details'\".to_string()))?\r\n            .to_string();\r\n\r\n        let feedback = Feedback {\r\n            feedback_type,\r\n            severity,\r\n            details,\r\n            suggested_fix: args\r\n                .get(\"suggested_fix\")\r\n                .and_then(|v| v.as_str())\r\n                .map(String::from),\r\n            timestamp: chrono::Utc::now(),\r\n        };\r\n\r\n        append_feedback(&self.session_id, &feedback).map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"feedback_recorded\",\r\n            \"message\": \"Feedback will be available to Actor in next iteration\"\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// AskUserTool\r\n// ============================================================================\r\n\r\npub struct AskUserTool;\r\n\r\n#[async_trait]\r\nimpl Tool for AskUserTool {\r\n    fn name(&self) -> &str {\r\n        \"ask_user\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Ask the user for confirmation or input via CLI interface.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"question\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"The question to ask the user\"\r\n                },\r\n                \"question_type\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"yes_no\", \"text_input\"],\r\n                    \"description\": \"Type of question\"\r\n                }\r\n            },\r\n            \"required\": [\"question\", \"question_type\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let question = args[\"question\"].as_str().unwrap();\r\n        let question_type = args[\"question_type\"].as_str().unwrap();\r\n\r\n        match question_type {\r\n            \"yes_no\" => {\r\n                let answer = Confirm::new()\r\n                    .with_prompt(question)\r\n                    .default(false)\r\n                    .interact()\r\n                    .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n                Ok(json!({\r\n                    \"answer\": answer,\r\n                    \"answer_type\": \"boolean\"\r\n                }))\r\n            }\r\n            \"text_input\" => {\r\n                let answer: String = Input::new()\r\n                    .with_prompt(question)\r\n                    .interact_text()\r\n                    .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n                Ok(json!({\r\n                    \"answer\": answer,\r\n                    \"answer_type\": \"text\"\r\n                }))\r\n            }\r\n            _ => Ok(json!({\"error\": \"Invalid question type\"})),\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// RequestHumanReviewTool\r\n// ============================================================================\r\n\r\npub struct RequestHumanReviewTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl RequestHumanReviewTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for RequestHumanReviewTool {\r\n    fn name(&self) -> &str {\r\n        \"request_human_review\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Request human intervention when you detect an infinite loop, unclear situation, \\\r\n         or when you're about to repeat the same feedback. This prevents endless loops \\\r\n         and escalates issues that require human judgment.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"reason\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Brief reason for requesting human review (e.g., 'Detected infinite loop', 'Unclear if task is non-core')\"\r\n                },\r\n                \"details\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Detailed explanation of the situation, including what you observed and why you cannot proceed\"\r\n                },\r\n                \"suspected_issue\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"infinite_loop\", \"unclear_requirements\", \"actor_not_responding\", \"hallucination_detected\", \"other\"],\r\n                    \"description\": \"Type of issue detected\"\r\n                }\r\n            },\r\n            \"required\": [\"reason\", \"details\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        use crate::data::{Feedback, FeedbackType, Severity};\r\n        use crate::storage::append_feedback;\r\n\r\n        let reason = args.get(\"reason\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'reason'\".to_string()))?;\r\n\r\n        let details = args.get(\"details\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| adk_core::AdkError::Tool(\"Missing 'details'\".to_string()))?;\r\n\r\n        let suspected_issue = args.get(\"suspected_issue\")\r\n            .and_then(|v| v.as_str())\r\n            .unwrap_or(\"other\");\r\n\r\n        // Record as critical feedback requiring human review\r\n        let feedback_details = format!(\r\n            \"🚨 HUMAN REVIEW REQUESTED 🚨\\n\\\r\n             Reason: {}\\n\\\r\n             Suspected Issue: {}\\n\\\r\n             Details: {}\\n\\\r\n             \\n\\\r\n             The Critic agent has detected a situation that requires human intervention. \\\r\n             Please review the session logs and decide how to proceed.\",\r\n            reason, suspected_issue, details\r\n        );\r\n\r\n        let feedback = Feedback {\r\n            feedback_type: FeedbackType::Suggestion, // Use suggestion type for human review\r\n            severity: Severity::Critical,\r\n            details: feedback_details.clone(),\r\n            suggested_fix: Some(\"Human review required - please examine session state and provide guidance\".to_string()),\r\n            timestamp: chrono::Utc::now(),\r\n        };\r\n\r\n        append_feedback(&self.session_id, &feedback)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        // Print prominent warning to console\r\n        println!(\"\\n╔═══════════════════════════════════════════════════════════╗\");\r\n        println!(\"║  🚨 HUMAN REVIEW REQUESTED - CRITIC NEEDS HELP 🚨        ║\");\r\n        println!(\"╚═══════════════════════════════════════════════════════════╝\");\r\n        println!(\"Reason: {}\", reason);\r\n        println!(\"Type: {}\", suspected_issue);\r\n        println!(\"Details: {}\", details);\r\n        println!(\"═══════════════════════════════════════════════════════════\\n\");\r\n\r\n        // Return error to stop the loop - this will trigger ResilientAgent HITL\r\n        Err(adk_core::AdkError::Agent(format!(\r\n            \"Human review requested: {}. The loop will stop to prevent infinite iteration.\",\r\n            reason\r\n        )))\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 20.0,
      "lines_of_code": 419,
      "number_of_classes": 4,
      "number_of_functions": 19
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "crate::data",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "crate::storage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "trait",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "dialoguer",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": true,
        "line_number": null,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component implements four session-scoped control tools that enable agent-human interaction within the cowork-core framework:\n\n1. **ProvideFeedbackTool**: Records structured feedback (build errors, quality issues, missing requirements, suggestions) with severity levels (critical/major/minor). Feedback is stored via append_feedback() and made available to the Actor agent in subsequent iterations.\n\n2. **RequestReplanningTool**: Handles fundamental architectural issues by recording replanning requests. Captures issue types (design_flaw, missing_dependency, architecture_conflict, requirement_mismatch), severity, affected features, and suggested approaches. Outputs prominent console warnings and provides guidance for the Check Agent.\n\n3. **AskUserTool**: Provides CLI-based user interaction supporting yes/no confirmations and text input. Uses dialoguer crate for interactive prompts. Stateless design (no session_id required) suitable for immediate user queries.\n\n4. **RequestHumanReviewTool**: Escalation mechanism for infinite loops, unclear requirements, or actor non-responsiveness. Records critical feedback with prominent console warnings (boxed visual formatting) and returns an Agent error to halt execution and trigger Human-in-The-Loop (HITL) protocols.\n\nAll tools implement the adk_core::Tool trait with async_trait, returning serde_json::Value responses. The tools use FeedbackType and Severity enums for categorization, with timestamp generation via chrono::Utc::now().\n\n**Business Logic Flow:**\n- Parameter validation uses ok_or_else pattern with AdkError::Tool wrapping\n- Severity mapping defaults to Minor/Minor (moderate maps to Minor)\n- Console output distinguishes severity levels with emoji warnings (⚠️ 🚨)\n- Error handling propagates storage errors via map_err conversion",
    "interfaces": [
      {
        "description": "Records structured feedback to the Actor agent for the next iteration. Supports build_error, quality_issue, missing_requirement, and suggestion types with critical/major/minor severity levels.",
        "interface_type": "struct",
        "name": "ProvideFeedbackTool",
        "parameters": [
          {
            "description": "Session identifier for feedback storage",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Tool implementation providing structured feedback recording.",
        "interface_type": "impl Tool",
        "name": "ProvideFeedbackTool",
        "parameters": [],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Handles replanning requests for fundamental architectural issues discovered during implementation.",
        "interface_type": "struct",
        "name": "RequestReplanningTool",
        "parameters": [
          {
            "description": "Session identifier for replanning request storage",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Tool implementation for requesting plan re-evaluation with issue categorization and severity assessment.",
        "interface_type": "impl Tool",
        "name": "RequestReplanningTool",
        "parameters": [],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "CLI-based user interaction tool for yes/no confirmations and text input queries. Stateless design.",
        "interface_type": "struct",
        "name": "AskUserTool",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Tool implementation for synchronous user interaction via dialoguer prompts.",
        "interface_type": "impl Tool",
        "name": "AskUserTool",
        "parameters": [],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Human escalation tool for infinite loops or situations requiring human judgment.",
        "interface_type": "struct",
        "name": "RequestHumanReviewTool",
        "parameters": [
          {
            "description": "Session identifier for review request tracking",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Tool implementation that halts execution and triggers Human-in-The-Loop protocols via Agent errors.",
        "interface_type": "impl Tool",
        "name": "RequestHumanReviewTool",
        "parameters": [],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Returns the tool identifier used for tool registration and invocation",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns description text describing tool purpose and usage guidelines",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON schema for parameter validation",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Executes the tool logic with provided arguments and context",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Tool arguments as JSON value",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Enabling bidirectional communication between AI agents and human operators through structured feedback channels with severity classification",
      "Facilitating workflow control by allowing agents to request plan replanning when fundamental architectural issues are discovered during implementation",
      "Providing synchronous user interaction capabilities for yes/no confirmations and free-text input during agent execution",
      "Serving as an escalation mechanism to halt execution and trigger Human-in-The-Loop (HITL) protocols when infinite loops or unclear situations are detected",
      "Recording session-scoped feedback events with timestamps and categorization for audit trails and agent context management"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\tools\\data_tools.rs",
      "functions": [
        "CreateRequirementTool::new",
        "CreateRequirementTool::execute",
        "AddFeatureTool::new",
        "AddFeatureTool::execute",
        "CreateDesignComponentTool::new",
        "CreateDesignComponentTool::execute",
        "CreateTaskTool::new",
        "CreateTaskTool::execute",
        "UpdateFeatureStatusTool::new",
        "UpdateFeatureStatusTool::execute",
        "UpdateTaskStatusTool::new",
        "UpdateTaskStatusTool::execute",
        "UpdateTaskTool::new",
        "UpdateTaskTool::execute",
        "DeleteTaskTool::new",
        "DeleteTaskTool::execute",
        "GetRequirementsTool::new",
        "GetRequirementsTool::execute",
        "GetDesignTool::new",
        "GetDesignTool::execute",
        "GetPlanTool::new",
        "GetPlanTool::execute"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "CreateRequirementTool",
        "AddFeatureTool",
        "CreateDesignComponentTool",
        "CreateTaskTool",
        "UpdateFeatureStatusTool",
        "UpdateTaskStatusTool",
        "UpdateTaskTool",
        "DeleteTaskTool",
        "GetRequirementsTool",
        "GetDesignTool",
        "GetPlanTool"
      ],
      "name": "data_tools.rs",
      "source_summary": "// Data operation tools - Create and modify structured data (Session-scoped)\r\nuse crate::data::*;\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext, AdkError};\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\n// ============================================================================\r\n// CreateRequirementTool\r\n// ============================================================================\r\n\r\npub struct CreateRequirementTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CreateRequirementTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CreateRequirementTool {\r\n    fn name(&self) -> &str {\r\n        \"create_requirement\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Create a new requirement in requirements.json. Requirements define what \\\r\n         the system must do. Each requirement should be SMART (Specific, Measurable, \\\r\n         Achievable, Relevant, Time-bound) with clear acceptance criteria.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"title\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Brief requirement title\"\r\n                },\r\n                \"description\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Detailed description of the requirement\"\r\n                },\r\n                \"priority\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"high\", \"medium\", \"low\"],\r\n                    \"description\": \"Priority level\"\r\n                },\r\n                \"category\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"functional\", \"non_functional\"],\r\n                    \"description\": \"Requirement category\"\r\n                },\r\n                \"acceptance_criteria\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"List of acceptance criteria\"\r\n                }\r\n            },\r\n            \"required\": [\"title\", \"description\", \"priority\", \"category\", \"acceptance_criteria\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut reqs = load_requirements(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let req_id = generate_id(\"REQ\", reqs.requirements.len());\r\n\r\n        // Extract and validate required fields with better error messages\r\n        let title = args.get(\"title\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'title' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let description = args.get(\"description\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'description' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let priority_str = args.get(\"priority\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'priority' parameter\".to_string()))?;\r\n\r\n        let priority = match priority_str {\r\n            \"high\" => Priority::High,\r\n            \"medium\" => Priority::Medium,\r\n            \"low\" => Priority::Low,\r\n            _ => Priority::Medium,\r\n        };\r\n\r\n        let category_str = args.get(\"category\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'category' parameter\".to_string()))?;\r\n\r\n        let category = match category_str {\r\n            \"functional\" => RequirementCategory::Functional,\r\n            \"non_functional\" => RequirementCategory::NonFunctional,\r\n            _ => RequirementCategory::Functional,\r\n        };\r\n\r\n        let acceptance_criteria = args.get(\"acceptance_criteria\")\r\n            .and_then(|v| v.as_array())\r\n            .ok_or_else(|| AdkError::Tool(\r\n                \"Missing or invalid 'acceptance_criteria' parameter. Expected an array of criteria.\".to_string()\r\n            ))?\r\n            .iter()\r\n            .enumerate()\r\n            .map(|(i, v)| {\r\n                v.as_str()\r\n                    .ok_or_else(|| AdkError::Tool(format!(\"acceptance_criteria[{}] is not a string\", i)))\r\n                    .map(String::from)\r\n            })\r\n            .collect::<Result<Vec<String>, AdkError>>()?;\r\n\r\n        let requirement = Requirement {\r\n            id: req_id.clone(),\r\n            title,\r\n            description,\r\n            priority,\r\n            category,\r\n            acceptance_criteria,\r\n            related_features: vec![],\r\n        };\r\n\r\n        reqs.requirements.push(requirement.clone());\r\n        reqs.updated_at = chrono::Utc::now();\r\n        save_requirements(&self.session_id, &reqs).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        println!(\"✅ Created: {} - {}\", req_id, requirement.title);\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"requirement_id\": req_id,\r\n            \"message\": format!(\"Requirement {} created successfully\", req_id)\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// AddFeatureTool\r\n// ============================================================================\r\n\r\npub struct AddFeatureTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl AddFeatureTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for AddFeatureTool {\r\n    fn name(&self) -> &str {\r\n        \"add_feature\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Add a new feature to feature_list.json. Features are concrete \\\r\n         functionalities that implement one or more requirements. Each \\\r\n         feature will later be broken down into implementation tasks.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"name\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Feature name\"\r\n                },\r\n                \"description\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Detailed description\"\r\n                },\r\n                \"requirement_ids\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"IDs of requirements this feature implements\"\r\n                },\r\n                \"completion_criteria\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"Criteria for feature completion\"\r\n                }\r\n            },\r\n            \"required\": [\"name\", \"description\", \"requirement_ids\", \"completion_criteria\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut features = load_feature_list(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let feat_id = generate_id(\"FEAT\", features.features.len());\r\n\r\n        // Extract and validate required fields with better error messages\r\n        let name = args.get(\"name\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'name' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let description = args.get(\"description\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'description' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let requirement_ids = args.get(\"requirement_ids\")\r\n            .and_then(|v| v.as_array())\r\n            .ok_or_else(|| AdkError::Tool(\r\n                \"Missing or invalid 'requirement_ids' parameter. Expected an array of requirement IDs.\".to_string()\r\n            ))?\r\n            .iter()\r\n            .enumerate()\r\n            .map(|(i, v)| {\r\n                v.as_str()\r\n                    .ok_or_else(|| AdkError::Tool(format!(\"requirement_ids[{}] is not a string\", i)))\r\n                    .map(String::from)\r\n            })\r\n            .collect::<Result<Vec<String>, AdkError>>()?;\r\n\r\n        let completion_criteria = args.get(\"completion_criteria\")\r\n            .and_then(|v| v.as_array())\r\n            .ok_or_else(|| AdkError::Tool(\r\n                \"Missing or invalid 'completion_criteria' parameter. Expected an array of criteria.\".to_string()\r\n            ))?\r\n            .iter()\r\n            .enumerate()\r\n            .map(|(i, v)| {\r\n                v.as_str()\r\n                    .ok_or_else(|| AdkError::Tool(format!(\"completion_criteria[{}] is not a string\", i)))\r\n                    .map(String::from)\r\n            })\r\n            .collect::<Result<Vec<String>, AdkError>>()?;\r\n\r\n        let feature = Feature {\r\n            id: feat_id.clone(),\r\n            name,\r\n            description,\r\n            requirement_ids,\r\n            status: FeatureStatus::Pending,\r\n            assigned_to_tasks: vec![],\r\n            completion_criteria,\r\n            created_at: chrono::Utc::now(),\r\n            completed_at: None,\r\n            metadata: FeatureMetadata::default(),\r\n        };\r\n\r\n        features.features.push(feature);\r\n        save_feature_list(&self.session_id, &features).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"feature_id\": feat_id,\r\n            \"message\": format!(\"Feature {} created successfully\", feat_id)\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CreateDesignComponentTool\r\n// ============================================================================\r\n\r\npub struct CreateDesignComponentTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CreateDesignComponentTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CreateDesignComponentTool {\r\n    fn name(&self) -> &str {\r\n        \"create_design_component\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Create a new component in design_spec.json. Components are the \\\r\n         architectural building blocks (services, modules, UI components) \\\r\n         that implement features.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"name\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Component name\"\r\n                },\r\n                \"component_type\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"backend_service\", \"frontend_component\", \"database\", \"api_gateway\"],\r\n                    \"description\": \"Type of component\"\r\n                },\r\n                \"responsibilities\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"List of responsibilities\"\r\n                },\r\n                \"technology\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Technology stack\"\r\n                },\r\n                \"related_features\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"Related feature IDs\"\r\n                }\r\n            },\r\n            \"required\": [\"name\", \"component_type\", \"responsibilities\", \"technology\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut design = load_design_spec(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let comp_id = generate_id(\"COMP\", design.architecture.components.len());\r\n\r\n        let component_type = args.get(\"component_type\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'component_type' parameter\".to_string()))?;\r\n        \r\n        let component_type = match component_type {\r\n            \"backend_service\" => ComponentType::BackendService,\r\n            \"frontend_component\" => ComponentType::FrontendComponent,\r\n            \"database\" => ComponentType::Database,\r\n            \"api_gateway\" => ComponentType::ApiGateway,\r\n            other => ComponentType::Other(other.to_string()),\r\n        };\r\n\r\n        let name = args.get(\"name\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'name' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let technology = args.get(\"technology\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'technology' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let responsibilities = args.get(\"responsibilities\")\r\n            .and_then(|v| v.as_array())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'responsibilities' parameter (must be an array)\".to_string()))?\r\n            .iter()\r\n            .filter_map(|v| v.as_str().map(|s| s.to_string()))\r\n            .collect::<Vec<String>>();\r\n\r\n        if responsibilities.is_empty() {\r\n            return Err(AdkError::Tool(\"'responsibilities' array cannot be empty\".to_string()));\r\n        }\r\n\r\n        let related_features = args.get(\"related_features\")\r\n            .and_then(|v| v.as_array())\r\n            .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect())\r\n            .unwrap_or_default();\r\n\r\n        let component = DesignComponent {\r\n            id: comp_id.clone(),\r\n            name,\r\n            component_type,\r\n            responsibilities,\r\n            technology,\r\n            interfaces: vec![],\r\n            related_features,\r\n        };\r\n\r\n        design.architecture.components.push(component.clone());\r\n        save_design_spec(&self.session_id, &design).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        println!(\"🏗️  Created component: {} - {}\", comp_id, component.name);\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"component_id\": comp_id,\r\n            \"message\": format!(\"Component {} created successfully\", comp_id)\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CreateTaskTool\r\n// ============================================================================\r\n\r\npub struct CreateTaskTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CreateTaskTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CreateTaskTool {\r\n    fn name(&self) -> &str {\r\n        \"create_task\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Create an implementation task in implementation_plan.json. Tasks \\\r\n         are concrete coding work items that implement features.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"title\": {\"type\": \"string\"},\r\n                \"description\": {\"type\": \"string\"},\r\n                \"feature_id\": {\"type\": \"string\"},\r\n                \"component_id\": {\"type\": \"string\"},\r\n                \"files_to_create\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"}\r\n                },\r\n                \"dependencies\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"Task IDs that must be completed first\"\r\n                },\r\n                \"acceptance_criteria\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"}\r\n                }\r\n            },\r\n            \"required\": [\"title\", \"description\", \"feature_id\", \"component_id\", \"acceptance_criteria\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut plan = load_implementation_plan(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let task_id = generate_id(\"TASK\", plan.tasks.len());\r\n\r\n        // Extract and validate required fields with better error messages\r\n        let title = args.get(\"title\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'title' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let description = args.get(\"description\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'description' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let feature_id = args.get(\"feature_id\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'feature_id' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let component_id = args.get(\"component_id\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'component_id' parameter\".to_string()))?\r\n            .to_string();\r\n\r\n        let dependencies: Vec<String> = args.get(\"dependencies\")\r\n            .and_then(|v| v.as_array())\r\n            .map(|arr| {\r\n                arr.iter()\r\n                    .enumerate()\r\n                    .map(|(i, v)| {\r\n                        v.as_str()\r\n                            .ok_or_else(|| AdkError::Tool(format!(\"dependencies[{}] is not a string\", i)))\r\n                            .map(String::from)\r\n                    })\r\n                    .collect::<Result<Vec<String>, AdkError>>()\r\n            })\r\n            .transpose()?\r\n            .unwrap_or_default();\r\n\r\n        let files_to_create: Vec<String> = args.get(\"files_to_create\")\r\n            .and_then(|v| v.as_array())\r\n            .map(|arr| {\r\n                arr.iter()\r\n                    .enumerate()\r\n                    .map(|(i, v)| {\r\n                        v.as_str()\r\n                            .ok_or_else(|| AdkError::Tool(format!(\"files_to_create[{}] is not a string\", i)))\r\n                            .map(String::from)\r\n                    })\r\n                    .collect::<Result<Vec<String>, AdkError>>()\r\n            })\r\n            .transpose()?\r\n            .unwrap_or_default();\r\n\r\n        let acceptance_criteria = args.get(\"acceptance_criteria\")\r\n            .and_then(|v| v.as_array())\r\n            .ok_or_else(|| AdkError::Tool(\r\n                \"Missing or invalid 'acceptance_criteria' parameter. Expected an array of criteria.\".to_string()\r\n            ))?\r\n            .iter()\r\n            .enumerate()\r\n            .map(|(i, v)| {\r\n                v.as_str()\r\n                    .ok_or_else(|| AdkError::Tool(format!(\"acceptance_criteria[{}] is not a string\", i)))\r\n                    .map(String::from)\r\n            })\r\n            .collect::<Result<Vec<String>, AdkError>>()?;\r\n\r\n        let task = Task {\r\n            id: task_id.clone(),\r\n            title,\r\n            description,\r\n            feature_id,\r\n            component_id,\r\n            status: TaskStatus::Pending,\r\n            dependencies,\r\n            estimated_effort: None,\r\n            files_to_create,\r\n            acceptance_criteria,\r\n            created_at: chrono::Utc::now(),\r\n            started_at: None,\r\n            completed_at: None,\r\n        };\r\n\r\n        plan.tasks.push(task);\r\n        save_implementation_plan(&self.session_id, &plan).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"task_id\": task_id,\r\n            \"message\": format!(\"Task {} created successfully\", task_id)\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Update Status Tools\r\n// ============================================================================\r\n\r\npub struct UpdateFeatureStatusTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl UpdateFeatureStatusTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for UpdateFeatureStatusTool {\r\n    fn name(&self) -> &str {\r\n        \"update_feature_status\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Update the status of a feature. Valid transitions: \\\r\n         pending → in_progress → completed.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"feature_id\": {\"type\": \"string\"},\r\n                \"new_status\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"pending\", \"in_progress\", \"completed\", \"blocked\"]\r\n                }\r\n            },\r\n            \"required\": [\"feature_id\", \"new_status\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut features = load_feature_list(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let feature_id = args[\"feature_id\"].as_str().unwrap();\r\n        let new_status_str = args[\"new_status\"].as_str().unwrap();\r\n\r\n        let new_status = match new_status_str {\r\n            \"pending\" => FeatureStatus::Pending,\r\n            \"in_progress\" => FeatureStatus::InProgress,\r\n            \"completed\" => FeatureStatus::Completed,\r\n            \"blocked\" => FeatureStatus::Blocked,\r\n            _ => FeatureStatus::Pending,\r\n        };\r\n\r\n        if let Some(feature) = features.features.iter_mut().find(|f| f.id == feature_id) {\r\n            feature.status = new_status;\r\n            if new_status_str == \"completed\" {\r\n                feature.completed_at = Some(chrono::Utc::now());\r\n            }\r\n            save_feature_list(&self.session_id, &features).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n            Ok(json!({\r\n                \"status\": \"success\",\r\n                \"feature_id\": feature_id,\r\n                \"new_status\": new_status_str,\r\n                \"message\": format!(\"Feature {} status updated to {}\", feature_id, new_status_str)\r\n            }))\r\n        } else {\r\n            Ok(json!({\r\n                \"status\": \"error\",\r\n                \"message\": format!(\"Feature {} not found\", feature_id)\r\n            }))\r\n        }\r\n    }\r\n}\r\n\r\npub struct UpdateTaskStatusTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl UpdateTaskStatusTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for UpdateTaskStatusTool {\r\n    fn name(&self) -> &str {\r\n        \"update_task_status\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Update task status. Call this as you start and complete tasks.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"task_id\": {\"type\": \"string\"},\r\n                \"new_status\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"pending\", \"in_progress\", \"completed\", \"blocked\"]\r\n                }\r\n            },\r\n            \"required\": [\"task_id\", \"new_status\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let mut plan = load_implementation_plan(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        let task_id = args.get(\"task_id\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'task_id' parameter\".to_string()))?;\r\n        \r\n        let new_status_str = args.get(\"new_status\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing or invalid 'new_status' parameter\".to_string()))?;\r\n\r\n        let new_status = match new_status_str {\r\n            \"pending\" => TaskStatus::Pending,\r\n            \"in_progress\" => TaskStatus::InProgress,\r\n            \"completed\" => TaskStatus::Completed,\r\n            \"blocked\" => TaskStatus::Blocked,\r\n            _ => return Err(AdkError::Tool(format!(\"Invalid status: {}. Must be one of: pending, in_progress, completed, blocked\", new_status_str))),\r\n        };\r\n\r\n        // Find and update task\r\n        let feature_id = if let Some(task) = plan.tasks.iter_mut().find(|t| t.id == task_id) {\r\n            task.status = new_status;\r\n            match new_status_str {\r\n                \"in_progress\" => task.started_at = Some(chrono::Utc::now()),\r\n                \"completed\" => task.completed_at = Some(chrono::Utc::now()),\r\n                _ => {}\r\n            }\r\n            \r\n            let fid = task.feature_id.clone();\r\n            save_implementation_plan(&self.session_id, &plan).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n            println!(\"✓ Task {} → {}\", task_id, new_status_str);\r\n            fid\r\n        } else {\r\n            return Ok(json!({\r\n                \"status\": \"error\",\r\n                \"message\": format!(\"Task {} not found\", task_id)\r\n            }));\r\n        };\r\n\r\n        // Update corresponding feature status\r\n        if new_status == TaskStatus::Completed {\r\n            update_feature_status_if_needed(&self.session_id, &feature_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n        }\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"task_id\": task_id,\r\n            \"new_status\": new_status_str\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// UpdateTaskTool - Modify task properties\r\n// ============================================================================\r\n\r\npub struct UpdateTaskTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl UpdateTaskTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for UpdateTaskTool {\r\n    fn name(&self) -> &str {\r\n        \"update_task\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Update task properties such as title, description, dependencies, or files. \\\r\n         Use this when you discover that task requirements have changed during implementation.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"task_id\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"ID of the task to update\"\r\n                },\r\n                \"title\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"New title (optional)\"\r\n                },\r\n                \"description\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"New description (optional)\"\r\n                },\r\n                \"dependencies\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"New list of task IDs that must be completed first (optional)\"\r\n                },\r\n                \"files_to_create\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"New list of files to create (optional)\"\r\n                },\r\n                \"acceptance_criteria\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"New acceptance criteria (optional)\"\r\n                },\r\n                \"reason\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Reason for this update\"\r\n                }\r\n            },\r\n            \"required\": [\"task_id\", \"reason\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let task_id = args.get(\"task_id\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing 'task_id' parameter\".to_string()))?;\r\n        \r\n        let reason = args.get(\"reason\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing 'reason' parameter\".to_string()))?;\r\n\r\n        let mut plan = load_implementation_plan(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        // First, find the task index\r\n        let task_idx = plan.tasks.iter()\r\n            .position(|t| t.id == task_id)\r\n            .ok_or_else(|| AdkError::Tool(format!(\"Task {} not found\", task_id)))?;\r\n\r\n        let mut updates = Vec::new();\r\n\r\n        // Update title if provided\r\n        if let Some(title) = args.get(\"title\").and_then(|v| v.as_str()) {\r\n            plan.tasks[task_idx].title = title.to_string();\r\n            updates.push(format!(\"title → {}\", title));\r\n        }\r\n\r\n        // Update description if provided\r\n        if let Some(desc) = args.get(\"description\").and_then(|v| v.as_str()) {\r\n            plan.tasks[task_idx].description = desc.to_string();\r\n            updates.push(\"description updated\".to_string());\r\n        }\r\n\r\n        // Update dependencies if provided\r\n        if let Some(deps) = args.get(\"dependencies\").and_then(|v| v.as_array()) {\r\n            let new_deps: Vec<String> = deps.iter()\r\n                .filter_map(|v| v.as_str().map(String::from))\r\n                .collect();\r\n            \r\n            // Validate that all dependency task IDs exist\r\n            for dep_id in &new_deps {\r\n                if !plan.tasks.iter().any(|t| &t.id == dep_id) {\r\n                    return Err(AdkError::Tool(format!(\"Dependency task {} not found\", dep_id)));\r\n                }\r\n            }\r\n            \r\n            plan.tasks[task_idx].dependencies = new_deps.clone();\r\n            updates.push(format!(\"dependencies → {:?}\", new_deps));\r\n        }\r\n\r\n        // Update files_to_create if provided\r\n        if let Some(files) = args.get(\"files_to_create\").and_then(|v| v.as_array()) {\r\n            plan.tasks[task_idx].files_to_create = files.iter()\r\n                .filter_map(|v| v.as_str().map(String::from))\r\n                .collect();\r\n            updates.push(\"files_to_create updated\".to_string());\r\n        }\r\n\r\n        // Update acceptance_criteria if provided\r\n        if let Some(criteria) = args.get(\"acceptance_criteria\").and_then(|v| v.as_array()) {\r\n            plan.tasks[task_idx].acceptance_criteria = criteria.iter()\r\n                .filter_map(|v| v.as_str().map(String::from))\r\n                .collect();\r\n            updates.push(\"acceptance_criteria updated\".to_string());\r\n        }\r\n\r\n        save_implementation_plan(&self.session_id, &plan).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        // Log the update with reason\r\n        println!(\"✓ Task {} updated: {}\", task_id, updates.join(\", \"));\r\n        println!(\"  Reason: {}\", reason);\r\n\r\n        // Record to feedback for audit trail\r\n        let feedback = crate::data::Feedback {\r\n            feedback_type: crate::data::FeedbackType::Suggestion,\r\n            severity: crate::data::Severity::Minor,\r\n            details: format!(\"Task {} updated: {}. Reason: {}\", task_id, updates.join(\", \"), reason),\r\n            suggested_fix: None,\r\n            timestamp: chrono::Utc::now(),\r\n        };\r\n        let _ = crate::storage::append_feedback(&self.session_id, &feedback);\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"task_id\": task_id,\r\n            \"updates\": updates,\r\n            \"reason\": reason\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// DeleteTaskTool - Remove task and clean up dependencies\r\n// ============================================================================\r\n\r\npub struct DeleteTaskTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl DeleteTaskTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for DeleteTaskTool {\r\n    fn name(&self) -> &str {\r\n        \"delete_task\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Delete a task from the plan. This will also remove references to this task \\\r\n         from other tasks' dependencies. Use this when a task is no longer needed \\\r\n         or was incorrectly planned.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"task_id\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"ID of the task to delete\"\r\n                },\r\n                \"reason\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Reason for deleting this task\"\r\n                }\r\n            },\r\n            \"required\": [\"task_id\", \"reason\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let task_id = args.get(\"task_id\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing 'task_id' parameter\".to_string()))?;\r\n        \r\n        let reason = args.get(\"reason\")\r\n            .and_then(|v| v.as_str())\r\n            .ok_or_else(|| AdkError::Tool(\"Missing 'reason' parameter\".to_string()))?;\r\n\r\n        let mut plan = load_implementation_plan(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        // Check if task exists\r\n        let task_exists = plan.tasks.iter().any(|t| t.id == task_id);\r\n        if !task_exists {\r\n            return Err(AdkError::Tool(format!(\"Task {} not found\", task_id)));\r\n        }\r\n\r\n        // Check if this task is in_progress or completed\r\n        if let Some(task) = plan.tasks.iter().find(|t| t.id == task_id) {\r\n            if task.status == crate::data::TaskStatus::InProgress {\r\n                return Err(AdkError::Tool(format!(\r\n                    \"Cannot delete task {} because it's currently in progress. \\\r\n                     Set status to pending or blocked first.\", task_id\r\n                )));\r\n            }\r\n            if task.status == crate::data::TaskStatus::Completed {\r\n                return Err(AdkError::Tool(format!(\r\n                    \"Cannot delete task {} because it's already completed. \\\r\n                     Consider keeping it for documentation.\", task_id\r\n                )));\r\n            }\r\n        }\r\n\r\n        // Remove the task\r\n        plan.tasks.retain(|t| t.id != task_id);\r\n\r\n        // Clean up dependencies - remove this task_id from other tasks' dependencies\r\n        let mut affected_tasks = Vec::new();\r\n        for task in &mut plan.tasks {\r\n            let before_len = task.dependencies.len();\r\n            task.dependencies.retain(|dep| dep != task_id);\r\n            let after_len = task.dependencies.len();\r\n            \r\n            if before_len != after_len {\r\n                affected_tasks.push(task.id.clone());\r\n            }\r\n        }\r\n\r\n        save_implementation_plan(&self.session_id, &plan).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        println!(\"✓ Task {} deleted\", task_id);\r\n        if !affected_tasks.is_empty() {\r\n            println!(\"  Cleaned dependencies from: {}\", affected_tasks.join(\", \"));\r\n        }\r\n        println!(\"  Reason: {}\", reason);\r\n\r\n        // Record to feedback for audit trail\r\n        let feedback = crate::data::Feedback {\r\n            feedback_type: crate::data::FeedbackType::Suggestion,\r\n            severity: crate::data::Severity::Minor,\r\n            details: format!(\r\n                \"Task {} deleted. Reason: {}. Affected tasks: {}\", \r\n                task_id, reason, \r\n                if affected_tasks.is_empty() { \"none\".to_string() } else { affected_tasks.join(\", \") }\r\n            ),\r\n            suggested_fix: None,\r\n            timestamp: chrono::Utc::now(),\r\n        };\r\n        let _ = crate::storage::append_feedback(&self.session_id, &feedback);\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"task_id\": task_id,\r\n            \"affected_tasks\": affected_tasks,\r\n            \"reason\": reason,\r\n            \"message\": format!(\"Task {} deleted successfully\", task_id)\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Get/Read Tools\r\n// ============================================================================\r\n\r\npub struct GetRequirementsTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl GetRequirementsTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for GetRequirementsTool {\r\n    fn name(&self) -> &str {\r\n        \"get_requirements\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Retrieve all requirements and features.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {}\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let requirements = load_requirements(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n        let features = load_feature_list(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"requirements\": requirements.requirements,\r\n            \"features\": features.features\r\n        }))\r\n    }\r\n}\r\n\r\npub struct GetDesignTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl GetDesignTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for GetDesignTool {\r\n    fn name(&self) -> &str {\r\n        \"get_design\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Retrieve the design specification.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let design = load_design_spec(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n        Ok(serde_json::to_value(design).map_err(|e| AdkError::Tool(e.to_string()))?)\r\n    }\r\n}\r\n\r\npub struct GetPlanTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl GetPlanTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for GetPlanTool {\r\n    fn name(&self) -> &str {\r\n        \"get_plan\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Retrieve the implementation plan with all tasks.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let plan = load_implementation_plan(&self.session_id).map_err(|e| AdkError::Tool(e.to_string()))?;\r\n        Ok(serde_json::to_value(plan).map_err(|e| AdkError::Tool(e.to_string()))?)\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 51.0,
      "lines_of_code": 1073,
      "number_of_classes": 10,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": 2,
        "name": "crate::data",
        "path": "crate::data",
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": 3,
        "name": "crate::storage",
        "path": "crate::storage",
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": 4,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": 5,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": 6,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": 7,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The `data_tools.rs` module implements a comprehensive set of data operation tools for the ADK (Agent Development Kit) framework, specifically designed for managing collaborative development artifacts within a session-scoped context. This module defines ten distinct Tool implementations that enable AI agents to programmatically create, read, update, and delete project management entities including requirements, features, design components, and implementation tasks.\n\nThe module follows a clear taxonomy of operations:\n1. **Creation Tools** (4): CreateRequirementTool, AddFeatureTool, CreateDesignComponentTool, CreateTaskTool - enable structured creation of project artifacts with automatic ID generation (REQ*, FEAT*, COMP*, TASK*) and comprehensive validation\n2. **Status Management Tools** (2): UpdateFeatureStatusTool, UpdateTaskStatusTool - facilitate state transitions (pending → in_progress → completed) with automatic timestamp tracking and cascading updates\n3. **Modification/Removal Tools** (2): UpdateTaskTool, DeleteTaskTool - allow dynamic task plan adjustments with dependency cleanup, reason tracking, and audit logging\n4. **Retrieval Tools** (3): GetRequirementsTool, GetDesignTool, GetPlanTool - provide read-only access to project state snapshots\n\nEach tool implements the `Tool` trait from `adk_core`, defining name(), description(), parameters_schema(), and execute() methods. The tools leverage JSON Schema for parameter validation, serialize data using serde_json, and persist state through storage functions (load_*/save_*). Key features include array element type checking with enumerated error messages, automatic feature status updates when tasks complete, dependency management with circular reference prevention, and feedback logging for audit trails.",
    "interfaces": [
      {
        "description": "Creates new requirements with SMART criteria validation, priority/category classification, and acceptance criteria management",
        "interface_type": "struct_impl_Trait",
        "name": "CreateRequirementTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments containing title, description, priority, category, acceptance_criteria",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Adds features that implement requirements, with completion criteria and status tracking",
        "interface_type": "struct_impl_Trait",
        "name": "AddFeatureTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with name, description, requirement_ids, completion_criteria",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Creates architectural design components (services, modules, UI components) with technology stack specification",
        "interface_type": "struct_impl_Trait",
        "name": "CreateDesignComponentTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with name, component_type, responsibilities, technology, related_features",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Creates implementation tasks linked to features and components with dependency management",
        "interface_type": "struct_impl_Trait",
        "name": "CreateTaskTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with title, description, feature_id, component_id, acceptance_criteria",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Updates feature status with valid transitions and completion timestamp tracking",
        "interface_type": "struct_impl_Trait",
        "name": "UpdateFeatureStatusTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with feature_id and new_status (pending, in_progress, completed, blocked)",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Updates task status with automatic started_at/completed_at timestamps and cascading feature updates",
        "interface_type": "struct_impl_Trait",
        "name": "UpdateTaskStatusTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with task_id and new_status",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Modifies task properties (title, description, dependencies, files, acceptance criteria) with change tracking and audit logging",
        "interface_type": "struct_impl_Trait",
        "name": "UpdateTaskTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with task_id, reason, and optional fields to update",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Removes tasks from plan with dependency cleanup, status validation (blocks deletion of in_progress/completed), and audit logging",
        "interface_type": "struct_impl_Trait",
        "name": "DeleteTaskTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments with task_id and reason",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Retrieves all requirements and features as a combined view",
        "interface_type": "struct_impl_Trait",
        "name": "GetRequirementsTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Empty JSON object as arguments",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Retrieves the complete design specification including architecture and components",
        "interface_type": "struct_impl_Trait",
        "name": "GetDesignTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Empty JSON object as arguments",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Retrieves the implementation plan with all tasks and their statuses",
        "interface_type": "struct_impl_Trait",
        "name": "GetPlanTool",
        "parameters": [
          {
            "description": "ToolContext for the operation",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Empty JSON object as arguments",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Provide CRUD operations for project management artifacts (requirements, features, design components, tasks) within a session-scoped context",
      "Enforce data validation and business rules including enum validation, array type checking, and status transition constraints",
      "Implement automatic ID generation using prefixed counters (REQ*, FEAT*, COMP*, TASK*) for entity identification",
      "Manage relationships between entities including requirement-to-feature mapping, feature-to-task linking, and inter-task dependencies",
      "Provide audit trail functionality through feedback logging for status changes, task deletions, and property modifications",
      "Support project workflow automation including cascading status updates and dependency cleanup operations"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Secure file operation tools with security constraints for AI agent use, providing read, write, list, delete, and command execution capabilities within current directory bounds.",
      "file_path": "crates\\cowork-core\\src\\tools\\file_tools.rs",
      "functions": [
        "validate_path_security",
        "ListFilesTool::name",
        "ListFilesTool::description",
        "ListFilesTool::parameters_schema",
        "ListFilesTool::execute",
        "should_ignore",
        "ReadFileTool::name",
        "ReadFileTool::description",
        "ReadFileTool::parameters_schema",
        "ReadFileTool::execute",
        "WriteFileTool::name",
        "WriteFileTool::description",
        "WriteFileTool::parameters_schema",
        "WriteFileTool::execute",
        "RunCommandTool::name",
        "RunCommandTool::description",
        "RunCommandTool::parameters_schema",
        "RunCommandTool::execute",
        "is_blocking_service_command",
        "DeleteFileTool::name",
        "DeleteFileTool::description",
        "DeleteFileTool::parameters_schema",
        "DeleteFileTool::execute",
        "DeleteDirectoryTool::name",
        "DeleteDirectoryTool::description",
        "DeleteDirectoryTool::parameters_schema",
        "DeleteDirectoryTool::execute"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "file_tools.rs",
      "source_summary": "// File operation tools with SECURITY constraints\nuse adk_core::{Tool, ToolContext};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::sync::Arc;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse walkdir::WalkDir;\n\n// ============================================================================\n// Security Helper - Path Validation\n// ============================================================================\n\n/// Validate that a path is safe to access\n/// Rules:\n/// 1. Must be relative path (no absolute paths like /tmp, C:\\)\n/// 2. Must not escape current directory (no ..)\n/// 3. Must be within current working directory or .cowork\nfn validate_path_security(path: &str) -> Result<PathBuf, String> {\n    let path_obj = Path::new(path);\n    \n    // Rule 1: Reject absolute paths\n    if path_obj.is_absolute() {\n        return Err(format!(\n            \"Security: Absolute paths are not allowed. Path '{}' must be relative to current directory.\",\n            path\n        ));\n    }\n    \n    // Rule 2: Reject parent directory access (..)\n    if path.contains(\"..\") {\n        return Err(format!(\n            \"Security: Parent directory access (..) is not allowed. Path: '{}'\",\n            path\n        ));\n    }\n    \n    // Rule 3: Canonicalize and verify it's within current directory\n    let current_dir = std::env::current_dir()\n        .map_err(|e| format!(\"Failed to get current directory: {}\", e))?;\n    \n    let full_path = current_dir.join(path);\n    \n    // Canonicalize both paths for reliable comparison\n    // On Windows, canonicalize() returns \\\\?\\ prefix paths\n    let normalized_current_dir = current_dir.canonicalize()\n        .map_err(|e| format!(\"Failed to canonicalize current directory: {}\", e))?;\n    \n    let canonical_path = if full_path.exists() {\n        full_path.canonicalize()\n            .map_err(|e| format!(\"Failed to resolve path: {}\", e))?\n    } else {\n        // For non-existent paths (e.g., files to be created), canonicalize parent directory\n        // then append the filename to get consistent UNC prefix format\n        if let Some(parent) = full_path.parent() {\n            let canonical_parent = parent.canonicalize()\n                .unwrap_or_else(|_| parent.to_path_buf());\n            if let Some(filename) = full_path.file_name() {\n                canonical_parent.join(filename)\n            } else {\n                full_path\n            }\n        } else {\n            full_path\n        }\n    };\n    \n    // Verify the path is within current directory\n    // Use normalized paths for comparison to handle Windows UNC path prefixes\n    if !canonical_path.starts_with(&normalized_current_dir) {\n        return Err(format!(\n            \"Security: Path escapes current directory. Path '{}' resolves to '{}', expected to be within '{}'\",\n            path,\n            canonical_path.display(),\n            normalized_current_dir.display()\n        ));\n    }\n    \n    Ok(canonical_path)\n}\n\n// ============================================================================\n// ListFilesTool\n// ============================================================================\n\npub struct ListFilesTool;\n\n#[async_trait]\nimpl Tool for ListFilesTool {\n    fn name(&self) -> &str {\n        \"list_files\"\n    }\n\n    fn description(&self) -> &str {\n        \"List files in a directory (recursively or non-recursively). \\\n         SECURITY: Only works within current directory. \\\n         Useful for understanding project structure.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"path\": {\n                    \"type\": \"string\",\n                    \"description\": \"Directory path to list (default: current directory). Must be relative path.\"\n                },\n                \"recursive\": {\n                    \"type\": \"boolean\",\n                    \"description\": \"Whether to list files recursively (default: false)\"\n                },\n                \"max_depth\": {\n                    \"type\": \"integer\",\n                    \"description\": \"Maximum depth for recursive listing (default: 3)\"\n                }\n            }\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let path = args.get(\"path\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\".\");\n        \n        // Security check\n        let safe_path = match validate_path_security(path) {\n            Ok(p) => p,\n            Err(e) => {\n                return Ok(json!({\n                    \"status\": \"security_error\",\n                    \"message\": e\n                }));\n            }\n        };\n        \n        let recursive = args.get(\"recursive\")\n            .and_then(|v| v.as_bool())\n            .unwrap_or(false);\n        \n        let max_depth = args.get(\"max_depth\")\n            .and_then(|v| v.as_u64())\n            .unwrap_or(3) as usize;\n\n        if !safe_path.exists() {\n            return Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Path not found: {}\", path)\n            }));\n        }\n\n        let mut files = Vec::new();\n        let mut directories = Vec::new();\n\n        if recursive {\n            // Recursive listing with max depth\n            let cwd = std::env::current_dir()\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get current dir: {}\", e)))?;\n\n            for entry in WalkDir::new(&safe_path)\n                .max_depth(max_depth)\n                .follow_links(false)\n                .into_iter()\n                .filter_entry(|e| {\n                    // Prune hidden directories early (except the root itself)\n                    if let Some(name) = e.file_name().to_str() {\n                        if name.starts_with('.') && name != \".\" {\n                            return false;\n                        }\n                    }\n                    true\n                })\n                .filter_map(|e| e.ok())\n            {\n                // Convert to relative path for stable ignore matching\n                let rel = entry.path().strip_prefix(&cwd).unwrap_or(entry.path());\n                let rel_str = rel.to_string_lossy();\n                let path_str = format!(\"./{}\", rel_str.trim_start_matches(\"./\"));\n\n                // Skip hidden files and common ignore patterns\n                if should_ignore(&path_str) {\n                    continue;\n                }\n\n                if entry.file_type().is_dir() {\n                    directories.push(path_str);\n                } else {\n                    files.push(path_str);\n                }\n            }\n        } else {\n            // Non-recursive listing\n            let cwd = std::env::current_dir()\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get current dir: {}\", e)))?;\n\n            let entries = fs::read_dir(&safe_path)\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read directory: {}\", e)))?;\n\n            for entry in entries {\n                let entry = entry.map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\n\n                // Skip hidden at top-level\n                if let Some(name) = entry.file_name().to_str() {\n                    if name.starts_with('.') {\n                        continue;\n                    }\n                }\n\n                let full = entry.path().to_path_buf();\n                let rel = full.strip_prefix(&cwd).unwrap_or(&full);\n                let rel_str = rel.to_string_lossy();\n                let path_str = format!(\"./{}\", rel_str.trim_start_matches(\"./\"));\n\n                if should_ignore(&path_str) {\n                    continue;\n                }\n\n                if entry.file_type().map(|ft| ft.is_dir()).unwrap_or(false) {\n                    directories.push(path_str);\n                } else {\n                    files.push(path_str);\n                }\n            }\n        }\n\n        Ok(json!({\n            \"status\": \"success\",\n            \"path\": path,\n            \"files\": files,\n            \"directories\": directories,\n            \"total_files\": files.len(),\n            \"total_directories\": directories.len()\n        }))\n    }\n}\n\nfn should_ignore(path: &str) -> bool {\n    // Normalize: we mostly work with \"./...\" relative paths now\n\n    // 1) Hide dotfiles / dot-directories broadly\n    // (We still keep root path \".\" out of this function; callers handle it)\n    if let Some(name) = Path::new(path).file_name().and_then(|n| n.to_str()) {\n        if name.starts_with('.') {\n            return true;\n        }\n    }\n\n    // 2) Common ignore patterns\n    let ignore_patterns = [\n        \"./.git\", \"./target\", \"./node_modules\", \"./.cowork\", \"./.litho\",\n        \"./.idea\", \"./.vscode\", \"./dist\", \"./build\", \"./docs\", \"./tests\",\n        \"__tests__\", \"./.archived\",\n        \".DS_Store\", \"Thumbs.db\",\n    ];\n\n    ignore_patterns.iter().any(|pattern| path.contains(pattern))\n}\n\n// ============================================================================\n// ReadFileTool\n// ============================================================================\n\npub struct ReadFileTool;\n\n#[async_trait]\nimpl Tool for ReadFileTool {\n    fn name(&self) -> &str {\n        \"read_file\"\n    }\n\n    fn description(&self) -> &str {\n        \"Read the contents of a file. \\\n         SECURITY: Only works within current directory.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"path\": {\n                    \"type\": \"string\",\n                    \"description\": \"File path to read (must be relative path within current directory)\"\n                }\n            },\n            \"required\": [\"path\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let path = args[\"path\"].as_str().unwrap();\n\n        // Security check\n        let safe_path = match validate_path_security(path) {\n            Ok(p) => p,\n            Err(e) => {\n                return Ok(json!({\n                    \"status\": \"security_error\",\n                    \"message\": e\n                }));\n            }\n        };\n\n        if !safe_path.exists() {\n            return Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"File not found: {}\", path)\n            }));\n        }\n        \n        match fs::read_to_string(&safe_path) {\n            Ok(content) => Ok(json!({\n                \"status\": \"success\",\n                \"path\": path,\n                \"content\": content\n            })),\n            Err(e) => Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Failed to read file: {}\", e)\n            })),\n        }\n    }\n}\n\n// ============================================================================\n// WriteFileTool\n// ============================================================================\n\npub struct WriteFileTool;\n\n#[async_trait]\nimpl Tool for WriteFileTool {\n    fn name(&self) -> &str {\n        \"write_file\"\n    }\n\n    fn description(&self) -> &str {\n        \"Write content to a file. Creates parent directories if needed. \\\n         SECURITY: Only works within current directory. Absolute paths and .. are forbidden.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"path\": {\n                    \"type\": \"string\",\n                    \"description\": \"File path to write (must be relative path within current directory)\"\n                },\n                \"content\": {\n                    \"type\": \"string\",\n                    \"description\": \"Content to write\"\n                }\n            },\n            \"required\": [\"path\", \"content\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let path = args[\"path\"].as_str().unwrap();\n        let content = args[\"content\"].as_str().unwrap();\n\n        // Security check\n        let safe_path = match validate_path_security(path) {\n            Ok(p) => p,\n            Err(e) => {\n                return Ok(json!({\n                    \"status\": \"security_error\",\n                    \"message\": e\n                }));\n            }\n        };\n\n        // Create parent directories if needed\n        if let Some(parent) = safe_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\n        }\n\n        match fs::write(&safe_path, content) {\n            Ok(_) => {\n                // Log file creation for user visibility\n                println!(\"📝 Writing file: {} ({} lines)\", path, content.lines().count());\n                Ok(json!({\n                    \"status\": \"success\",\n                    \"path\": path,\n                    \"lines_written\": content.lines().count()\n                }))\n            },\n            Err(e) => Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Failed to write file: {}\", e)\n            })),\n        }\n    }\n}\n\n// ============================================================================\n// RunCommandTool with blocking detection\n// ============================================================================\n\npub struct RunCommandTool;\n\n/// Detect if a command is a long-running service that would block execution\nfn is_blocking_service_command(command: &str) -> bool {\n    let blocking_patterns = vec![\n        \"http.server\",      // python -m http.server\n        \"npm run dev\",      // npm dev server\n        \"npm start\",        // npm start\n        \"yarn dev\",\n        \"yarn start\",\n        \"pnpm dev\",\n        \"pnpm start\",\n        \"uvicorn\",          // Python ASGI server\n        \"gunicorn\",         // Python WSGI server\n        \"flask run\",\n        \"django runserver\",\n        \"rails server\",\n        \"cargo run\",        // Might be a server\n        \"serve\",            // serve package\n        \"webpack-dev-server\",\n        \"vite\",\n        \"next dev\",\n    ];\n\n    blocking_patterns.iter().any(|pattern| command.contains(pattern))\n}\n\n#[async_trait]\nimpl Tool for RunCommandTool {\n    fn name(&self) -> &str {\n        \"run_command\"\n    }\n\n    fn description(&self) -> &str {\n        \"Execute a shell command and return the output. \\\n         WARNING: This tool will REJECT commands that start long-running services \\\n         (like http.server, npm dev, etc.) as they would block execution. \\\n         Use this for: building, testing, linting - NOT for starting servers.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"command\": {\n                    \"type\": \"string\",\n                    \"description\": \"Shell command to execute (must not be a blocking service command)\"\n                }\n            },\n            \"required\": [\"command\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let command = args[\"command\"].as_str().unwrap();\n\n        // Check if command would block\n        if is_blocking_service_command(command) {\n            return Ok(json!({\n                \"status\": \"rejected\",\n                \"message\": format!(\n                    \"BLOCKED: This command appears to start a long-running service: '{}'. \\\n                     Starting services would block the agent. \\\n                     If you need to verify the code works, just create the files - don't start servers.\",\n                    command\n                )\n            }));\n        }\n\n        // Execute command with timeout\n        let output = tokio::time::timeout(\n            std::time::Duration::from_secs(30),\n            tokio::process::Command::new(\"sh\")\n                .arg(\"-c\")\n                .arg(command)\n                .current_dir(std::env::current_dir().unwrap()) // Run in current dir\n                .output()\n        )\n        .await;\n\n        match output {\n            Ok(Ok(output)) => {\n                let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n                let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n\n                Ok(json!({\n                    \"status\": if output.status.success() { \"success\" } else { \"failed\" },\n                    \"exit_code\": output.status.code(),\n                    \"stdout\": stdout,\n                    \"stderr\": stderr\n                }))\n            }\n            Ok(Err(e)) => {\n                Ok(json!({\n                    \"status\": \"error\",\n                    \"message\": format!(\"Failed to execute command: {}\", e)\n                }))\n            }\n            Err(_) => {\n                Ok(json!({\n                    \"status\": \"timeout\",\n                    \"message\": \"Command execution timeout (30s limit)\"\n                }))\n            }\n        }\n    }\n}\n\n// ============================================================================\n// DeleteFileTool\n// ============================================================================\n\npub struct DeleteFileTool;\n\n#[async_trait]\nimpl Tool for DeleteFileTool {\n    fn name(&self) -> &str {\n        \"delete_file\"\n    }\n\n    fn description(&self) -> &str {\n        \"Delete a file from the project. \\\n         SECURITY: Only works within current directory. \\\n         Useful for removing deprecated or unused files during iterative changes.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"path\": {\n                    \"type\": \"string\",\n                    \"description\": \"File path to delete (must be relative path within current directory)\"\n                }\n            },\n            \"required\": [\"path\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let path = args[\"path\"].as_str().unwrap();\n\n        // Security check\n        let safe_path = match validate_path_security(path) {\n            Ok(p) => p,\n            Err(e) => {\n                return Ok(json!({\n                    \"status\": \"security_error\",\n                    \"message\": e\n                }));\n            }\n        };\n\n        // Check if file exists\n        if !safe_path.exists() {\n            return Ok(json!({\n                \"status\": \"not_found\",\n                \"message\": format!(\"File not found: {}\", path)\n            }));\n        }\n\n        // Check if it's a directory (we only delete files, not directories)\n        if safe_path.is_dir() {\n            return Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Path '{}' is a directory. Use delete_directory for directories.\", path)\n            }));\n        }\n\n        // Delete the file\n        match fs::remove_file(&safe_path) {\n            Ok(_) => {\n                // Log file deletion for user visibility\n                println!(\"🗑️  Deleted file: {}\", path);\n                Ok(json!({\n                    \"status\": \"success\",\n                    \"path\": path,\n                    \"message\": format!(\"File '{}' deleted successfully\", path)\n                }))\n            },\n            Err(e) => Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Failed to delete file: {}\", e)\n            })),\n        }\n    }\n}\n\n// ============================================================================\n// DeleteDirectoryTool\n// ============================================================================\n\npub struct DeleteDirectoryTool;\n\n#[async_trait]\nimpl Tool for DeleteDirectoryTool {\n    fn name(&self) -> &str {\n        \"delete_directory\"\n    }\n\n    fn description(&self) -> &str {\n        \"Delete a directory and all its contents recursively. \\\n         SECURITY: Only works within current directory. \\\n         WARNING: This operation is irreversible! Use with caution.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"path\": {\n                    \"type\": \"string\",\n                    \"description\": \"Directory path to delete (must be relative path within current directory)\"\n                }\n            },\n            \"required\": [\"path\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let path = args[\"path\"].as_str().unwrap();\n\n        // Security check\n        let safe_path = match validate_path_security(path) {\n            Ok(p) => p,\n            Err(e) => {\n                return Ok(json!({\n                    \"status\": \"security_error\",\n                    \"message\": e\n                }));\n            }\n        };\n\n        // Check if directory exists\n        if !safe_path.exists() {\n            return Ok(json!({\n                \"status\": \"not_found\",\n                \"message\": format!(\"Directory not found: {}\", path)\n            }));\n        }\n\n        // Check if it's actually a directory\n        if !safe_path.is_dir() {\n            return Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Path '{}' is a file. Use delete_file for files.\", path)\n            }));\n        }\n\n        // Delete the directory recursively\n        match fs::remove_dir_all(&safe_path) {\n            Ok(_) => {\n                // Log directory deletion for user visibility\n                println!(\"🗑️  Deleted directory: {}\", path);\n                Ok(json!({\n                    \"status\": \"success\",\n                    \"path\": path,\n                    \"message\": format!(\"Directory '{}' and all its contents deleted successfully\", path)\n                }))\n            },\n            Err(e) => Ok(json!({\n                \"status\": \"error\",\n                \"message\": format!(\"Failed to delete directory: {}\", e)\n            })),\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 65.0,
      "lines_of_code": 665,
      "number_of_classes": 6,
      "number_of_functions": 26
    },
    "dependencies": [
      {
        "dependency_type": "framework",
        "is_external": true,
        "line_number": 3,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "macro",
        "is_external": true,
        "line_number": 4,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 5,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 6,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 7,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": 8,
        "name": "std::path",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 9,
        "name": "walkdir",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The `file_tools.rs` component is a comprehensive file operation toolkit designed for AI agents with strict security constraints. It implements six specialized tools (ListFilesTool, ReadFileTool, WriteFileTool, RunCommandTool, DeleteFileTool, DeleteDirectoryTool) that conform to the `Tool` trait from the adk_core framework. The component's primary focus is enabling safe file system interactions within a bounded working directory.\n\nThe security architecture is built around a centralized path validation system (`validate_path_security`) that enforces three critical rules: (1) absolute paths are forbidden, (2) parent directory access via \"..\" is blocked, and (3) all paths must resolve within the current working directory. This prevents directory traversal attacks and ensures agents cannot access files outside their designated workspace. The implementation handles cross-platform concerns including Windows UNC path prefixes and non-existent paths for file creation scenarios.\n\nThe component provides both file and directory management capabilities. ListFilesTool offers recursive and non-recursive directory traversal with depth control, intelligent filtering of hidden files/directories, and support for common ignore patterns (.git, node_modules, target, etc.). ReadFileTool and WriteFileTool handle content access with automatic directory creation for writes. DeleteFileTool and DeleteDirectoryTool provide cleanup capabilities with appropriate safety checks.\n\nThe RunCommandTool adds shell command execution with built-in blocking detection to prevent agents from starting long-running services (http.server, npm dev, uvicorn, etc.) that would block execution. It implements a 30-second timeout and returns structured output with exit codes, stdout, and stderr.\n\nAll tools follow a consistent pattern: security validation → existence/permission checks → operation execution → JSON-formatted response with status and relevant data. User-facing logging uses emoji indicators for better visibility.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "struct",
        "name": "ListFilesTool",
        "parameters": [
          {
            "description": "Directory path to list (default: current directory). Must be relative path.",
            "is_optional": true,
            "name": "path",
            "param_type": "string"
          },
          {
            "description": "Whether to list files recursively (default: false)",
            "is_optional": true,
            "name": "recursive",
            "param_type": "boolean"
          },
          {
            "description": "Maximum depth for recursive listing (default: 3)",
            "is_optional": true,
            "name": "max_depth",
            "param_type": "integer"
          }
        ],
        "return_type": "Value (JSON response with status, files, directories, and counts)",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ReadFileTool",
        "parameters": [
          {
            "description": "File path to read (must be relative path within current directory)",
            "is_optional": false,
            "name": "path",
            "param_type": "string"
          }
        ],
        "return_type": "Value (JSON response with status, path, and content)",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "WriteFileTool",
        "parameters": [
          {
            "description": "File path to write (must be relative path within current directory)",
            "is_optional": false,
            "name": "path",
            "param_type": "string"
          },
          {
            "description": "Content to write",
            "is_optional": false,
            "name": "content",
            "param_type": "string"
          }
        ],
        "return_type": "Value (JSON response with status, path, and lines_written)",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "RunCommandTool",
        "parameters": [
          {
            "description": "Shell command to execute (must not be a blocking service command)",
            "is_optional": false,
            "name": "command",
            "param_type": "string"
          }
        ],
        "return_type": "Value (JSON response with status, exit_code, stdout, stderr)",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "DeleteFileTool",
        "parameters": [
          {
            "description": "File path to delete (must be relative path within current directory)",
            "is_optional": false,
            "name": "path",
            "param_type": "string"
          }
        ],
        "return_type": "Value (JSON response with status, path, and message)",
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "DeleteDirectoryTool",
        "parameters": [
          {
            "description": "Directory path to delete (must be relative path within current directory)",
            "is_optional": false,
            "name": "path",
            "param_type": "string"
          }
        ],
        "return_type": "Value (JSON response with status, path, and message)",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Secure file system operations enforcement - validating all path access attempts against security rules to prevent directory traversal attacks and ensure confinement within current working directory",
      "File and directory management - providing read, write, list, and delete operations with proper error handling, existence checks, and appropriate warnings for destructive operations",
      "Command execution with safety controls - detecting and blocking long-running service commands while allowing build/test operations, with timeout protection and structured output",
      "Intelligent file filtering - implementing ignore patterns for hidden files, build artifacts, and common development directories to reduce noise in file listings",
      "Cross-platform path normalization - handling Windows UNC paths, relative path resolution, and canonicalization for consistent security checks across different operating systems"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "A session-scoped tool for the Check Agent that enables restarting the pipeline from a specific stage. Validates stage input, persists restart metadata to storage, and provides feedback about the restart scheduling.",
      "file_path": "crates\\cowork-core\\src\\tools\\goto_stage_tool.rs",
      "functions": [
        "new",
        "name",
        "description",
        "parameters_schema",
        "execute"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Tool trait implementation",
        "GotoStageTool struct",
        "new constructor"
      ],
      "name": "goto_stage_tool.rs",
      "source_summary": "// Goto Stage tool for Check Agent (Session-scoped)\r\nuse crate::data::*;\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext};\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\npub struct GotoStageTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl GotoStageTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for GotoStageTool {\r\n    fn name(&self) -> &str {\r\n        \"goto_stage\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Restart pipeline from a specific stage. Use this when critical issues \\\r\n         require going back to an earlier phase. Valid stages: prd, design, plan, coding.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"stage\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"prd\", \"design\", \"plan\", \"coding\"],\r\n                    \"description\": \"Which stage to restart from\"\r\n                },\r\n                \"reason\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Why the restart is needed\"\r\n                }\r\n            },\r\n            \"required\": [\"stage\", \"reason\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let stage_str = args[\"stage\"].as_str().unwrap();\r\n        let reason = args[\"reason\"].as_str().unwrap();\r\n\r\n        // Parse stage\r\n        let stage = match stage_str {\r\n            \"prd\" => Stage::Prd,\r\n            \"design\" => Stage::Design,\r\n            \"plan\" => Stage::Plan,\r\n            \"coding\" => Stage::Coding,\r\n            _ => {\r\n                return Ok(json!({\r\n                    \"status\": \"error\",\r\n                    \"message\": format!(\"Invalid stage: {}\", stage_str)\r\n                }));\r\n            }\r\n        };\r\n\r\n        // Load or create session meta\r\n        let mut meta = load_session_meta(&self.session_id)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?\r\n            .unwrap_or_else(|| SessionMeta {\r\n                session_id: self.session_id.clone(),\r\n                created_at: chrono::Utc::now(),\r\n                current_stage: Some(Stage::Check),\r\n                restart_reason: None,\r\n            });\r\n\r\n        // Set restart information by updating current_stage and reason\r\n        meta.current_stage = Some(stage);\r\n        meta.restart_reason = Some(reason.to_string());\r\n\r\n        // Save session meta\r\n        save_session_meta(&self.session_id, &meta)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"restart_scheduled\",\r\n            \"stage\": stage_str,\r\n            \"reason\": reason,\r\n            \"message\": format!(\"Pipeline will restart from {} stage. User should re-run with 'cowork revert --from {}' command.\", stage_str, stage_str)\r\n        }))\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 4.0,
      "lines_of_code": 91,
      "number_of_classes": 1,
      "number_of_functions": 5
    },
    "dependencies": [
      {
        "dependency_type": "internal crate module",
        "is_external": false,
        "line_number": 2,
        "name": "crate::data::*",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal crate module",
        "is_external": false,
        "line_number": 3,
        "name": "crate::storage::*",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 4,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 5,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 6,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external crate",
        "is_external": true,
        "line_number": 4,
        "name": "Tool",
        "path": "adk_core",
        "version": null
      }
    ],
    "detailed_description": "The GotoStageTool is a session-scoped tool implementation for the cowork system's Check Agent. It provides functionality to restart a development pipeline from a specified stage (PRD, Design, Plan, or Coding). The tool validates input parameters against a predefined schema, handles stage string-to-enum conversion with error handling, persists restart metadata (target stage and reason) to session storage, and returns structured JSON responses indicating the restart status. It serves as an integration point between the agent framework (adk_core) and the application's domain logic for session management and pipeline control.",
    "interfaces": [
      {
        "description": "Constructor that creates a new GotoStageTool instance bound to a specific session",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [
          {
            "description": "Unique identifier for the session",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Returns the tool's unique identifier for registration with the agent framework",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns a human-readable description of the tool's purpose and usage",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns a JSON Schema describing the expected input parameters",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Core logic that processes the goto_stage command - parses stage, updates session metadata, and persists changes",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": "The execution context provided by the agent framework",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Input arguments containing stage and reason",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Validate and parse user-provided stage targets from string inputs to strongly-typed Stage enum variants",
      "Manage session metadata persistence by loading existing metadata, updating current stage and restart reason, and saving back to storage",
      "Provide self-documenting interface to the agent framework through Tool trait implementation with schema-defined parameters",
      "Orchestrate pipeline restart workflow by validating inputs, persisting state changes, and returning actionable feedback messages to users"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "A HITL (Human-in-the-Loop) content tools module that implements interactive content review workflows with support for editing, passing, and providing feedback on generated content through an InteractiveBackend.",
      "file_path": "crates\\cowork-core\\src\\tools\\hitl_content_tools.rs",
      "functions": [
        "set_interaction_backend",
        "get_interaction_backend",
        "review_and_edit_content",
        "review_with_feedback_content"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Tool",
        "InteractiveBackend"
      ],
      "name": "hitl_content_tools.rs",
      "source_summary": "// HITL tools (content-based) using InteractiveBackend\nuse adk_core::{Tool, ToolContext};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::sync::{Arc, Mutex};\nuse once_cell::sync::Lazy;\n\nuse crate::interaction::{InteractiveBackend, InputOption, InputResponse, MessageLevel};\n\n// Global InteractiveBackend for HITL tools\nstatic INTERACTION_BACKEND: Lazy<Mutex<Option<Arc<dyn InteractiveBackend + Send + Sync>>>> = \n    Lazy::new(|| Mutex::new(None));\n\n/// Set the global InteractiveBackend\npub fn set_interaction_backend(backend: Arc<dyn InteractiveBackend + Send + Sync>) {\n    *INTERACTION_BACKEND.lock().unwrap() = Some(backend);\n}\n\n/// Get the global InteractiveBackend\nfn get_interaction_backend() -> Option<Arc<dyn InteractiveBackend + Send + Sync>> {\n    INTERACTION_BACKEND.lock().unwrap().clone()\n}\n\n/// review_and_edit_content\n/// - Shows content to user\n/// - Lets user choose: edit, pass, or provide feedback\n/// - Returns action and content/feedback\npub struct ReviewAndEditContentTool;\n\n#[async_trait]\nimpl Tool for ReviewAndEditContentTool {\n    fn name(&self) -> &str {\n        \"review_and_edit_content\"\n    }\n\n    fn description(&self) -> &str {\n        \"Let the user review content and choose: edit, pass, or provide feedback.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"title\": {\"type\": \"string\", \"description\": \"Title shown to user\"},\n                \"content\": {\"type\": \"string\", \"description\": \"Content to review\"}\n            },\n            \"required\": [\"title\", \"content\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let title = args[\"title\"].as_str().unwrap();\n        let content = args[\"content\"].as_str().unwrap();\n\n        // Get InteractiveBackend\n        let interaction = get_interaction_backend()\n            .ok_or_else(|| adk_core::AdkError::Tool(\"InteractiveBackend not set\".to_string()))?;\n\n        // Show content to user\n        interaction.show_message(\n            MessageLevel::Info,\n            format!(\"\\n📝 {}\\n{}\\n---\\n{}\",\n                title,\n                \"─\".repeat(40),\n                content.lines().take(15).collect::<Vec<_>>().join(\"\\n\")\n            )\n        ).await;\n\n        // Request user input\n        let options = vec![\n            InputOption {\n                id: \"pass\".to_string(),\n                label: \"✓ Pass\".to_string(),\n                description: Some(\"Continue without changes\".to_string()),\n            },\n        ];\n\n        let response = interaction.request_input(\n            \"Type 'edit' to open editor, 'pass' to continue, or provide feedback:\",\n            options,\n            Some(content.to_string())\n        ).await.map_err(|e| adk_core::AdkError::Tool(format!(\"Input error: {}\", e)))?;\n\n        match response {\n            InputResponse::Selection(id) => match id.as_str() {\n                \"pass\" => Ok(json!({\n                    \"action\": \"pass\",\n                    \"content\": content,\n                    \"message\": \"User passed\"\n                })),\n                _ => Ok(json!({\n                    \"action\": \"pass\",\n                    \"content\": content,\n                    \"message\": \"Unknown action\"\n                }))\n            },\n            InputResponse::Text(text) => {\n                let text = text.trim();\n                // Check if text looks like edited content (multiline) or feedback (short)\n                if text.contains('\\n') || text.len() > 100 {\n                    // Assume this is edited content\n                    Ok(json!({\n                        \"action\": \"edit\",\n                        \"content\": text,\n                        \"message\": \"User provided edited content\"\n                    }))\n                } else {\n                    // Assume this is feedback\n                    Ok(json!({\n                        \"action\": \"feedback\",\n                        \"feedback\": text,\n                        \"content\": content,\n                        \"message\": \"User provided feedback\"\n                    }))\n                }\n            },\n            InputResponse::Cancel => Ok(json!({\n                \"action\": \"pass\",\n                \"content\": content,\n                \"message\": \"User cancelled\"\n            })),\n        }\n    }\n}\n\n/// review_with_feedback_content\n/// - Shows content to user\n/// - Allows edit/pass/feedback\n/// - Returns edited content OR feedback text\npub struct ReviewWithFeedbackContentTool;\n\n#[async_trait]\nimpl Tool for ReviewWithFeedbackContentTool {\n    fn name(&self) -> &str {\n        \"review_with_feedback_content\"\n    }\n\n    fn description(&self) -> &str {\n        \"Review content and allow user to: edit, pass, or provide feedback text.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"title\": {\"type\": \"string\"},\n                \"content\": {\"type\": \"string\"},\n                \"prompt\": {\"type\": \"string\"}\n            },\n            \"required\": [\"title\", \"content\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let title = args[\"title\"].as_str().unwrap();\n        let content = args[\"content\"].as_str().unwrap();\n        let default_prompt = \"Type 'edit' to open editor, 'pass' to continue, or provide feedback:\";\n        let prompt = args.get(\"prompt\").and_then(|v| v.as_str()).unwrap_or(default_prompt);\n\n        // Get InteractiveBackend\n        let interaction = get_interaction_backend()\n            .ok_or_else(|| adk_core::AdkError::Tool(\"InteractiveBackend not set\".to_string()))?;\n\n        // Show content to user\n        interaction.show_message(\n            MessageLevel::Info,\n            format!(\"\\n📝 {}\\n{}\\n---\\n{}\",\n                title,\n                \"─\".repeat(40),\n                content.lines().take(15).collect::<Vec<_>>().join(\"\\n\")\n            )\n        ).await;\n\n        // Request user input\n        let options = vec![\n            InputOption {\n                id: \"pass\".to_string(),\n                label: \"✓ Pass\".to_string(),\n                description: Some(\"Continue without changes\".to_string()),\n            },\n        ];\n\n        let response = interaction.request_input(prompt, options, Some(content.to_string()))\n            .await.map_err(|e| adk_core::AdkError::Tool(format!(\"Input error: {}\", e)))?;\n\n        match response {\n            InputResponse::Selection(id) => match id.as_str() {\n                \"pass\" => Ok(json!({\n                    \"action\": \"pass\",\n                    \"content\": content,\n                    \"message\": \"User passed\"\n                })),\n                _ => Ok(json!({\n                    \"action\": \"pass\",\n                    \"content\": content,\n                    \"message\": \"Unknown action\"\n                }))\n            },\n            InputResponse::Text(text) => {\n                let text = text.trim();\n                // Check if text looks like edited content (multiline) or feedback (short)\n                if text.contains('\\n') || text.len() > 100 {\n                    // Assume this is edited content\n                    Ok(json!({\n                        \"action\": \"edit\",\n                        \"content\": text,\n                        \"message\": \"User provided edited content\"\n                    }))\n                } else {\n                    // Assume this is feedback\n                    Ok(json!({\n                        \"action\": \"feedback\",\n                        \"feedback\": text,\n                        \"content\": content,\n                        \"message\": \"User provided feedback\"\n                    }))\n                }\n            },\n            InputResponse::Cancel => Ok(json!({\n                \"action\": \"pass\",\n                \"content\": content,\n                \"message\": \"User cancelled\"\n            })),\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 12.0,
      "lines_of_code": 226,
      "number_of_classes": 2,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 1,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 2,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 3,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 5,
        "name": "once_cell",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 7,
        "name": "crate::interaction",
        "path": "crates/cowork-core/src/interaction",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "std",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Functional Description\n\nThis component implements Human-in-the-Loop (HITL) content review tools that enable interactive collaboration between AI systems and human users. The module provides two primary tools:\n\n### ReviewAndEditContentTool\n- Displays content to users with a formatted title and preview (first 15 lines)\n- Presents users with three interaction options: edit (via text input), pass (accept without changes), or provide feedback\n- Intelligently categorizes user input based on content characteristics:\n  - Multiline or long text (>100 characters) is treated as edited content\n  - Short text is treated as feedback\n- Returns structured JSON responses with action type, content/feedback, and descriptive message\n\n### ReviewWithFeedbackContentTool\n- Functionally identical to ReviewAndEditContentTool\n- Adds customizable prompt parameter for flexible user messaging\n- Maintains same content display and interaction logic\n\n### Global Backend Management\n- Implements a thread-safe, lazily-initialized global InteractiveBackend using Lazy<Mutex<...>>\n- Provides `set_interaction_backend()` for dependency injection\n- Offers `get_interaction_backend()` for accessing the configured backend\n- Uses Arc<dyn InteractiveBackend + Send + Sync> for thread-safe shared ownership\n\nBoth tools adhere to the `Tool` trait from `adk_core`, enabling integration with larger AI agent systems as callable tools with defined parameter schemas and asynchronous execution.",
    "interfaces": [
      {
        "description": "Core trait defining tool interface with name, description, parameters_schema, and async execute method",
        "interface_type": "trait",
        "name": "Tool",
        "parameters": [
          {
            "description": "Receiver reference",
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          },
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Tool input arguments as JSON value",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "External trait for handling user interactions with show_message and request_input methods",
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [
          {
            "description": "Message severity level",
            "is_optional": false,
            "name": "message",
            "param_type": "MessageLevel"
          },
          {
            "description": "User interaction prompt",
            "is_optional": false,
            "name": "prompt",
            "param_type": "String"
          },
          {
            "description": "Available input options",
            "is_optional": false,
            "name": "options",
            "param_type": "Vec<InputOption>"
          },
          {
            "description": "Default text for editing",
            "is_optional": true,
            "name": "default_text",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Future<InputResponse>",
        "visibility": "external"
      },
      {
        "description": "Sets the global InteractiveBackend for HITL tools",
        "interface_type": "function",
        "name": "set_interaction_backend",
        "parameters": [
          {
            "description": "Interactive backend implementation to set",
            "is_optional": false,
            "name": "backend",
            "param_type": "Arc<dyn InteractiveBackend + Send + Sync>"
          }
        ],
        "return_type": "void",
        "visibility": "public"
      },
      {
        "description": "Retrieves the configured global InteractiveBackend",
        "interface_type": "function",
        "name": "get_interaction_backend",
        "parameters": [],
        "return_type": "Option<Arc<dyn InteractiveBackend + Send + Sync>>",
        "visibility": "private"
      },
      {
        "description": "Returns the tool identifier name",
        "interface_type": "method",
        "name": "name",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns human-readable tool description",
        "interface_type": "method",
        "name": "description",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON schema for tool parameters",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          }
        ],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Async method that executes the tool with given arguments",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "self",
            "param_type": "&self"
          },
          {
            "description": "Tool execution context (unused)",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Tool input arguments",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manage and provide thread-safe global access to InteractiveBackend for HITL operations",
      "Implement content review workflows allowing users to pass, edit, or provide feedback on AI-generated content",
      "Process and categorize user input responses based on content characteristics (multiline/length-based detection)",
      "Format and display content to users with structured previews and titles",
      "Convert user interactions into structured JSON responses for downstream processing",
      "Implement Tool trait interface for integration with agent systems as callable functions"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Human-in-the-Loop (HITL) tools providing interactive file review, editing, and feedback collection capabilities for agent workflows",
      "file_path": "crates\\cowork-core\\src\\tools\\hitl_tools.rs",
      "functions": [
        "review_and_edit_file",
        "review_with_feedback"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Tool",
        "ToolContext"
      ],
      "name": "hitl_tools.rs",
      "source_summary": "// HITL (Human-in-the-Loop) tools\r\nuse adk_core::{Tool, ToolContext};\r\nuse async_trait::async_trait;\r\nuse dialoguer::{Confirm, Editor, Input};\r\nuse serde_json::{json, Value};\r\nuse std::fs;\r\nuse std::sync::Arc;\r\n\r\n/// ReviewAndEditFileTool - Original HITL tool (used in Idea stage)\r\npub struct ReviewAndEditFileTool;\r\n\r\n#[async_trait]\r\nimpl Tool for ReviewAndEditFileTool {\r\n    fn name(&self) -> &str {\r\n        \"review_and_edit_file\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Let the user review and optionally edit a file using their default editor. \\\r\n         User will be prompted: 'Do you want to edit this file? (y/n)'. \\\r\n         If 'y', opens the file in an editor. If 'n', continues without changes.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"file_path\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Path to the file to review and edit\"\r\n                },\r\n                \"title\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Title/description for the review prompt\"\r\n                }\r\n            },\r\n            \"required\": [\"file_path\", \"title\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let file_path = args[\"file_path\"].as_str().unwrap();\r\n        let title = args[\"title\"].as_str().unwrap();\r\n\r\n        // Read current file content\r\n        let content = fs::read_to_string(file_path)\r\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read file {}: {}\", file_path, e)))?;\r\n\r\n        // Show preview\r\n        println!(\"\\n📝 {} - {}\", title, file_path);\r\n        println!(\"  ────────────────────────────────────────\");\r\n        let line_count = content.lines().count();\r\n        for (i, line) in content.lines().take(10).enumerate() {\r\n            println!(\"  {}: {}\", i + 1, line);\r\n        }\r\n        if line_count > 10 {\r\n            println!(\"  ... ({} more lines)\", line_count - 10);\r\n        }\r\n        println!(\"  ────────────────────────────────────────\\n\");\r\n\r\n        // Ask user if they want to edit\r\n        let should_edit = Confirm::new()\r\n            .with_prompt(\"Do you want to edit this file? (y/n)\")\r\n            .default(false)\r\n            .interact()\r\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Interaction error: {}\", e)))?;\r\n\r\n        if !should_edit {\r\n            return Ok(json!({\r\n                \"status\": \"no_changes\",\r\n                \"message\": \"User chose not to edit the file\"\r\n            }));\r\n        }\r\n\r\n        // Open editor\r\n        println!(\"📝 Opening editor... (Save and close to submit changes)\");\r\n        let edited = Editor::new()\r\n            .require_save(true)\r\n            .edit(&content)\r\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Editor error: {}\", e)))?;\r\n\r\n        match edited {\r\n            Some(new_content) if new_content.trim() != content.trim() => {\r\n                // Save changes\r\n                fs::write(file_path, &new_content)\r\n                    .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to write file: {}\", e)))?;\r\n\r\n                println!(\"✅ File updated successfully\");\r\n                Ok(json!({\r\n                    \"status\": \"edited\",\r\n                    \"message\": \"File was edited and saved\",\r\n                    \"changes_made\": true\r\n                }))\r\n            }\r\n            _ => {\r\n                println!(\"ℹ️  No changes made\");\r\n                Ok(json!({\r\n                    \"status\": \"no_changes\",\r\n                    \"message\": \"File was not modified\"\r\n                }))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// ReviewWithFeedbackTool - Enhanced HITL tool with three modes:\r\n/// 1. User types \"edit\" → Opens editor\r\n/// 2. User types \"pass\" → Continues without changes\r\n/// 3. User types other text → Returns as feedback for agent to process\r\npub struct ReviewWithFeedbackTool;\r\n\r\n#[async_trait]\r\nimpl Tool for ReviewWithFeedbackTool {\r\n    fn name(&self) -> &str {\r\n        \"review_with_feedback\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Show user a file preview and ask for feedback. User can:\\n\\\r\n         - Type 'edit' to open the file in an editor\\n\\\r\n         - Type 'pass' to continue without changes\\n\\\r\n         - Type any other text to provide feedback/suggestions (agent will revise based on feedback)\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"path\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Path to the file to review\"\r\n                },\r\n                \"title\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Title/description for the review prompt\"\r\n                },\r\n                \"prompt\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Custom prompt to show the user (e.g., '请审查需求大纲')\"\r\n                }\r\n            },\r\n            \"required\": [\"path\", \"title\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let file_path = args[\"path\"].as_str().unwrap();\r\n        let title = args[\"title\"].as_str().unwrap();\r\n        let default_prompt = \"输入 'edit' 编辑，'pass' 继续，或直接输入修改建议\";\r\n        let prompt = args[\"prompt\"].as_str().unwrap_or(default_prompt);\r\n\r\n        // Read current file content\r\n        let content = fs::read_to_string(file_path)\r\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read file {}: {}\", file_path, e)))?;\r\n\r\n        // Show preview\r\n        println!(\"\\n📝 {} - {}\", title, file_path);\r\n        println!(\"  ────────────────────────────────────────\");\r\n        let line_count = content.lines().count();\r\n        for (i, line) in content.lines().take(15).enumerate() {\r\n            println!(\"  {}: {}\", i + 1, line);\r\n        }\r\n        if line_count > 15 {\r\n            println!(\"  ... ({} more lines)\", line_count - 15);\r\n        }\r\n        println!(\"  ────────────────────────────────────────\\n\");\r\n\r\n        // Ask user for input\r\n        let user_input: String = Input::new()\r\n            .with_prompt(prompt)\r\n            .allow_empty(true)\r\n            .interact_text()\r\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Interaction error: {}\", e)))?;\r\n\r\n        let user_input = user_input.trim();\r\n\r\n        // Handle different input modes\r\n        match user_input.to_lowercase().as_str() {\r\n            \"edit\" => {\r\n                // Mode 1: Open editor\r\n                println!(\"📝 Opening editor... (Save and close to submit changes)\");\r\n                let edited = Editor::new()\r\n                    .require_save(true)\r\n                    .edit(&content)\r\n                    .map_err(|e| adk_core::AdkError::Tool(format!(\"Editor error: {}\", e)))?;\r\n\r\n                match edited {\r\n                    Some(new_content) if new_content.trim() != content.trim() => {\r\n                        fs::write(file_path, &new_content)\r\n                            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to write file: {}\", e)))?;\r\n\r\n                        println!(\"✅ File updated successfully\");\r\n                        Ok(json!({\r\n                            \"action\": \"edit\",\r\n                            \"status\": \"edited\",\r\n                            \"message\": \"User edited the file in editor\",\r\n                            \"changes_made\": true\r\n                        }))\r\n                    }\r\n                    _ => {\r\n                        println!(\"ℹ️  No changes made in editor\");\r\n                        Ok(json!({\r\n                            \"action\": \"edit\",\r\n                            \"status\": \"no_changes\",\r\n                            \"message\": \"User opened editor but made no changes\"\r\n                        }))\r\n                    }\r\n                }\r\n            }\r\n            \"pass\" | \"\" => {\r\n                // Mode 2: Pass/Continue\r\n                println!(\"➡️  Continuing without changes...\");\r\n                Ok(json!({\r\n                    \"action\": \"pass\",\r\n                    \"status\": \"passed\",\r\n                    \"message\": \"User chose to continue without changes\"\r\n                }))\r\n            }\r\n            _ => {\r\n                // Mode 3: Feedback text\r\n                println!(\"💬 Feedback received: {}\", user_input);\r\n                println!(\"🔄 Agent will revise based on your feedback...\");\r\n                Ok(json!({\r\n                    \"action\": \"feedback\",\r\n                    \"status\": \"feedback_provided\",\r\n                    \"feedback\": user_input,\r\n                    \"message\": format!(\"User provided feedback: {}\", user_input)\r\n                }))\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 232,
      "number_of_classes": 2,
      "number_of_functions": 2
    },
    "dependencies": [
      {
        "dependency_type": "trait",
        "is_external": true,
        "line_number": 3,
        "name": "Tool",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "trait",
        "is_external": true,
        "line_number": 3,
        "name": "ToolContext",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "macro_attribute",
        "is_external": true,
        "line_number": 4,
        "name": "async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 5,
        "name": "Confirm",
        "path": "dialoguer",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 5,
        "name": "Editor",
        "path": "dialoguer",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": true,
        "line_number": 5,
        "name": "Input",
        "path": "dialoguer",
        "version": null
      },
      {
        "dependency_type": "macro",
        "is_external": true,
        "line_number": 6,
        "name": "json",
        "path": "serde_json",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": true,
        "line_number": 6,
        "name": "Value",
        "path": "serde_json",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 7,
        "name": "fs",
        "path": "std",
        "version": null
      },
      {
        "dependency_type": "type",
        "is_external": false,
        "line_number": 8,
        "name": "Arc",
        "path": "std::sync",
        "version": null
      }
    ],
    "detailed_description": "This component implements two Human-in-the-Loop (HITL) tools for interactive agent workflows: ReviewAndEditFileTool and ReviewWithFeedbackTool. Both tools enable agents to pause execution and solicit human input for file review and modification decisions. ReviewAndEditFileTool provides a binary choice workflow (edit/file_path vs skip), displaying file previews and launching external editors when requested. ReviewWithFeedbackTool offers a more sophisticated three-mode interaction: 'edit' opens the file in an editor, 'pass' continues without changes, and any other text is captured as feedback for the agent to process. The tools handle file I/O operations, interactive CLI prompting via dialoguer, and return structured JSON responses indicating the action taken and any changes made. Both tools display formatted file previews (first 10-15 lines) with line numbers and continuation indicators for large files.",
    "interfaces": [
      {
        "description": "Returns the tool identifier used by the agent system to invoke this tool",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Provides human-readable description of tool functionality for agent decision-making",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON Schema defining expected parameters (file_path/path, title, optional prompt)",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Executes the interactive file review workflow with user prompting and potential file editing",
        "interface_type": "async_method",
        "name": "execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Tool arguments including file path and title",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Provide interactive human-in-the-loop file review capabilities allowing users to preview file contents before making modification decisions",
      "Enable direct file editing through external editor integration with automatic change detection and persistence",
      "Support three-mode feedback workflow (edit/pass/feedback) to accommodate different levels of human involvement in agent workflows",
      "Handle all file I/O operations safely with proper error handling and user-friendly error messages",
      "Format and display file previews with pagination (10-15 lines) showing line numbers and continuation indicators"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Session-scoped artifact management tools for idea.md files, providing save and load operations within the .cowork/sessions/<id>/artifacts/ directory structure. Implements the Tool trait from adk_core for agent integration.",
      "file_path": "crates\\cowork-core\\src\\tools\\idea_tools.rs",
      "functions": [
        "SaveIdeaTool::new",
        "SaveIdeaTool::name",
        "SaveIdeaTool::description",
        "SaveIdeaTool::parameters_schema",
        "SaveIdeaTool::execute",
        "LoadIdeaTool::new",
        "LoadIdeaTool::name",
        "LoadIdeaTool::description",
        "LoadIdeaTool::parameters_schema",
        "LoadIdeaTool::execute"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "SaveIdeaTool",
        "LoadIdeaTool",
        "Tool"
      ],
      "name": "idea_tools.rs",
      "source_summary": "// Idea artifact tools (Session-scoped)\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext};\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\npub struct SaveIdeaTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl SaveIdeaTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for SaveIdeaTool {\r\n    fn name(&self) -> &str {\r\n        \"save_idea\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Save idea.md as a session-scoped artifact (.cowork/sessions/<id>/artifacts/idea.md).\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"content\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Markdown content of idea.md\"\r\n                }\r\n            },\r\n            \"required\": [\"content\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let content = args[\"content\"].as_str().unwrap();\r\n        save_idea(&self.session_id, content)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"message\": \"Idea saved successfully\"\r\n        }))\r\n    }\r\n}\r\n\r\npub struct LoadIdeaTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl LoadIdeaTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for LoadIdeaTool {\r\n    fn name(&self) -> &str {\r\n        \"load_idea\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Load idea.md from current session artifacts.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let content = load_idea(&self.session_id)\r\n            .map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"content\": content\r\n        }))\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 3.0,
      "lines_of_code": 86,
      "number_of_classes": 2,
      "number_of_functions": 10
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::storage::*",
        "path": "crate::storage",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 4,
        "name": "adk_core::{Tool, ToolContext}",
        "path": "adk_core",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 3,
        "name": "async_trait::async_trait",
        "path": "async_trait",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 5,
        "name": "serde_json::{json, Value}",
        "path": "serde_json",
        "version": null
      },
      {
        "dependency_type": "standard",
        "is_external": false,
        "line_number": 6,
        "name": "std::sync::Arc",
        "path": "std::sync::Arc",
        "version": null
      }
    ],
    "detailed_description": "This component implements two specialized Tool trait implementations (SaveIdeaTool and LoadIdeaTool) that manage idea.md artifacts within a session-scoped directory structure. The tools enable agents to persist and retrieve markdown content representing ideas or project requirements. SaveIdeaTool accepts content parameters and persists to .cowork/sessions/<id>/artifacts/idea.md, while LoadIdeaTool retrieves the stored content. Both tools use JSON schemas for parameter validation, implement async execution patterns using Tokio-compatible futures, and provide proper error handling by converting storage-level errors into adk_core::AdkError::Tool variants. The component follows a clean trait-based architecture enabling dynamic tool registration and execution within an ADK (Agent Development Kit) environment.",
    "interfaces": [
      {
        "description": "Constructor for SaveIdeaTool",
        "interface_type": "constructor",
        "name": "SaveIdeaTool::new",
        "parameters": [
          {
            "description": "Session identifier for scoping the artifact storage",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "pub"
      },
      {
        "description": "Returns the tool identifier",
        "interface_type": "method",
        "name": "SaveIdeaTool::name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      },
      {
        "description": "Returns the tool description for agent integration",
        "interface_type": "method",
        "name": "SaveIdeaTool::description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      },
      {
        "description": "Returns JSON schema for parameter validation",
        "interface_type": "method",
        "name": "SaveIdeaTool::parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "pub"
      },
      {
        "description": "Executes the save operation to persist idea content",
        "interface_type": "async_method",
        "name": "SaveIdeaTool::execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments containing content field",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "pub"
      },
      {
        "description": "Constructor for LoadIdeaTool",
        "interface_type": "constructor",
        "name": "LoadIdeaTool::new",
        "parameters": [
          {
            "description": "Session identifier for scoping the artifact retrieval",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "pub"
      },
      {
        "description": "Returns the tool identifier",
        "interface_type": "method",
        "name": "LoadIdeaTool::name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      },
      {
        "description": "Returns the tool description for agent integration",
        "interface_type": "method",
        "name": "LoadIdeaTool::description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "pub"
      },
      {
        "description": "Returns JSON schema for parameter validation (empty object)",
        "interface_type": "method",
        "name": "LoadIdeaTool::parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "pub"
      },
      {
        "description": "Executes the load operation to retrieve idea content",
        "interface_type": "async_method",
        "name": "LoadIdeaTool::execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Empty JSON arguments (required by trait but unused)",
            "is_optional": false,
            "name": "_args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "Managing persistence of idea.md artifacts to session-scoped storage at .cowork/sessions/<id>/artifacts/idea.md",
      "Retrieving idea.md content from session-scoped storage for agent access",
      "Implementing the adk_core::Tool trait to enable dynamic agent tool registration",
      "Defining JSON schemas for tool parameter validation and auto-completion",
      "Converting storage operation errors to standardized ADK error types for consistent error handling across the agent system"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": null,
      "file_path": "crates\\cowork-core\\src\\tools\\memory_tools.rs",
      "functions": [
        "query_memory_index",
        "load_memory_detail",
        "save_session_memory",
        "promote_to_project_memory",
        "get_memory_context",
        "filter_items"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "Tool",
        "ToolContext",
        "ProjectMemoryIndex",
        "SessionMemoryIndex",
        "MemoryItem",
        "TimelineEvent",
        "MemoryStatistics",
        "MemoryContextProject",
        "MemoryContextSession",
        "MemoryContextInfo"
      ],
      "name": "memory_tools.rs",
      "source_summary": "// Memory Tools - Tools for the dual-layer memory system\n//\n// These tools allow agents to:\n// - Query memory indices (project and session level)\n// - Load memory details\n// - Save session memories\n// - Promote session memories to project level\n// - Get memory context\n\nuse adk_core::{Tool, ToolContext};\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::sync::Arc;\nuse crate::memory::*;\nuse crate::storage::get_cowork_dir;\nuse std::fs;\n\n// ============================================================================\n// Query Memory Index Tool\n// ============================================================================\n\npub struct QueryMemoryIndexTool;\n\n#[async_trait]\nimpl Tool for QueryMemoryIndexTool {\n    fn name(&self) -> &str {\n        \"query_memory_index\"\n    }\n\n    fn description(&self) -> &str {\n        \"Query memory index to get a list of memory items (decisions, experiences, patterns, records). Use this before loading detailed memory content to find relevant items.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"query_type\": {\n                    \"type\": \"string\",\n                    \"description\": \"Which memory to query: 'all' (both project and session), 'project' (project-level only), or 'session' (current session only)\",\n                    \"enum\": [\"all\", \"project\", \"session\"],\n                    \"default\": \"all\"\n                },\n                \"category\": {\n                    \"type\": \"string\",\n                    \"description\": \"Filter by memory category: 'decision', 'experience', 'pattern', 'record', or 'all' for all categories\",\n                    \"enum\": [\"decision\", \"experience\", \"pattern\", \"record\", \"all\"],\n                    \"default\": \"all\"\n                },\n                \"stage\": {\n                    \"type\": \"string\",\n                    \"description\": \"Filter by stage (e.g., 'idea', 'prd', 'design', 'plan', 'coding', 'check'). Optional.\",\n                    \"default\": null\n                },\n                \"limit\": {\n                    \"type\": \"number\",\n                    \"description\": \"Maximum number of results to return. Default: 20\",\n                    \"default\": 20\n                }\n            },\n            \"required\": []\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let query_type = args.get(\"query_type\").and_then(|v| v.as_str()).unwrap_or(\"all\");\n        let category = args.get(\"category\").and_then(|v| v.as_str()).unwrap_or(\"all\");\n        let stage = args.get(\"stage\").and_then(|v| v.as_str());\n        let limit = args.get(\"limit\").and_then(|v| v.as_i64()).unwrap_or(20);\n\n        let mut results = Vec::new();\n\n        // Query project memory\n        if query_type == \"all\" || query_type == \"project\" {\n            if let Ok(project_file) = get_project_memory_file() {\n                if let Ok(content) = fs::read_to_string(&project_file) {\n                    if let Ok(index) = serde_json::from_str::<ProjectMemoryIndex>(&content) {\n                        for item in Self::filter_items(index.key_decisions, category, stage, limit) {\n                            results.push(item);\n                        }\n                        for item in Self::filter_items(index.key_experiences, category, stage, limit) {\n                            results.push(item);\n                        }\n                        for item in Self::filter_items(index.patterns, category, stage, limit) {\n                            results.push(item);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Query session memory (get current session from .cowork/session.json)\n        if query_type == \"all\" || query_type == \"session\" {\n            if let Ok(cow_dir) = get_cowork_dir() {\n                if let Ok(index_content) = fs::read_to_string(cow_dir.join(\"session.json\")) {\n                    if let Ok(index) = serde_json::from_str::<crate::data::ProjectIndex>(&index_content) {\n                        if let Some(current_session_id) = index.latest_successful_session {\n                            if let Ok(session_file) = get_session_memory_file(&current_session_id) {\n                                if let Ok(content) = fs::read_to_string(&session_file) {\n                                    if let Ok(session_index) = serde_json::from_str::<SessionMemoryIndex>(&content) {\n                                        for item in Self::filter_items(session_index.decisions, category, stage, limit) {\n                                            results.push(item);\n                                        }\n                                        for item in Self::filter_items(session_index.experiences, category, stage, limit) {\n                                            results.push(item);\n                                        }\n                                        for item in Self::filter_items(session_index.records, category, stage, limit) {\n                                            results.push(item);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Sort by created_at descending and apply limit\n        results.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n        results.truncate(limit as usize);\n\n        let total = results.len();\n\n        Ok(json!({\n            \"results\": results,\n            \"total\": total\n        }))\n    }\n}\n\nimpl QueryMemoryIndexTool {\n    fn filter_items(items: Vec<MemoryItem>, category: &str, stage_filter: Option<&str>, _limit: i64) -> Vec<MemoryItem> {\n        items.into_iter()\n            .filter(|item| {\n                if category != \"all\" && item.category != category {\n                    return false;\n                }\n                if let Some(stage) = stage_filter {\n                    if let Some(item_stage) = &item.stage {\n                        if item_stage != stage {\n                            return false;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n                true\n            })\n            .collect()\n    }\n}\n\n// ============================================================================\n// Load Memory Detail Tool\n// ============================================================================\n\npub struct LoadMemoryDetailTool;\n\n#[async_trait]\nimpl Tool for LoadMemoryDetailTool {\n    fn name(&self) -> &str {\n        \"load_memory_detail\"\n    }\n\n    fn description(&self) -> &str {\n        \"Load the detailed content of a memory item from its markdown file. Use this after querying the index to get the full details of a specific memory item.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"memory_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The ID of the memory item to load\"\n                },\n                \"file\": {\n                    \"type\": \"string\",\n                    \"description\": \"The file path to the memory detail (as returned by query_memory_index)\"\n                }\n            },\n            \"required\": [\"memory_id\", \"file\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let memory_id = args.get(\"memory_id\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"memory_id is required\".to_string()))?;\n        let file = args.get(\"file\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"file is required\".to_string()))?;\n\n        let cow_dir = get_cowork_dir()\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get cow dir: {}\", e)))?;\n        let full_path = cow_dir.join(file);\n\n        let content = fs::read_to_string(&full_path)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read memory file: {}\", e)))?;\n\n        Ok(json!({\n            \"memory_id\": memory_id,\n            \"content\": content,\n            \"file\": file\n        }))\n    }\n}\n\n// ============================================================================\n// Save Session Memory Tool\n// ============================================================================\n\npub struct SaveSessionMemoryTool;\n\n#[async_trait]\nimpl Tool for SaveSessionMemoryTool {\n    fn name(&self) -> &str {\n        \"save_session_memory\"\n    }\n\n    fn description(&self) -> &str {\n        \"Save a memory item to the current session's memory. Use this to record important decisions, experiences, or observations during the session.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"memory_type\": {\n                    \"type\": \"string\",\n                    \"description\": \"Type of memory: 'decision', 'experience', or 'record'\",\n                    \"enum\": [\"decision\", \"experience\", \"record\"]\n                },\n                \"title\": {\n                    \"type\": \"string\",\n                    \"description\": \"Title of the memory item\"\n                },\n                \"summary\": {\n                    \"type\": \"string\",\n                    \"description\": \"Brief summary of the memory (1-2 sentences)\"\n                },\n                \"content\": {\n                    \"type\": \"string\",\n                    \"description\": \"Detailed markdown content of the memory\"\n                },\n                \"stage\": {\n                    \"type\": \"string\",\n                    \"description\": \"The current stage (e.g., 'idea', 'prd', 'design', 'plan', 'coding', 'check')\"\n                },\n                \"category\": {\n                    \"type\": \"string\",\n                    \"description\": \"Category for better organization (e.g., 'technical', 'design', 'user-experience')\"\n                },\n                \"impact\": {\n                    \"type\": \"string\",\n                    \"description\": \"Impact level: 'high', 'medium', or 'low'\",\n                    \"enum\": [\"high\", \"medium\", \"low\"],\n                    \"default\": \"medium\"\n                },\n                \"tags\": {\n                    \"type\": \"array\",\n                    \"description\": \"Tags for better searchability\",\n                    \"items\": {\"type\": \"string\"},\n                    \"default\": []\n                }\n            },\n            \"required\": [\"memory_type\", \"title\", \"summary\", \"content\", \"stage\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let memory_type = args.get(\"memory_type\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"memory_type is required\".to_string()))?;\n        let title = args.get(\"title\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"title is required\".to_string()))?;\n        let summary = args.get(\"summary\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"summary is required\".to_string()))?;\n        let content = args.get(\"content\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"content is required\".to_string()))?;\n        let stage = args.get(\"stage\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"stage is required\".to_string()))?;\n        let _category = args.get(\"category\").and_then(|v| v.as_str()).unwrap_or(\"general\");\n        let impact = args.get(\"impact\").and_then(|v| v.as_str()).unwrap_or(\"medium\");\n        let tags: Vec<String> = args.get(\"tags\")\n            .and_then(|v| v.as_array())\n            .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect())\n            .unwrap_or_default();\n\n        // Get current session ID\n        let cow_dir = get_cowork_dir()\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get cow dir: {}\", e)))?;\n        let index_content = fs::read_to_string(cow_dir.join(\"session.json\"))\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read session index: {}\", e)))?;\n        let index: crate::data::ProjectIndex = serde_json::from_str(&index_content)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to parse session index: {}\", e)))?;\n        let session_id = index.latest_successful_session\n            .ok_or_else(|| adk_core::AdkError::Tool(\"No active session found\".to_string()))?;\n\n        // Generate memory ID\n        let memory_id = format!(\"{}-{:04}\",\n            memory_type.chars().next().unwrap_or('X'),\n            chrono::Utc::now().timestamp() % 10000\n        );\n\n        // Create detail directory and file\n        let detail_dir = get_session_memory_detail_dir(&session_id)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get session memory detail dir: {}\", e)))?\n            .join(format!(\"{}s\", memory_type));\n        fs::create_dir_all(&detail_dir)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to create detail directory: {}\", e)))?;\n\n        let file_path = detail_dir.join(format!(\"{}.md\", memory_id));\n        let file_relative = format!(\"sessions/sessions/{}/{}s/{}.md\", session_id, memory_type, memory_id);\n\n        // Write markdown content\n        fs::write(&file_path, content)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to write memory file: {}\", e)))?;\n\n        // Update session memory index\n        let session_index_file = get_session_memory_file(&session_id)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get session memory file: {}\", e)))?;\n        let mut session_index: SessionMemoryIndex = if session_index_file.exists() {\n            let content = fs::read_to_string(&session_index_file)\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read session memory index: {}\", e)))?;\n            serde_json::from_str(&content)\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to parse session memory index: {}\", e)))?\n        } else {\n            SessionMemoryIndex {\n                session_id: session_id.clone(),\n                session_type: \"modify\".to_string(),\n                session_description: \"\".to_string(),\n                schema_version: \"1.0\".to_string(),\n                created_at: chrono::Utc::now(),\n                updated_at: chrono::Utc::now(),\n                status: \"active\".to_string(),\n                overview: SessionOverview {\n                    stages_completed: vec![],\n                    key_achievements: vec![],\n                    challenges_faced: vec![],\n                },\n                decisions: vec![],\n                experiences: vec![],\n                records: vec![],\n            }\n        };\n\n        // Add memory item to appropriate category\n        let item = MemoryItem {\n            id: memory_id.clone(),\n            title: title.to_string(),\n            category: memory_type.to_string(),\n            summary: summary.to_string(),\n            stage: Some(stage.to_string()),\n            session_id: Some(session_id.clone()),\n            created_at: chrono::Utc::now(),\n            impact: impact.to_string(),\n            status: \"implemented\".to_string(),\n            file: file_relative.clone(),\n            tags: tags.clone(),\n        };\n\n        match memory_type {\n            \"decision\" => session_index.decisions.push(item),\n            \"experience\" => session_index.experiences.push(item),\n            \"record\" => session_index.records.push(item),\n            _ => return Err(adk_core::AdkError::Tool(format!(\"Invalid memory type: {}\", memory_type))),\n        }\n\n        session_index.updated_at = chrono::Utc::now();\n\n        // Save updated index\n        fs::write(&session_index_file, serde_json::to_string_pretty(&session_index).unwrap())\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to save session memory index: {}\", e)))?;\n\n        Ok(json!({\n            \"memory_id\": memory_id,\n            \"file\": file_relative,\n            \"message\": \"Session memory saved successfully\"\n        }))\n    }\n}\n\n// ============================================================================\n// Promote to Project Memory Tool\n// ============================================================================\n\npub struct PromoteToProjectMemoryTool;\n\n#[async_trait]\nimpl Tool for PromoteToProjectMemoryTool {\n    fn name(&self) -> &str {\n        \"promote_to_project_memory\"\n    }\n\n    fn description(&self) -> &str {\n        \"Promote a session memory item to project-level memory. Use this for decisions or experiences that are valuable across sessions and should be remembered at the project level.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"memory_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The ID of the session memory item to promote\"\n                },\n                \"reason\": {\n                    \"type\": \"string\",\n                    \"description\": \"Why this memory should be promoted to project level\"\n                }\n            },\n            \"required\": [\"memory_id\", \"reason\"]\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\n        let memory_id = args.get(\"memory_id\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"memory_id is required\".to_string()))?;\n        let reason = args.get(\"reason\").and_then(|v| v.as_str())\n            .ok_or_else(|| adk_core::AdkError::Tool(\"reason is required\".to_string()))?;\n\n        // Get current session ID\n        let cow_dir = get_cowork_dir()\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get cow dir: {}\", e)))?;\n        let index_content = fs::read_to_string(cow_dir.join(\"session.json\"))\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read session index: {}\", e)))?;\n        let index: crate::data::ProjectIndex = serde_json::from_str(&index_content)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to parse session index: {}\", e)))?;\n        let session_id = index.latest_successful_session\n            .ok_or_else(|| adk_core::AdkError::Tool(\"No active session found\".to_string()))?;\n\n        // Read session memory index\n        let session_index_file = get_session_memory_file(&session_id)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get session memory file: {}\", e)))?;\n        let session_index_content = fs::read_to_string(&session_index_file)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read session memory index: {}\", e)))?;\n        let session_index: SessionMemoryIndex = serde_json::from_str(&session_index_content)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to parse session memory index: {}\", e)))?;\n\n        // Find the memory item\n        let memory_item = session_index.decisions.iter()\n            .chain(session_index.experiences.iter())\n            .chain(session_index.records.iter())\n            .find(|item| item.id == memory_id)\n            .ok_or_else(|| adk_core::AdkError::Tool(format!(\"Memory item not found: {}\", memory_id)))?;\n\n        // Create project memory ID\n        let project_memory_id = format!(\"{}-{:04}\",\n            memory_item.id.chars().next().unwrap_or('X'),\n            chrono::Utc::now().timestamp() % 10000\n        );\n\n        // Copy to project memory directory\n        let project_detail_dir = get_project_memory_detail_dir()\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get project memory detail dir: {}\", e)))?\n            .join(format!(\"{}s\", memory_item.category));\n        fs::create_dir_all(&project_detail_dir)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to create project memory directory: {}\", e)))?;\n\n        let old_file = cow_dir.join(&memory_item.file);\n        let new_file = project_detail_dir.join(format!(\"{}.md\", project_memory_id));\n        let new_file_relative = format!(\"project_memory/{}s/{}.md\", memory_item.category, project_memory_id);\n\n        fs::copy(&old_file, &new_file)\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to copy memory file: {}\", e)))?;\n\n        // Update project memory index\n        let project_index_file = get_project_memory_file()\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to get project memory file: {}\", e)))?;\n        let mut project_index: ProjectMemoryIndex = if project_index_file.exists() {\n            let content = fs::read_to_string(&project_index_file)\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to read project memory index: {}\", e)))?;\n            serde_json::from_str(&content)\n                .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to parse project memory index: {}\", e)))?\n        } else {\n            ProjectMemoryIndex {\n                project_id: \"default\".to_string(),\n                project_name: \"Default Project\".to_string(),\n                schema_version: \"1.0\".to_string(),\n                created_at: chrono::Utc::now(),\n                updated_at: chrono::Utc::now(),\n                key_decisions: vec![],\n                key_experiences: vec![],\n                patterns: vec![],\n                timeline: vec![],\n                statistics: MemoryStatistics {\n                    total_decisions: 0,\n                    total_experiences: 0,\n                    total_patterns: 0,\n                    total_sessions: 0,\n                },\n            }\n        };\n\n        // Add promoted item\n        let promoted_item = MemoryItem {\n            id: project_memory_id.clone(),\n            title: memory_item.title.clone(),\n            category: memory_item.category.clone(),\n            summary: memory_item.summary.clone(),\n            stage: memory_item.stage.clone(),\n            session_id: Some(session_id.clone()),\n            created_at: chrono::Utc::now(),\n            impact: memory_item.impact.clone(),\n            status: \"implemented\".to_string(),\n            file: new_file_relative.clone(),\n            tags: memory_item.tags.clone(),\n        };\n\n        // Add timeline event\n        project_index.timeline.push(TimelineEvent {\n            timestamp: chrono::Utc::now(),\n            event_type: format!(\"promoted_{}\", memory_item.category),\n            description: format!(\"Promoted from session {}: {}\", session_id, reason),\n            related_memory_id: Some(project_memory_id.clone()),\n        });\n\n        // Add to appropriate category\n        match memory_item.category.as_str() {\n            \"decision\" => {\n                project_index.key_decisions.push(promoted_item);\n                project_index.statistics.total_decisions += 1;\n            }\n            \"experience\" => {\n                project_index.key_experiences.push(promoted_item);\n                project_index.statistics.total_experiences += 1;\n            }\n            \"pattern\" => {\n                project_index.patterns.push(promoted_item);\n                project_index.statistics.total_patterns += 1;\n            }\n            _ => {}\n        }\n\n        project_index.updated_at = chrono::Utc::now();\n\n        // Save updated index\n        fs::write(&project_index_file, serde_json::to_string_pretty(&project_index).unwrap())\n            .map_err(|e| adk_core::AdkError::Tool(format!(\"Failed to save project memory index: {}\", e)))?;\n\n        Ok(json!({\n            \"project_memory_id\": project_memory_id,\n            \"file\": new_file_relative,\n            \"message\": \"Memory promoted to project level successfully\"\n        }))\n    }\n}\n\n// ============================================================================\n// Get Memory Context Tool\n// ============================================================================\n\npub struct GetMemoryContextTool;\n\n#[async_trait]\nimpl Tool for GetMemoryContextTool {\n    fn name(&self) -> &str {\n        \"get_memory_context\"\n    }\n\n    fn description(&self) -> &str {\n        \"Get the current memory context including project memory summary, session memory summary, and general context information. Use this before making decisions to understand the current memory state.\"\n    }\n\n    fn parameters_schema(&self) -> Option<Value> {\n        Some(json!({\n            \"type\": \"object\",\n            \"properties\": {},\n            \"required\": []\n        }))\n    }\n\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\n        // Get project memory\n        let project_memory = if let Ok(project_file) = get_project_memory_file() {\n            if let Ok(content) = fs::read_to_string(&project_file) {\n                if let Ok(index) = serde_json::from_str::<ProjectMemoryIndex>(&content) {\n                    MemoryContextProject {\n                        total_decisions: index.key_decisions.len(),\n                        total_experiences: index.key_experiences.len(),\n                        key_decisions: index.key_decisions.iter()\n                            .take(5)\n                            .map(|d| (d.id.clone(), d.title.clone()))\n                            .collect(),\n                    }\n                } else {\n                    MemoryContextProject {\n                        total_decisions: 0,\n                        total_experiences: 0,\n                        key_decisions: vec![],\n                    }\n                }\n            } else {\n                MemoryContextProject {\n                    total_decisions: 0,\n                    total_experiences: 0,\n                    key_decisions: vec![],\n                }\n            }\n        } else {\n            MemoryContextProject {\n                total_decisions: 0,\n                total_experiences: 0,\n                key_decisions: vec![],\n            }\n        };\n\n        // Get session memory\n        let session_memory = if let Ok(cow_dir) = get_cowork_dir() {\n            if let Ok(index_content) = fs::read_to_string(cow_dir.join(\"session.json\")) {\n                if let Ok(index) = serde_json::from_str::<crate::data::ProjectIndex>(&index_content) {\n                    if let Some(current_session_id) = index.latest_successful_session {\n                        if let Ok(session_file) = get_session_memory_file(&current_session_id) {\n                            if let Ok(content) = fs::read_to_string(&session_file) {\n                                if let Ok(session_index) = serde_json::from_str::<SessionMemoryIndex>(&content) {\n                                    MemoryContextSession {\n                                        session_id: current_session_id.clone(),\n                                        status: session_index.status,\n                                        stages_completed: session_index.overview.stages_completed,\n                                        current_stage: \"coding\".to_string(), // Default stage\n                                        decisions: session_index.decisions.len(),\n                                        experiences: session_index.experiences.len(),\n                                    }\n                                } else {\n                                    MemoryContextSession::default()\n                                }\n                            } else {\n                                MemoryContextSession::default()\n                            }\n                        } else {\n                            MemoryContextSession::default()\n                        }\n                    } else {\n                        MemoryContextSession::default()\n                    }\n                } else {\n                    MemoryContextSession::default()\n                }\n            } else {\n                MemoryContextSession::default()\n            }\n        } else {\n            MemoryContextSession::default()\n        };\n\n        // Get context info\n        let context = MemoryContextInfo {\n            current_time: chrono::Utc::now().to_rfc3339(),\n            project_age: \"Unknown\".to_string(),\n            session_age: \"Unknown\".to_string(),\n        };\n\n        Ok(json!({\n            \"project_memory\": project_memory,\n            \"session_memory\": session_memory,\n            \"context\": context\n        }))\n    }\n}\n\nimpl Default for MemoryContextSession {\n    fn default() -> Self {\n        Self {\n            session_id: \"none\".to_string(),\n            status: \"inactive\".to_string(),\n            stages_completed: vec![],\n            current_stage: \"none\".to_string(),\n            decisions: 0,\n            experiences: 0,\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 48.0,
      "lines_of_code": 671,
      "number_of_classes": 5,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 9,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 10,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 11,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 12,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 13,
        "name": "crate::memory",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 14,
        "name": "crate::storage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 177,
        "name": "crate::data",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 15,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component implements a comprehensive tool suite for managing a dual-layer memory system in a collaborative AI development framework. It provides five distinct tools that enable agents to interact with both project-level (persistent across sessions) and session-level (ephemeral to specific sessions) memory stores.\n\nThe component implements the Tool trait from adk_core to expose functionality to intelligent agents. Each tool handles specific memory operations:\n\n1. QueryMemoryIndexTool: Executes complex queries against memory indices with multi-dimensional filtering (by memory layer, category, development stage) and sorting capabilities. It reads JSON index files from both project_memory and sessions directories, aggregates results, and returns filtered/sorted memory item listings.\n\n2. LoadMemoryDetailTool: Retrieves the full markdown content of specific memory items by reading from the file system using paths obtained from index queries, enabling agents to access complete memory details.\n\n3. SaveSessionMemoryTool: Creates new memory items in the current session with automatic ID generation (type-timestamp format), markdown file creation, directory structure management, and session index updates. It supports three memory types: decisions, experiences, and records, with metadata including impact levels, tags, and stage associations.\n\n4. PromoteToProjectMemoryTool: Facilitates elevation of session-level memories to project-level persistence. This involves copying memory files, regenerating IDs, creating timeline events, updating project statistics, and maintaining cross-references to the original session.\n\n5. GetMemoryContextTool: Provides a holistic view of the current memory state by aggregating summaries from both memory layers, including counts of decisions/experiences, recent key decisions, session status, and completed stages.\n\nAll tools implement robust error handling with detailed error messages, file system operations with proper path resolution, and JSON serialization/deserialization for persistence. The component uses chrono for timestamp management and maintains consistent data structures across memory layers.",
    "interfaces": [
      {
        "description": "The core trait that all memory tools implement from adk_core, defining the contract for agent-accessible tools with name, description, parameters schema, and execute method",
        "interface_type": "trait",
        "name": "Tool",
        "parameters": [
          {
            "description": "Returns the tool identifier name",
            "is_optional": false,
            "name": "name",
            "param_type": "&self"
          },
          {
            "description": "Returns a human-readable description of the tool's purpose",
            "is_optional": false,
            "name": "description",
            "param_type": "&self"
          },
          {
            "description": "Returns JSON schema defining valid parameters for the tool",
            "is_optional": false,
            "name": "parameters_schema",
            "param_type": "&self"
          },
          {
            "description": "Async method that executes the tool logic with provided arguments and context",
            "is_optional": false,
            "name": "execute",
            "param_type": "&self, Arc<dyn ToolContext>, Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Queries memory indices and returns filtered lists of memory items based on query_type, category, stage, and limit parameters",
        "interface_type": "method",
        "name": "QueryMemoryIndexTool::query_memory_index",
        "parameters": [
          {
            "description": "Filter by memory layer: 'all', 'project', or 'session'",
            "is_optional": true,
            "name": "query_type",
            "param_type": "string"
          },
          {
            "description": "Filter by memory category: 'decision', 'experience', 'pattern', 'record', or 'all'",
            "is_optional": true,
            "name": "category",
            "param_type": "string"
          },
          {
            "description": "Filter by development stage (e.g., 'idea', 'prd', 'design', 'plan', 'coding', 'check')",
            "is_optional": true,
            "name": "stage",
            "param_type": "string"
          },
          {
            "description": "Maximum number of results to return",
            "is_optional": true,
            "name": "limit",
            "param_type": "number"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Internal helper method that filters a vector of memory items by category and stage criteria",
        "interface_type": "method",
        "name": "QueryMemoryIndexTool::filter_items",
        "parameters": [
          {
            "description": "The memory items to filter",
            "is_optional": false,
            "name": "items",
            "param_type": "Vec<MemoryItem>"
          },
          {
            "description": "Category filter string",
            "is_optional": false,
            "name": "category",
            "param_type": "&str"
          },
          {
            "description": "Optional stage filter string",
            "is_optional": false,
            "name": "stage_filter",
            "param_type": "Option<&str>"
          },
          {
            "description": "Result limit (currently unused in filtering logic)",
            "is_optional": false,
            "name": "_limit",
            "param_type": "i64"
          }
        ],
        "return_type": "Vec<MemoryItem>",
        "visibility": "private"
      },
      {
        "description": "Loads the detailed markdown content of a specific memory item given its ID and file path",
        "interface_type": "method",
        "name": "LoadMemoryDetailTool::load_memory_detail",
        "parameters": [
          {
            "description": "The unique identifier of the memory item",
            "is_optional": false,
            "name": "memory_id",
            "param_type": "string"
          },
          {
            "description": "The relative file path to the memory's markdown content",
            "is_optional": false,
            "name": "file",
            "param_type": "string"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Creates a new memory item in the current session with automatic directory creation, ID generation, and index updates",
        "interface_type": "method",
        "name": "SaveSessionMemoryTool::save_session_memory",
        "parameters": [
          {
            "description": "Type of memory: 'decision', 'experience', or 'record'",
            "is_optional": false,
            "name": "memory_type",
            "param_type": "string"
          },
          {
            "description": "Title of the memory item",
            "is_optional": false,
            "name": "title",
            "param_type": "string"
          },
          {
            "description": "Brief 1-2 sentence summary of the memory",
            "is_optional": false,
            "name": "summary",
            "param_type": "string"
          },
          {
            "description": "Detailed markdown content of the memory",
            "is_optional": false,
            "name": "content",
            "param_type": "string"
          },
          {
            "description": "Current development stage",
            "is_optional": false,
            "name": "stage",
            "param_type": "string"
          },
          {
            "description": "Organizational category (default: 'general')",
            "is_optional": true,
            "name": "category",
            "param_type": "string"
          },
          {
            "description": "Impact level: 'high', 'medium', or 'low' (default: 'medium')",
            "is_optional": true,
            "name": "impact",
            "param_type": "string"
          },
          {
            "description": "Array of string tags for searchability",
            "is_optional": true,
            "name": "tags",
            "param_type": "array"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Promotes a session memory item to project-level memory with file copying and timeline event creation",
        "interface_type": "method",
        "name": "PromoteToProjectMemoryTool::promote_to_project_memory",
        "parameters": [
          {
            "description": "The ID of the session memory to promote",
            "is_optional": false,
            "name": "memory_id",
            "param_type": "string"
          },
          {
            "description": "Justification for why this memory should be promoted",
            "is_optional": false,
            "name": "reason",
            "param_type": "string"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Retrieves comprehensive memory context including summaries of project and session memories and current temporal context",
        "interface_type": "method",
        "name": "GetMemoryContextTool::get_memory_context",
        "parameters": [],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Memory Index Query and Filtering - Provides efficient querying and filtering of memory indices from both project-level and session-level memory stores with support for category, stage, and result count filtering",
      "Memory Content Management - Handles the complete lifecycle of memory content including loading detailed markdown files, saving new session memories with automatic file creation, and promoting memories between memory layers",
      "Memory Context Aggregation - Aggregates comprehensive memory context information from multiple sources to provide agents with situational awareness of the current memory state",
      "Dual-Layer Memory Orchestration - Manages the interaction between project-level (persistent) and session-level (ephemeral) memory systems, including promotion workflows and session tracking",
      "File System and Persistence Operations - Manages all file I/O operations for memory storage including index file reading/writing, markdown content storage, directory creation, and file copying between layers"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Tools for modify workflow - Save/Load ChangeRequest and PatchMetadata. Implements ADK tools for persisting and retrieving change request data in a collaborative workflow system.",
      "file_path": "crates\\cowork-core\\src\\tools\\modify_tools.rs",
      "functions": [
        "SaveChangeRequestTool::new",
        "SaveChangeRequestTool::name",
        "SaveChangeRequestTool::description",
        "SaveChangeRequestTool::parameters_schema",
        "SaveChangeRequestTool::execute",
        "LoadChangeRequestTool::new",
        "LoadChangeRequestTool::name",
        "LoadChangeRequestTool::description",
        "LoadChangeRequestTool::parameters_schema",
        "LoadChangeRequestTool::execute"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "save_change_request",
        "load_change_request"
      ],
      "name": "modify_tools.rs",
      "source_summary": "// Tools for modify workflow - Save/Load ChangeRequest and PatchMetadata\r\nuse crate::data::*;\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext, AdkError};\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\n// ============================================================================\r\n// SaveChangeRequestTool\r\n// ============================================================================\r\n\r\npub struct SaveChangeRequestTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl SaveChangeRequestTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for SaveChangeRequestTool {\r\n    fn name(&self) -> &str {\r\n        \"save_change_request\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Save the analyzed ChangeRequest. This is the output of the Change Triage Agent.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"requires_prd_update\": {\r\n                    \"type\": \"boolean\",\r\n                    \"description\": \"Does PRD need updating?\"\r\n                },\r\n                \"requires_design_update\": {\r\n                    \"type\": \"boolean\",\r\n                    \"description\": \"Does design need updating?\"\r\n                },\r\n                \"requires_plan_update\": {\r\n                    \"type\": \"boolean\",\r\n                    \"description\": \"Does plan need updating?\"\r\n                },\r\n                \"requires_code_change\": {\r\n                    \"type\": \"boolean\",\r\n                    \"description\": \"Does code need changing?\"\r\n                },\r\n                \"affected_components\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"List of component IDs affected\"\r\n                },\r\n                \"affected_features\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"List of feature IDs affected\"\r\n                },\r\n                \"risk_level\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"low\", \"medium\", \"high\"],\r\n                    \"description\": \"Risk assessment\"\r\n                },\r\n                \"estimated_effort\": {\r\n                    \"type\": \"string\",\r\n                    \"description\": \"Brief effort estimate\"\r\n                },\r\n                \"acceptance_criteria\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"What defines 'done'\"\r\n                },\r\n                \"constraints\": {\r\n                    \"type\": \"array\",\r\n                    \"items\": {\"type\": \"string\"},\r\n                    \"description\": \"Things to preserve\"\r\n                }\r\n            },\r\n            \"required\": [\"requires_prd_update\", \"requires_design_update\", \"requires_plan_update\", \"requires_code_change\", \"risk_level\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        // Load existing change request\r\n        let mut change_request = load_change_request(&self.session_id)\r\n            .map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        // Update scope\r\n        change_request.scope.requires_prd_update = args[\"requires_prd_update\"].as_bool().unwrap_or(false);\r\n        change_request.scope.requires_design_update = args[\"requires_design_update\"].as_bool().unwrap_or(false);\r\n        change_request.scope.requires_plan_update = args[\"requires_plan_update\"].as_bool().unwrap_or(false);\r\n        change_request.scope.requires_code_change = args[\"requires_code_change\"].as_bool().unwrap_or(true);\r\n\r\n        // Update analysis\r\n        let risk_level = match args[\"risk_level\"].as_str().unwrap_or(\"medium\") {\r\n            \"low\" => RiskLevel::Low,\r\n            \"high\" => RiskLevel::High,\r\n            _ => RiskLevel::Medium,\r\n        };\r\n\r\n        let analysis = ChangeAnalysis {\r\n            affected_components: args.get(\"affected_components\")\r\n                .and_then(|v| v.as_array())\r\n                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect())\r\n                .unwrap_or_default(),\r\n            affected_features: args.get(\"affected_features\")\r\n                .and_then(|v| v.as_array())\r\n                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect())\r\n                .unwrap_or_default(),\r\n            risk_level,\r\n            estimated_effort: args.get(\"estimated_effort\")\r\n                .and_then(|v| v.as_str())\r\n                .unwrap_or(\"Unknown\")\r\n                .to_string(),\r\n        };\r\n\r\n        change_request.analysis = Some(analysis);\r\n\r\n        // Update acceptance criteria\r\n        if let Some(criteria) = args.get(\"acceptance_criteria\").and_then(|v| v.as_array()) {\r\n            change_request.acceptance_criteria = criteria.iter()\r\n                .filter_map(|v| v.as_str().map(|s| s.to_string()))\r\n                .collect();\r\n        }\r\n\r\n        // Update constraints\r\n        if let Some(constraints) = args.get(\"constraints\").and_then(|v| v.as_array()) {\r\n            change_request.constraints = constraints.iter()\r\n                .filter_map(|v| v.as_str().map(|s| s.to_string()))\r\n                .collect();\r\n        }\r\n\r\n        // Save\r\n        save_change_request(&self.session_id, &change_request)\r\n            .map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        println!(\"✅ Change request analyzed and saved\");\r\n        println!(\"   Scope: PRD={}, Design={}, Plan={}, Code={}\",\r\n            change_request.scope.requires_prd_update,\r\n            change_request.scope.requires_design_update,\r\n            change_request.scope.requires_plan_update,\r\n            change_request.scope.requires_code_change);\r\n        println!(\"   Risk: {:?}\", change_request.analysis.as_ref().unwrap().risk_level);\r\n\r\n        Ok(json!({\r\n            \"status\": \"success\",\r\n            \"message\": \"Change request saved successfully\"\r\n        }))\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// LoadChangeRequestTool\r\n// ============================================================================\r\n\r\npub struct LoadChangeRequestTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl LoadChangeRequestTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for LoadChangeRequestTool {\r\n    fn name(&self) -> &str {\r\n        \"load_change_request\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Load the ChangeRequest for this session. Use this to understand what needs to be implemented.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let change_request = load_change_request(&self.session_id)\r\n            .map_err(|e| AdkError::Tool(e.to_string()))?;\r\n\r\n        Ok(serde_json::to_value(change_request)\r\n            .map_err(|e| AdkError::Tool(e.to_string()))?)\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 8.0,
      "lines_of_code": 191,
      "number_of_classes": 2,
      "number_of_functions": 10
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::data",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "crate::storage",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This Rust module provides specialized ADK (Agent Development Kit) Tools for managing ChangeRequest entities in a collaborative workflow system. It implements two core tools: SaveChangeRequestTool and LoadChangeRequestTool.\n\nThe SaveChangeRequestTool handles persistence of analyzed change requests, capturing scope information (PRD, design, plan, code update requirements), risk assessments (low/medium/high), affected components/features, effort estimates, acceptance criteria, and constraints. It provides comprehensive JSON schema validation through its parameters_schema() method and performs complex data transformation from JSON arguments to internal ChangeRequest/ChangeAnalysis structures.\n\nThe LoadChangeRequestTool provides read-only access to existing change request data for a given session, enabling agents to retrieve current state information without parameters. This forms a complete CRUD cycle for change request management within agent-based workflows.\n\nThe tools integrate with the storage layer through load_change_request() and save_change_request() functions, handling serialization/deserialization via serde_json and providing rich console output for debugging/monitoring purposes. Error handling converts storage errors to AdkError::Tool variants for consistent error propagation within the ADK framework.\n\n**Business Logic Flow:**\n1. Change Triage Agent analyzes change requirements\n2. SaveChangeRequestTool receives JSON arguments with scope flags, risk level, and analysis data\n3. Tool loads existing change request by session_id\n4. Updates scope fields (boolean flags for PRD/Design/Plan/Code updates)\n5. Constructs ChangeAnalysis with risk level enum mapping, component lists, and effort estimates\n6. Optionally updates acceptance criteria and constraints arrays\n7. Persists modified change request back to storage\n8. Outputs success confirmation with formatted scope summary",
    "interfaces": [
      {
        "description": "Returns the tool name identifier",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns the human-readable tool description",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON schema for parameter validation",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Executes the tool with given context and arguments",
        "interface_type": "method",
        "name": "execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "_ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "JSON arguments for the tool",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "adk_core::Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Constructs a new SaveChangeRequestTool instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for change request",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructs a new LoadChangeRequestTool instance",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier for change request",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Persist analyzed ChangeRequest data to storage, including scope flags (PRD/design/plan/code updates), risk assessments, affected components, effort estimates, and constraints",
      "Retrieve ChangeRequest data from storage by session ID for agent consumption, enabling workflow continuity across agent interactions",
      "Transform JSON tool arguments into strongly-typed internal data structures (ChangeRequest, ChangeAnalysis, RiskLevel enum) with safe defaults",
      "Provide structured JSON schema definitions for parameter validation and self-documentation of tool capabilities",
      "Implement ADK Tool trait for seamless integration with agent framework, supporting async execution and standardized error handling"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "tool",
      "description": "Validation tools for checking data quality in session-scoped context, providing data format validation, feature coverage checking, and circular dependency detection",
      "file_path": "crates\\cowork-core\\src\\tools\\validation_tools.rs",
      "functions": [
        "CheckDataFormatTool::new",
        "CheckDataFormatTool::name",
        "CheckDataFormatTool::description",
        "CheckDataFormatTool::parameters_schema",
        "CheckDataFormatTool::execute",
        "CheckDataFormatTool::validate_requirements_schema",
        "CheckDataFormatTool::validate_features_schema",
        "CheckDataFormatTool::validate_design_schema",
        "CheckDataFormatTool::validate_plan_schema",
        "CheckFeatureCoverageTool::new",
        "CheckFeatureCoverageTool::name",
        "CheckFeatureCoverageTool::description",
        "CheckFeatureCoverageTool::parameters_schema",
        "CheckFeatureCoverageTool::execute",
        "CheckTaskDependenciesTool::new",
        "CheckTaskDependenciesTool::name",
        "CheckTaskDependenciesTool::description",
        "CheckTaskDependenciesTool::parameters_schema",
        "CheckTaskDependenciesTool::execute",
        "detect_cycle"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "CheckDataFormatTool",
        "CheckFeatureCoverageTool",
        "CheckTaskDependenciesTool",
        "Tool"
      ],
      "name": "validation_tools.rs",
      "source_summary": "// Validation tools for checking data quality (Session-scoped)\r\nuse crate::storage::*;\r\nuse adk_core::{Tool, ToolContext};\r\n\r\nuse async_trait::async_trait;\r\nuse serde_json::{json, Value};\r\nuse std::sync::Arc;\r\n\r\n// ============================================================================\r\n// CheckDataFormatTool\r\n// ============================================================================\r\n\r\npub struct CheckDataFormatTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CheckDataFormatTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CheckDataFormatTool {\r\n    fn name(&self) -> &str {\r\n        \"check_data_format\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Validate that a JSON data file conforms to its schema. Returns validation errors if any.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"data_type\": {\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\"requirements\", \"features\", \"design\", \"plan\"],\r\n                    \"description\": \"Which data file to validate\"\r\n                }\r\n            },\r\n            \"required\": [\"data_type\"]\r\n        }))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, args: Value) -> adk_core::Result<Value> {\r\n        let data_type = args[\"data_type\"].as_str().unwrap();\r\n\r\n        let errors = match data_type {\r\n            \"requirements\" => self.validate_requirements_schema(),\r\n            \"features\" => self.validate_features_schema(),\r\n            \"design\" => self.validate_design_schema(),\r\n            \"plan\" => self.validate_plan_schema(),\r\n            _ => return Ok(json!({\"status\": \"error\", \"message\": \"Unknown data type\"})),\r\n        };\r\n\r\n        if errors.is_empty() {\r\n            Ok(json!({\r\n                \"status\": \"valid\",\r\n                \"message\": format!(\"{} data is valid\", data_type)\r\n            }))\r\n        } else {\r\n            Ok(json!({\r\n                \"status\": \"invalid\",\r\n                \"errors\": errors\r\n            }))\r\n        }\r\n    }\r\n}\r\n\r\nimpl CheckDataFormatTool {\r\n    fn validate_requirements_schema(&self) -> Vec<String> {\r\n        let mut errors = vec![];\r\n        match load_requirements(&self.session_id) {\r\n            Ok(requirements) => {\r\n                for req in &requirements.requirements {\r\n                    if req.title.is_empty() {\r\n                        errors.push(format!(\"{}: title is empty\", req.id));\r\n                    }\r\n                    if req.acceptance_criteria.is_empty() {\r\n                        errors.push(format!(\"{}: missing acceptance criteria\", req.id));\r\n                    }\r\n                }\r\n            }\r\n            Err(e) => errors.push(format!(\"Failed to load requirements: {}\", e)),\r\n        }\r\n        errors\r\n    }\r\n\r\n    fn validate_features_schema(&self) -> Vec<String> {\r\n        let mut errors = vec![];\r\n        match load_feature_list(&self.session_id) {\r\n            Ok(features) => {\r\n                for feat in &features.features {\r\n                    if feat.name.is_empty() {\r\n                        errors.push(format!(\"{}: name is empty\", feat.id));\r\n                    }\r\n                    if feat.requirement_ids.is_empty() {\r\n                        errors.push(format!(\"{}: not linked to any requirement\", feat.id));\r\n                    }\r\n                }\r\n            }\r\n            Err(e) => errors.push(format!(\"Failed to load features: {}\", e)),\r\n        }\r\n        errors\r\n    }\r\n\r\n    fn validate_design_schema(&self) -> Vec<String> {\r\n        let mut errors = vec![];\r\n        match load_design_spec(&self.session_id) {\r\n            Ok(design) => {\r\n                if design.architecture.components.is_empty() {\r\n                    errors.push(\"No components defined\".to_string());\r\n                }\r\n            }\r\n            Err(e) => errors.push(format!(\"Failed to load design: {}\", e)),\r\n        }\r\n        errors\r\n    }\r\n\r\n    fn validate_plan_schema(&self) -> Vec<String> {\r\n        let mut errors = vec![];\r\n        match load_implementation_plan(&self.session_id) {\r\n            Ok(plan) => {\r\n                if plan.tasks.is_empty() {\r\n                    errors.push(\"No tasks defined\".to_string());\r\n                }\r\n            }\r\n            Err(e) => errors.push(format!(\"Failed to load plan: {}\", e)),\r\n        }\r\n        errors\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CheckFeatureCoverageTool\r\n// ============================================================================\r\n\r\npub struct CheckFeatureCoverageTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CheckFeatureCoverageTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CheckFeatureCoverageTool {\r\n    fn name(&self) -> &str {\r\n        \"check_feature_coverage\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Check if all features are covered by design components.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let features = load_feature_list(&self.session_id).map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n        let design = load_design_spec(&self.session_id).map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        let uncovered: Vec<String> = features\r\n            .features\r\n            .iter()\r\n            .filter(|f| {\r\n                !design\r\n                    .architecture\r\n                    .components\r\n                    .iter()\r\n                    .any(|c| c.related_features.contains(&f.id))\r\n            })\r\n            .map(|f| f.id.clone())\r\n            .collect();\r\n\r\n        if uncovered.is_empty() {\r\n            Ok(json!({\r\n                \"status\": \"full_coverage\",\r\n                \"message\": \"All features are covered by components\"\r\n            }))\r\n        } else {\r\n            Ok(json!({\r\n                \"status\": \"incomplete_coverage\",\r\n                \"uncovered_features\": uncovered,\r\n                \"message\": format!(\"{} features are not covered\", uncovered.len())\r\n            }))\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CheckTaskDependenciesTool\r\n// ============================================================================\r\n\r\npub struct CheckTaskDependenciesTool {\r\n    session_id: String,\r\n}\r\n\r\nimpl CheckTaskDependenciesTool {\r\n    pub fn new(session_id: String) -> Self {\r\n        Self { session_id }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl Tool for CheckTaskDependenciesTool {\r\n    fn name(&self) -> &str {\r\n        \"check_task_dependencies\"\r\n    }\r\n\r\n    fn description(&self) -> &str {\r\n        \"Analyze task dependencies to detect circular dependencies.\"\r\n    }\r\n\r\n    fn parameters_schema(&self) -> Option<Value> {\r\n        Some(json!({\"type\": \"object\", \"properties\": {}}))\r\n    }\r\n\r\n    async fn execute(&self, _ctx: Arc<dyn ToolContext>, _args: Value) -> adk_core::Result<Value> {\r\n        let plan = load_implementation_plan(&self.session_id).map_err(|e| adk_core::AdkError::Tool(e.to_string()))?;\r\n\r\n        // Build dependency graph\r\n        let mut graph: std::collections::HashMap<String, Vec<String>> =\r\n            std::collections::HashMap::new();\r\n        for task in &plan.tasks {\r\n            graph.insert(task.id.clone(), task.dependencies.clone());\r\n        }\r\n\r\n        // Detect cycles using DFS\r\n        let has_cycles = detect_cycle(&graph);\r\n\r\n        if has_cycles {\r\n            Ok(json!({\r\n                \"status\": \"invalid\",\r\n                \"message\": \"Circular dependencies detected in task graph\"\r\n            }))\r\n        } else {\r\n            Ok(json!({\r\n                \"status\": \"valid\",\r\n                \"message\": \"No circular dependencies detected\"\r\n            }))\r\n        }\r\n    }\r\n}\r\n\r\n/// Detect cycles in dependency graph using DFS\r\nfn detect_cycle(graph: &std::collections::HashMap<String, Vec<String>>) -> bool {\r\n    use std::collections::HashSet;\r\n\r\n    let mut visited = HashSet::new();\r\n    let mut rec_stack = HashSet::new();\r\n\r\n    fn dfs(\r\n        node: &str,\r\n        graph: &std::collections::HashMap<String, Vec<String>>,\r\n        visited: &mut HashSet<String>,\r\n        rec_stack: &mut HashSet<String>,\r\n    ) -> bool {\r\n        visited.insert(node.to_string());\r\n        rec_stack.insert(node.to_string());\r\n\r\n        if let Some(neighbors) = graph.get(node) {\r\n            for neighbor in neighbors {\r\n                if !visited.contains(neighbor) {\r\n                    if dfs(neighbor, graph, visited, rec_stack) {\r\n                        return true;\r\n                    }\r\n                } else if rec_stack.contains(neighbor) {\r\n                    return true; // Cycle detected\r\n                }\r\n            }\r\n        }\r\n\r\n        rec_stack.remove(node);\r\n        false\r\n    }\r\n\r\n    for node in graph.keys() {\r\n        if !visited.contains(node) {\r\n            if dfs(node, graph, &mut visited, &mut rec_stack) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    false\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 32.0,
      "lines_of_code": 292,
      "number_of_classes": 3,
      "number_of_functions": 20
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": false,
        "line_number": null,
        "name": "storage",
        "path": "crate::storage",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": true,
        "line_number": null,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": true,
        "line_number": null,
        "name": "std::collections",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component implements a suite of validation tools for ensuring data quality and consistency within a session-scoped software development workflow. The module contains three main tool implementations:\n\n1. **CheckDataFormatTool**: Validates JSON data files against predefined schemas for four data types: requirements (checking title and acceptance_criteria), features (checking name and requirement linkage), design (checking architecture components), and plan (checking task definitions). Each validation produces structured error reports.\n\n2. **CheckFeatureCoverageTool**: Analyzes the relationship between features and design components to identify uncovered features. Uses set operations to find features not referenced by any architecture component, providing gap analysis for design completeness.\n\n3. **CheckTaskDependenciesTool**: Performs dependency graph analysis using Depth-First Search (DFS) algorithm to detect circular dependencies in implementation plans. The cycle detection uses a standard three-color DFS approach with visited set and recursion stack.\n\nAll tools implement the `Tool` trait from `adk_core`, enabling integration with an agent framework. They follow async patterns and return structured JSON results with status indicators and detailed messages.",
    "interfaces": [
      {
        "description": "Validates JSON data files conform to their schemas based on data type",
        "interface_type": "struct",
        "name": "CheckDataFormatTool",
        "parameters": [
          {
            "description": "Session identifier for data isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Checks if all features are covered by design components",
        "interface_type": "struct",
        "name": "CheckFeatureCoverageTool",
        "parameters": [
          {
            "description": "Session identifier for data isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Analyzes task dependencies to detect circular dependencies",
        "interface_type": "struct",
        "name": "CheckTaskDependenciesTool",
        "parameters": [
          {
            "description": "Session identifier for data isolation",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "impl Tool",
        "visibility": "public"
      },
      {
        "description": "Detects cycles in dependency graph using DFS algorithm",
        "interface_type": "function",
        "name": "detect_cycle",
        "parameters": [
          {
            "description": "Dependency graph represented as adjacency list",
            "is_optional": false,
            "name": "graph",
            "param_type": "&HashMap<String, Vec<String>>"
          }
        ],
        "return_type": "bool",
        "visibility": "private"
      },
      {
        "description": "Returns the tool name identifier",
        "interface_type": "method",
        "name": "name",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns the tool description for agent context",
        "interface_type": "method",
        "name": "description",
        "parameters": [],
        "return_type": "&str",
        "visibility": "public"
      },
      {
        "description": "Returns JSON schema for tool parameters",
        "interface_type": "method",
        "name": "parameters_schema",
        "parameters": [],
        "return_type": "Option<Value>",
        "visibility": "public"
      },
      {
        "description": "Executes the validation logic",
        "interface_type": "async_method",
        "name": "execute",
        "parameters": [
          {
            "description": "Tool execution context",
            "is_optional": false,
            "name": "ctx",
            "param_type": "Arc<dyn ToolContext>"
          },
          {
            "description": "Tool arguments",
            "is_optional": false,
            "name": "args",
            "param_type": "Value"
          }
        ],
        "return_type": "Result<Value>",
        "visibility": "public"
      },
      {
        "description": "Validates requirements data schema",
        "interface_type": "method",
        "name": "validate_requirements_schema",
        "parameters": [],
        "return_type": "Vec<String>",
        "visibility": "private"
      },
      {
        "description": "Validates features data schema",
        "interface_type": "method",
        "name": "validate_features_schema",
        "parameters": [],
        "return_type": "Vec<String>",
        "visibility": "private"
      },
      {
        "description": "Validates design specification schema",
        "interface_type": "method",
        "name": "validate_design_schema",
        "parameters": [],
        "return_type": "Vec<String>",
        "visibility": "private"
      },
      {
        "description": "Validates implementation plan schema",
        "interface_type": "method",
        "name": "validate_plan_schema",
        "parameters": [],
        "return_type": "Vec<String>",
        "visibility": "private"
      },
      {
        "description": "Constructor for CheckDataFormatTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for CheckFeatureCoverageTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Constructor for CheckTaskDependenciesTool",
        "interface_type": "method",
        "name": "new",
        "parameters": [
          {
            "description": "Session identifier",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Self",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Validate data format compliance for requirements, features, design specifications, and implementation plans against their respective schemas",
      "Detect and report uncovered features that lack corresponding design component coverage",
      "Analyze task dependency graphs to identify circular dependencies using DFS algorithm",
      "Provide structured validation error reporting with contextual details for quality assurance",
      "Integrate with agent framework through Tool trait implementation for automated validation workflows"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "crates\\cowork-gui\\src\\App.jsx",
      "functions": [
        "App",
        "loadData",
        "handleSelectIteration",
        "handleExecuteStatusChange",
        "handleCreateGenesisIteration",
        "handleExecuteIteration",
        "handleSendUserMessage",
        "handleSelectOption",
        "handleSubmitFeedback",
        "handleCancelFeedback",
        "getStatusBadge",
        "renderContent"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "App.jsx",
      "source_summary": "import { useState, useEffect, useRef } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport { listen } from '@tauri-apps/api/event';\nimport { Layout, Menu, Button, Spin, Empty, Modal, message, Tooltip, Badge, Input, Tag } from 'antd';\nimport {\n  FolderOutlined,\n  FileTextOutlined,\n  CodeOutlined,\n  EyeOutlined,\n  PlayCircleOutlined,\n  PlusOutlined,\n  ReloadOutlined,\n  MessageOutlined,\n  AppstoreOutlined,\n  DatabaseOutlined,\n  BranchesOutlined,\n  CheckCircleOutlined,\n  RocketOutlined,\n  CloseCircleOutlined,\n  EditOutlined,\n  SendOutlined,\n} from '@ant-design/icons';\nimport ArtifactsViewer from './components/ArtifactsViewer';\nimport CodeEditor from './components/CodeEditor';\nimport PreviewPanel from './components/PreviewPanel';\nimport RunnerPanel from './components/RunnerPanel';\nimport ProjectsPanel from './components/ProjectsPanel';\nimport MemoryPanel from './components/MemoryPanel';\nimport CommandPalette from './components/CommandPalette';\nimport IterationsPanel from './components/IterationsPanel';\n\nconst { Sider, Content, Header, Footer } = Layout;\n\n// Stage definitions for status display\nconst STAGES = [\n  { key: 'idea', label: 'Idea', color: '#1890ff' },\n  { key: 'prd', label: 'PRD', color: '#52c41a' },\n  { key: 'design', label: 'Design', color: '#722ed1' },\n  { key: 'plan', label: 'Plan', color: '#fa8c16' },\n  { key: 'coding', label: 'Coding', color: '#13c2c2' },\n  { key: 'check', label: 'Check', color: '#eb2f96' },\n  { key: 'delivery', label: 'Delivery', color: '#52c41a' },\n];\n\nfunction App() {\n  const [project, setProject] = useState(null);\n  const [iterations, setIterations] = useState([]);\n  const [currentIteration, setCurrentIteration] = useState(null);\n  const [activeView, setActiveView] = useState('projects'); // Default to projects tab when no project is loaded\n  const [hasInitialProject, setHasInitialProject] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [currentStage, setCurrentStage] = useState(null);\n  const [inputRequest, setInputRequest] = useState(null);\n  const [userInput, setUserInput] = useState('');\n  const [showCommandPalette, setShowCommandPalette] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [activeArtifactTab, setActiveArtifactTab] = useState(null);\n  const [currentAgent, setCurrentAgent] = useState(null);\n\n  const listenersRegistered = useRef(false);\n  const messagesContainerRef = useRef(null);\n\n  // Load initial data\n  const loadData = async () => {\n    try {\n      setLoading(true);\n\n      // Load project\n      const projectData = await invoke('gui_get_project');\n      setProject(projectData);\n\n      if (projectData) {\n        // Load iterations\n        const iterationsData = await invoke('gui_get_iterations');\n        setIterations(iterationsData || []);\n\n        // Update current iteration if it exists\n        if (currentIteration) {\n          const updatedIteration = iterationsData?.find(\n            (i) => i.id === currentIteration.id\n          );\n          if (updatedIteration) {\n            setCurrentIteration(updatedIteration);\n          }\n        } else if (projectData.current_iteration_id) {\n          const iteration = iterationsData?.find(\n            (i) => i.id === projectData.current_iteration_id\n          );\n          setCurrentIteration(iteration || null);\n        }\n\n        // If we have a project and haven't switched to iterations yet, do it now\n        if (!hasInitialProject) {\n          setActiveView('iterations');\n          setHasInitialProject(true);\n        }\n      } else {\n        // No project loaded, ensure we're on projects tab\n        setActiveView('projects');\n        setHasInitialProject(false);\n      }\n    } catch (error) {\n      console.error('[App] Failed to load data:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadData();\n\n    // Listen for events\n    const setupListeners = async () => {\n      if (listenersRegistered.current) return;\n      listenersRegistered.current = true;\n\n      await listen('iteration_created', () => {\n        loadData();\n        message.success('Iteration created');\n      });\n\n      await listen('iteration_started', (event) => {\n        const iterationId = event.payload;\n        setIsProcessing(true);\n        handleExecuteStatusChange(iterationId, 'running');\n        message.info('Iteration started');\n      });\n\n      await listen('iteration_completed', (event) => {\n        const iterationId = event.payload;\n        setIsProcessing(false);\n        setCurrentStage(null);\n        setCurrentAgent(null);\n        handleExecuteStatusChange(iterationId, 'completed');\n        message.success('Iteration completed');\n      });\n\n      await listen('iteration_failed', (event) => {\n        const [iterationId, error] = event.payload;\n        setIsProcessing(false);\n        setCurrentStage(null);\n        setCurrentAgent(null);\n        handleExecuteStatusChange(iterationId, 'error');\n        message.error('Iteration failed: ' + error);\n      });\n\n      await listen('agent_event', (event) => {\n        const { content, is_thinking, agent_name } = event.payload;\n        // Track current agent for processing display\n        if (agent_name) {\n          setCurrentAgent(agent_name);\n        }\n        if (!is_thinking && content) {\n          setMessages((prev) => {\n            const lastMsg = prev[prev.length - 1];\n            if (lastMsg && lastMsg.type === 'agent' && lastMsg.isStreaming) {\n              return [\n                ...prev.slice(0, -1),\n                {\n                  ...lastMsg,\n                  content: lastMsg.content + content,\n                  agentName: agent_name || lastMsg.agentName,\n                },\n              ];\n            } else {\n              return [\n                ...prev,\n                {\n                  type: 'agent',\n                  content,\n                  agentName: agent_name || 'AI Agent',\n                  isStreaming: true,\n                  timestamp: new Date().toISOString(),\n                },\n              ];\n            }\n          });\n        }\n      });\n\n      await listen('input_request', (event) => {\n        const [requestId, prompt, options] = event.payload;\n        // Check if this is an artifact confirmation request\n        const artifactMatch = prompt.match(/\\[ARTIFACT_TYPE:(\\w+)\\]$/);\n        if (artifactMatch) {\n          const artifactType = artifactMatch[1];\n          const cleanPrompt = prompt.replace(/\\[ARTIFACT_TYPE:\\w+\\]$/, '').trim();\n          setInputRequest({ \n            requestId, \n            prompt: cleanPrompt, \n            options,\n            isArtifactConfirmation: true,\n            artifactType\n          });\n        } else {\n          setInputRequest({ requestId, prompt, options });\n        }\n        setUserInput('');\n      });\n\n      await listen('project_loaded', () => {\n        loadData();\n        message.success('Project loaded');\n      });\n\n      await listen('project_initialized', () => {\n        loadData();\n        message.success('Project initialized');\n      });\n    };\n\n    setupListeners();\n\n    // Keyboard shortcuts\n    const handleKeyDown = (e) => {\n      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {\n        e.preventDefault();\n        setShowCommandPalette(true);\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, []);\n\n  // Auto-scroll messages\n  useEffect(() => {\n    if (messagesContainerRef.current) {\n      messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;\n    }\n  }, [messages]);\n\n  const handleSelectIteration = (iterationId) => {\n    const iteration = iterations.find((i) => i.id === iterationId);\n    setCurrentIteration(iteration);\n    setActiveView('chat');\n  };\n\n  const handleExecuteStatusChange = (iterationId, status) => {\n    // Update local state when execution status changes\n    if (status === 'running') {\n      setIsProcessing(true);\n      // Find the iteration and update it\n      const iteration = iterations.find((i) => i.id === iterationId);\n      if (iteration) {\n        setCurrentIteration({ ...iteration, status: 'Running' });\n      }\n    } else if (status === 'completed') {\n      setIsProcessing(false);\n      loadData(); // Refresh data\n    } else if (status === 'error') {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleCreateGenesisIteration = async (title, description) => {\n    try {\n      const request = {\n        title,\n        description,\n        base_iteration_id: null,\n        inheritance: 'none',\n      };\n\n      const iteration = await invoke('gui_create_iteration', { request });\n      setCurrentIteration(iteration);\n      setActiveView('chat');\n      message.success('Genesis iteration created');\n    } catch (error) {\n      message.error('Failed to create iteration: ' + error);\n    }\n  };\n\n  const handleExecuteIteration = async () => {\n    if (!currentIteration) return;\n\n    try {\n      setIsProcessing(true);\n      await invoke('gui_execute_iteration', { iterationId: currentIteration.id });\n      message.info('Iteration execution started');\n    } catch (error) {\n      message.error('Failed to execute iteration: ' + error);\n      setIsProcessing(false);\n    }\n  };\n\n  const handleSendUserMessage = async () => {\n    if (!userInput.trim()) return;\n\n    const message = userInput;\n    setMessages((prev) => [\n      ...prev,\n      { type: 'user', content: message, timestamp: new Date().toISOString() },\n    ]);\n\n    if (inputRequest) {\n      await invoke('submit_input_response', {\n        requestId: inputRequest.requestId,\n        response: message,\n        responseType: 'text',\n      });\n      setInputRequest(null);\n    }\n\n    setUserInput('');\n  };\n\n  const handleSelectOption = async (option) => {\n    if (!inputRequest) return;\n\n    // Handle view artifact option specially\n    if (option.id === 'view_artifact' && inputRequest.isArtifactConfirmation) {\n      // Map artifactType to tab key\n      const artifactTypeToTab = {\n        'idea': 'idea',\n        'requirements': 'requirements',\n        'design': 'design',\n        'plan': 'plan',\n        'code': 'code',\n      };\n      const targetTab = artifactTypeToTab[inputRequest.artifactType] || 'idea';\n      \n      // Set the active tab before switching view\n      setActiveArtifactTab(targetTab);\n      // Switch to artifacts tab\n      setActiveView('artifacts');\n      message.info(`Switched to Artifacts tab to review ${inputRequest.artifactType}`);\n      // Keep the input request active so user can confirm after viewing\n      return;\n    }\n\n    // Handle feedback option - show feedback input mode\n    if (option.id === 'feedback' && inputRequest.isArtifactConfirmation) {\n      setInputRequest({\n        ...inputRequest,\n        isFeedbackMode: true,\n        feedbackPrompt: 'Please enter your feedback or suggestions for improvement:'\n      });\n      setUserInput('');\n      return;\n    }\n\n    // Add user message with context\n    let userMessageContent = option.label;\n    if (option.id === 'yes' && inputRequest.isArtifactConfirmation) {\n      userMessageContent = `✅ Confirmed: Proceed to next stage`;\n    } else if (option.id === 'no') {\n      userMessageContent = `❌ Cancelled: Stop iteration`;\n    }\n\n    setMessages((prev) => [\n      ...prev,\n      { type: 'user', content: userMessageContent, timestamp: new Date().toISOString() },\n    ]);\n\n    await invoke('submit_input_response', {\n      requestId: inputRequest.requestId,\n      response: option.id,\n      responseType: 'selection',\n    });\n\n    setInputRequest(null);\n    setUserInput('');\n  };\n\n  const handleSubmitFeedback = async () => {\n    if (!inputRequest || !userInput.trim()) return;\n\n    const feedback = userInput.trim();\n    \n    // Add system confirmation message before user feedback\n    setMessages((prev) => [\n      ...prev,\n      { \n        type: 'agent', \n        content: `📝 Feedback received. Regenerating based on your input...`, \n        agentName: 'System',\n        timestamp: new Date().toISOString() \n      },\n      { \n        type: 'user', \n        content: `💬 Feedback:\\n${feedback}`, \n        timestamp: new Date().toISOString() \n      },\n    ]);\n\n    // Send feedback as text response\n    await invoke('submit_input_response', {\n      requestId: inputRequest.requestId,\n      response: feedback,\n      responseType: 'text',\n    });\n\n    setInputRequest(null);\n    setUserInput('');\n  };\n\n  const handleCancelFeedback = () => {\n    // Cancel feedback mode and go back to confirmation options\n    if (inputRequest) {\n      setInputRequest({\n        ...inputRequest,\n        isFeedbackMode: false,\n      });\n      setUserInput('');\n    }\n  };\n\n  const getStatusBadge = (status) => {\n    switch (status?.toLowerCase()) {\n      case 'completed':\n        return <Badge status=\"success\" text=\"Completed\" />;\n      case 'running':\n        return <Badge status=\"processing\" text=\"Running\" />;\n      case 'paused':\n        return <Badge status=\"warning\" text=\"Paused\" />;\n      case 'failed':\n        return <Badge status=\"error\" text=\"Failed\" />;\n      default:\n        return <Badge status=\"default\" text=\"Draft\" />;\n    }\n  };\n\n  const renderContent = () => {\n    switch (activeView) {\n      case 'iterations':\n        return (\n          <IterationsPanel\n            onSelectIteration={handleSelectIteration}\n            selectedIterationId={currentIteration?.id}\n            onExecuteStatusChange={handleExecuteStatusChange}\n          />\n        );\n\n      case 'projects':\n        return <ProjectsPanel />;\n\n      case 'chat':\n        if (!currentIteration) {\n          return (\n            <Empty\n              description=\"Select an iteration to view chat\"\n              style={{ marginTop: '40px' }}\n            >\n              <Button type=\"primary\" onClick={() => setActiveView('iterations')}>\n                Go to Iterations\n              </Button>\n            </Empty>\n          );\n        }\n        return (\n          <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n            <div\n              ref={messagesContainerRef}\n              style={{ flex: 1, overflow: 'auto', padding: '20px' }}\n            >\n              <div style={{ marginBottom: '20px', padding: '12px', background: '#f0f5ff', borderRadius: '8px' }}>\n                <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>\n                  <RocketOutlined style={{ marginRight: '8px' }} />\n                  #{currentIteration.number} - {currentIteration.title}\n                </div>\n                <div style={{ fontSize: '12px', color: '#666' }}>\n                  {getStatusBadge(currentIteration.status)}\n                  {currentIteration.current_stage && (\n                    <span style={{ marginLeft: '16px' }}>\n                      Current: <Tag color=\"blue\">{currentIteration.current_stage}</Tag>\n                    </span>\n                  )}\n                </div>\n              </div>\n\n              {messages.map((msg, idx) => (\n                <div\n                  key={idx}\n                  style={{\n                    marginBottom: '16px',\n                    padding: '12px',\n                    background: msg.type === 'user' ? '#e6f7ff' : '#f6ffed',\n                    borderRadius: '8px',\n                    borderLeft: `4px solid ${msg.type === 'user' ? '#1890ff' : '#52c41a'}`,\n                  }}\n                >\n                  <div style={{ fontWeight: 'bold', marginBottom: '4px', fontSize: '12px', color: '#666' }}>\n                    {msg.type === 'user' ? 'You' : msg.agentName || 'AI Agent'}\n                  </div>\n                  <div style={{ whiteSpace: 'pre-wrap' }}>{msg.content}</div>\n                </div>\n              ))}\n\n              {isProcessing && (\n                <div style={{ textAlign: 'center', padding: '20px' }}>\n                  <Spin />\n                  <div style={{ marginTop: '8px', color: '#888' }}>\n                    {currentAgent ? (\n                      <>{currentAgent} is working...</>\n                    ) : currentIteration?.current_stage ? (\n                      `Executing ${currentIteration.current_stage} stage...`\n                    ) : (\n                      'Processing...'\n                    )}\n                  </div>\n                  {currentIteration?.current_stage && (\n                    <div style={{ marginTop: '4px', fontSize: '12px', color: '#aaa' }}>\n                      Stage: {currentIteration.current_stage}\n                    </div>\n                  )}\n                </div>\n              )}\n            </div>\n\n            {inputRequest && (\n              <div style={{ padding: '16px', borderTop: '1px solid #e8e8e8', background: '#fafafa' }}>\n                {inputRequest.isFeedbackMode ? (\n                  // Feedback input mode\n                  <>\n                    <div style={{ marginBottom: '12px', fontWeight: 'bold' }}>\n                      <Tag color=\"orange\" style={{ marginRight: '8px' }}>\n                        <EditOutlined /> Feedback Mode\n                      </Tag>\n                      {inputRequest.feedbackPrompt}\n                    </div>\n                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>\n                      <Input.TextArea\n                        value={userInput}\n                        onChange={(e) => setUserInput(e.target.value)}\n                        placeholder=\"Enter your feedback or suggestions for improvement...\"\n                        rows={4}\n                        autoFocus\n                      />\n                      <div style={{ display: 'flex', gap: '8px', justifyContent: 'flex-end' }}>\n                        <Button onClick={handleCancelFeedback}>\n                          Cancel\n                        </Button>\n                        <Button \n                          type=\"primary\" \n                          icon={<SendOutlined />}\n                          onClick={handleSubmitFeedback}\n                          disabled={!userInput.trim()}\n                        >\n                          Submit Feedback\n                        </Button>\n                      </div>\n                    </div>\n                  </>\n                ) : (\n                  // Normal confirmation mode\n                  <>\n                    <div style={{ marginBottom: '12px', fontWeight: 'bold' }}>\n                      {inputRequest.isArtifactConfirmation && (\n                        <Tag color=\"blue\" style={{ marginRight: '8px' }}>\n                          <EyeOutlined /> Review Required\n                        </Tag>\n                      )}\n                      {inputRequest.prompt}\n                    </div>\n                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>\n                      {inputRequest.options.map((option) => (\n                        <Button \n                          key={option.id} \n                          type={option.id === 'yes' ? 'primary' : option.id === 'view_artifact' ? 'dashed' : option.id === 'feedback' ? 'dashed' : 'default'}\n                          danger={option.id === 'no'}\n                          icon={\n                            option.id === 'view_artifact' ? <EyeOutlined /> : \n                            option.id === 'yes' ? <CheckCircleOutlined /> : \n                            option.id === 'no' ? <CloseCircleOutlined /> : \n                            option.id === 'feedback' ? <EditOutlined /> : null\n                          }\n                          onClick={() => handleSelectOption(option)}\n                        >\n                          {option.label}\n                        </Button>\n                      ))}\n                    </div>\n                  </>\n                )}\n              </div>\n            )}\n\n            <div style={{ padding: '16px', borderTop: '1px solid #e8e8e8', display: 'flex', gap: '8px' }}>\n              <Input\n                value={userInput}\n                onChange={(e) => setUserInput(e.target.value)}\n                onPressEnter={handleSendUserMessage}\n                placeholder={inputRequest ? 'Type your response...' : 'Type a message...'}\n                disabled={!inputRequest}\n              />\n              <Button type=\"primary\" onClick={handleSendUserMessage} disabled={!userInput.trim() || !inputRequest}>\n                Send\n              </Button>\n            </div>\n          </div>\n        );\n\n      case 'artifacts':\n        return currentIteration ? (\n          <ArtifactsViewer \n            iterationId={currentIteration.id} \n            activeTab={activeArtifactTab}\n            onTabChange={setActiveArtifactTab}\n          />\n        ) : (\n          <Empty description=\"Select an iteration\" style={{ marginTop: '40px' }} />\n        );\n\n      case 'code':\n        return currentIteration ? (\n          <CodeEditor iterationId={currentIteration.id} />\n        ) : (\n          <Empty description=\"Select an iteration\" style={{ marginTop: '40px' }} />\n        );\n\n      case 'preview':\n        return currentIteration ? (\n          <PreviewPanel iterationId={currentIteration.id} />\n        ) : (\n          <Empty description=\"Select an iteration\" style={{ marginTop: '40px' }} />\n        );\n\n      case 'run':\n        return currentIteration ? (\n          <RunnerPanel iterationId={currentIteration.id} />\n        ) : (\n          <Empty description=\"Select an iteration\" style={{ marginTop: '40px' }} />\n        );\n\n      case 'memory':\n        return <MemoryPanel currentSession={currentIteration?.id} />;\n\n      default:\n        return null;\n    }\n  };\n\n  if (loading) {\n    return (\n      <div style={{ height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\n        <Spin size=\"large\" tip=\"Loading...\" />\n      </div>\n    );\n  }\n\n  return (\n    <Layout style={{ minHeight: '100vh' }}>\n      <Header style={{ background: '#fff', borderBottom: '1px solid #e8e8e8', padding: '0 24px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n        <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>\n          <h1 style={{ margin: 0, fontSize: '18px' }}>\n            <RocketOutlined style={{ marginRight: '8px', color: '#1890ff' }} />\n            Cowork Forge\n          </h1>\n          {project && (\n            <Tag color=\"blue\">{project.name}</Tag>\n          )}\n        </div>\n\n        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>\n          {currentIteration && (\n            <>\n              {getStatusBadge(currentIteration.status)}\n              {(currentIteration.status === 'Draft' || currentIteration.status === 'Paused') && (\n                <Button\n                  type=\"primary\"\n                  icon={currentIteration.status === 'Draft' ? <PlayCircleOutlined /> : <ReloadOutlined />}\n                  onClick={handleExecuteIteration}\n                  loading={isProcessing}\n                >\n                  {currentIteration.status === 'Draft' ? 'Start Iteration' : 'Continue'}\n                </Button>\n              )}\n            </>\n          )}\n        </div>\n      </Header>\n\n      <Layout style={{ height: 'calc(100vh - 64px - 48px)' }}>\n        <Sider width={200} style={{ background: '#fff', borderRight: '1px solid #e8e8e8' }}>\n          <Menu\n            mode=\"inline\"\n            selectedKeys={[activeView]}\n            onClick={({ key }) => setActiveView(key)}\n            style={{ height: '100%', borderRight: 0 }}\n            items={[\n              { key: 'iterations', icon: <BranchesOutlined />, label: 'Iterations' },\n              { key: 'chat', icon: <MessageOutlined />, label: 'Chat' },\n              { key: 'artifacts', icon: <FileTextOutlined />, label: 'Artifacts' },\n              { key: 'code', icon: <CodeOutlined />, label: 'Code' },\n              { key: 'preview', icon: <EyeOutlined />, label: 'Preview' },\n              { key: 'run', icon: <PlayCircleOutlined />, label: 'Run' },\n              { key: 'memory', icon: <DatabaseOutlined />, label: 'Memory' },\n              { key: 'projects', icon: <AppstoreOutlined />, label: 'Projects' },\n            ]}\n          />\n        </Sider>\n\n        <Content style={{ overflow: 'hidden', height: '100%', display: 'flex', flexDirection: 'column' }}>\n          {renderContent()}\n        </Content>\n      </Layout>\n\n      <Footer style={{ background: '#fff', borderTop: '1px solid #e8e8e8', padding: '12px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <div style={{ fontSize: '12px', color: '#888' }}>\n          {project ? (\n            <>\n              <span style={{ marginRight: '16px' }}>\n                Project: <strong>{project.name}</strong>\n              </span>\n              <span>\n                Iterations: <strong>{iterations.length}</strong>\n              </span>\n            </>\n          ) : (\n            'No project loaded'\n          )}\n        </div>\n        <div style={{ fontSize: '12px', color: '#888' }}>\n          {isProcessing ? (\n            <span style={{ color: '#1890ff' }}>\n              <Spin size=\"small\" style={{ marginRight: '8px' }} />\n              {currentAgent ? `${currentAgent} is working...` : 'Processing...'}\n            </span>\n          ) : (\n            <span style={{ color: '#52c41a' }}>\n              <CheckCircleOutlined style={{ marginRight: '4px' }} />\n              Ready\n            </span>\n          )}\n        </div>\n      </Footer>\n\n      <CommandPalette\n        visible={showCommandPalette}\n        onClose={() => setShowCommandPalette(false)}\n        onCommandSelect={(commandId) => {\n          switch (commandId) {\n            case 'view-iterations':\n              setActiveView('iterations');\n              break;\n            case 'view-chat':\n              setActiveView('chat');\n              break;\n            case 'view-artifacts':\n              setActiveView('artifacts');\n              break;\n            case 'view-code':\n              setActiveView('code');\n              break;\n            case 'view-preview':\n              setActiveView('preview');\n              break;\n            case 'view-run':\n              setActiveView('run');\n              break;\n            case 'view-memory':\n              setActiveView('memory');\n              break;\n            case 'view-projects':\n              setActiveView('projects');\n              break;\n          }\n        }}\n      />\n    </Layout>\n  );\n}\n\nexport default App;\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 59.0,
      "lines_of_code": 766,
      "number_of_classes": 0,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "@tauri-apps/api/event",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": true,
        "line_number": null,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/ArtifactsViewer",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/CodeEditor",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/PreviewPanel",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/RunnerPanel",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/ProjectsPanel",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/MemoryPanel",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/CommandPalette",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "import",
        "is_external": false,
        "line_number": null,
        "name": "./components/IterationsPanel",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "App.jsx is the main entry point of the Cowork Forge application, a desktop GUI built with Tauri and React. It orchestrates the entire user interface and business logic flow, managing state for projects, iterations, messages, and user interactions. The component integrates with native Tauri backend services via invoke() and event listeners to handle project lifecycle events, iteration execution, and AI agent communication. It features a multi-tab interface (Iterations, Chat, Artifacts, Code, Preview, Run, Memory, Projects) with dynamic content rendering based on active view state. The app supports real-time event-driven communication: AI agents send streaming messages via 'agent_event', request user input via 'input_request', and report iteration status changes. User interactions include sending messages, selecting options from prompts, submitting feedback, and triggering actions via keyboard shortcuts (Ctrl+K). The component also manages UI state like loading spinners, processing indicators, and command palette visibility. It serves as the central hub connecting frontend UI with backend AI agent workflows and project data.",
    "interfaces": [],
    "responsibilities": [
      "Orchestrates the entire application lifecycle and UI state",
      "Manages communication between React frontend and Tauri backend via RPC and event listeners",
      "Coordinates user interactions across multiple panels (Chat, Artifacts, Code, etc.)",
      "Handles iteration execution workflow and status tracking",
      "Provides input handling for AI agent prompts and user feedback submission"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "page",
      "description": null,
      "file_path": "crates\\cowork-gui\\src\\components\\ArtifactsViewer.jsx",
      "functions": [
        "ArtifactsViewer",
        "loadArtifacts",
        "toggleViewMode",
        "requirementsToMarkdown",
        "featuresToMarkdown",
        "designToMarkdown",
        "planToMarkdown"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "ArtifactsViewer.jsx",
      "source_summary": "import { useState, useEffect } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport rehypeHighlight from 'rehype-highlight';\nimport rehypeRaw from 'rehype-raw';\nimport JsonView from 'react-json-view';\nimport { Tabs, Spin, Alert, Empty, Button, Space } from 'antd';\nimport { FileTextOutlined, ProjectOutlined, DatabaseOutlined, BuildOutlined, CheckCircleOutlined, FileMarkdownOutlined } from '@ant-design/icons';\nimport 'highlight.js/styles/atom-one-dark.css';\n\nconst ArtifactsViewer = ({ iterationId, activeTab: externalActiveTab, onTabChange }) => {\n  const [artifacts, setArtifacts] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [activeTab, setActiveTab] = useState('idea');\n  const [viewModes, setViewModes] = useState({});\n\n  // Sync with external active tab when provided\n  useEffect(() => {\n    if (externalActiveTab) {\n      setActiveTab(externalActiveTab);\n    }\n  }, [externalActiveTab]);\n\n  useEffect(() => {\n    if (iterationId) {\n      loadArtifacts();\n    }\n  }, [iterationId]);\n\n  const loadArtifacts = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Try new V2 API first, fall back to legacy API\n      const data = await invoke('get_iteration_artifacts', { iterationId })\n        .catch(() => invoke('get_session_artifacts', { sessionId: iterationId }));\n      setArtifacts(data);\n    } catch (err) {\n      setError(err.toString());\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const toggleViewMode = (tabKey) => {\n    setViewModes(prev => ({\n      ...prev,\n      [tabKey]: prev[tabKey] === 'json' ? 'doc' : 'json'\n    }));\n  };\n\n  const requirementsToMarkdown = (req) => {\n    if (!req || !req.requirements) return '';\n    let md = `# Requirements\\n\\n`;\n    req.requirements.forEach((r, i) => {\n      md += `## ${i + 1}. ${r.title}\\n\\n`;\n      md += `**ID:** ${r.id}\\n\\n`;\n      md += `**Description:** ${r.description}\\n\\n`;\n      if (r.acceptance_criteria && r.acceptance_criteria.length > 0) {\n        md += `### Acceptance Criteria\\n\\n`;\n        r.acceptance_criteria.forEach((ac, j) => {\n          md += `- ${ac}\\n`;\n        });\n        md += `\\n`;\n      }\n      if (r.notes) {\n        md += `**Notes:** ${r.notes}\\n\\n`;\n      }\n      md += `---\\n\\n`;\n    });\n    return md;\n  };\n\n  const featuresToMarkdown = (feat) => {\n    if (!feat || !feat.features) return '';\n    let md = `# Features\\n\\n`;\n    feat.features.forEach((f, i) => {\n      const title = f.title || f.name || `Feature ${i + 1}`;\n      md += `## ${i + 1}. ${title}\\n\\n`;\n      if (f.id) {\n        md += `**ID:** ${f.id}\\n\\n`;\n      }\n      if (f.description) {\n        md += `**Description:** ${f.description}\\n\\n`;\n      }\n      if (f.scenarios && f.scenarios.length > 0) {\n        md += `### Scenarios\\n\\n`;\n        f.scenarios.forEach((sc, j) => {\n          const scTitle = sc.title || `Scenario ${j + 1}`;\n          md += `#### ${scTitle}\\n\\n`;\n          if (sc.given) {\n            md += `**Given:** ${sc.given}\\n\\n`;\n          }\n          if (sc.when) {\n            md += `**When:** ${sc.when}\\n\\n`;\n          }\n          if (sc.then) {\n            md += `**Then:** ${sc.then}\\n\\n`;\n          }\n        });\n      }\n      if (f.notes) {\n        md += `**Notes:** ${f.notes}\\n\\n`;\n      }\n      md += `---\\n\\n`;\n    });\n    return md;\n  };\n\n  const designToMarkdown = (design) => {\n    if (!design) return '';\n    let md = `# Design Specification\\n\\n`;\n    if (design.overview) {\n      md += `## Overview\\n\\n`;\n      if (typeof design.overview === 'string') {\n        md += `${design.overview}\\n\\n`;\n      } else if (typeof design.overview === 'object') {\n        md += `${JSON.stringify(design.overview, null, 2)}\\n\\n`;\n      }\n    }\n    if (design.architecture) {\n      md += `## Architecture\\n\\n`;\n      if (typeof design.architecture === 'string') {\n        md += `${design.architecture}\\n\\n`;\n      } else if (typeof design.architecture === 'object') {\n        // Handle object format\n        if (design.architecture.type) {\n          md += `**Type:** ${design.architecture.type}\\n\\n`;\n        }\n        if (design.architecture.description) {\n          md += `**Description:** ${design.architecture.description}\\n\\n`;\n        }\n        if (design.architecture.components && Array.isArray(design.architecture.components)) {\n          md += `**Components:**\\n\\n`;\n          design.architecture.components.forEach((comp, j) => {\n            md += `- ${comp.name || comp.type}: ${comp.description || ''}\\n`;\n          });\n          md += `\\n`;\n        }\n        // If still need to show full object\n        md += `\\n\\`\\`\\`\\n${JSON.stringify(design.architecture, null, 2)}\\n\\`\\`\\`\\n\\n`;\n      }\n    }\n    if (design.components && design.components.length > 0) {\n      md += `## Components\\n\\n`;\n      design.components.forEach((comp, i) => {\n        const compName = comp.name || comp.type || `Component ${i + 1}`;\n        md += `### ${i + 1}. ${compName}\\n\\n`;\n        if (comp.description) {\n          md += `**Description:** ${comp.description}\\n\\n`;\n        }\n        if (comp.responsibilities && comp.responsibilities.length > 0) {\n          md += `**Responsibilities:**\\n\\n`;\n          comp.responsibilities.forEach((resp) => {\n            md += `- ${resp}\\n`;\n          });\n          md += `\\n`;\n        }\n      });\n    }\n    if (design.technology_stack) {\n      md += `## Technology Stack\\n\\n`;\n      if (typeof design.technology_stack === 'string') {\n        md += `${design.technology_stack}\\n\\n`;\n      } else if (typeof design.technology_stack === 'object') {\n        // Handle object format\n        if (design.technology_stack.frontend) {\n          md += `**Frontend:** ${design.technology_stack.frontend}\\n\\n`;\n        }\n        if (design.technology_stack.backend) {\n          md += `**Backend:** ${design.technology_stack.backend}\\n\\n`;\n        }\n        if (design.technology_stack.database) {\n          md += `**Database:** ${design.technology_stack.database}\\n\\n`;\n        }\n        if (design.technology_stack.other) {\n          md += `**Other:** ${design.technology_stack.other}\\n\\n`;\n        }\n        // Show all fields\n        Object.entries(design.technology_stack).forEach(([key, value]) => {\n          if (typeof value === 'string') {\n            md += `**${key.charAt(0).toUpperCase() + key.slice(1)}:** ${value}\\n\\n`;\n          }\n        });\n      }\n    }\n    return md;\n  };\n\n  const planToMarkdown = (plan) => {\n    if (!plan || !plan.tasks) return '';\n    let md = `# Implementation Plan\\n\\n`;\n    if (plan.overview) {\n      md += `## Overview\\n\\n${plan.overview}\\n\\n`;\n    }\n    if (plan.tasks && plan.tasks.length > 0) {\n      md += `## Tasks\\n\\n`;\n      plan.tasks.forEach((task, i) => {\n        md += `### ${i + 1}. ${task.title}\\n\\n`;\n        md += `**ID:** ${task.id}\\n\\n`;\n        md += `**Description:** ${task.description}\\n\\n`;\n        if (task.estimated_hours) {\n          md += `**Estimated Hours:** ${task.estimated_hours}\\n\\n`;\n        }\n        if (task.dependencies && task.dependencies.length > 0) {\n          md += `**Dependencies:** ${task.dependencies.join(', ')}\\n\\n`;\n        }\n        md += `---\\n\\n`;\n      });\n    }\n    return md;\n  };\n\n  if (loading) {\n    return (\n      <div style={{ textAlign: 'center', padding: '40px' }}>\n        <Spin size=\"large\" tip=\"Loading artifacts...\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert\n        message=\"Error loading artifacts\"\n        description={error}\n        type=\"error\"\n        showIcon\n        action={\n          <Button size=\"small\" onClick={loadArtifacts}>Retry</Button>\n        }\n      />\n    );\n  }\n\n  if (!artifacts) {\n    return (\n      <Empty\n        description=\"No artifacts available\"\n        image={Empty.PRESENTED_IMAGE_SIMPLE}\n      />\n    );\n  }\n\n  const items = [];\n\n  if (artifacts.idea) {\n    items.push({\n      key: 'idea',\n      label: <span><FileTextOutlined /> Idea</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div className=\"artifact-content markdown-content\" style={{ flex: 1, overflow: 'auto' }}>\n            <ReactMarkdown\n              remarkPlugins={[remarkGfm]}\n              rehypePlugins={[rehypeHighlight, rehypeRaw]}\n            >\n              {artifacts.idea}\n            </ReactMarkdown>\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.requirements) {\n    const reqViewMode = viewModes['requirements'] || 'doc';\n    items.push({\n      key: 'requirements',\n      label: <span><ProjectOutlined /> Requirements</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div style={{ \n            padding: '10px 20px', \n            borderBottom: '1px solid #303030', \n            display: 'flex', \n            justifyContent: 'space-between', \n            alignItems: 'center',\n            background: '#1f1f1f',\n            flexShrink: 0\n          }}>\n            <span style={{ fontWeight: 'bold', color: '#fff' }}>\n              Requirements ({artifacts.requirements.requirements.length})\n            </span>\n            <Space>\n              <Button \n                size=\"small\" \n                type={reqViewMode === 'doc' ? 'primary' : 'default'}\n                icon={<FileMarkdownOutlined />}\n                onClick={() => toggleViewMode('requirements')}\n              >\n                Doc\n              </Button>\n              <Button \n                size=\"small\" \n                type={reqViewMode === 'json' ? 'primary' : 'default'}\n                onClick={() => toggleViewMode('requirements')}\n              >\n                JSON\n              </Button>\n            </Space>\n          </div>\n          <div className=\"artifact-content\" style={{ flex: 1, overflow: 'auto', padding: '20px' }}>\n            {reqViewMode === 'doc' ? (\n              <div className=\"markdown-content\">\n                <ReactMarkdown\n                  remarkPlugins={[remarkGfm]}\n                  rehypePlugins={[rehypeHighlight, rehypeRaw]}\n                >\n                  {requirementsToMarkdown(artifacts.requirements)}\n                </ReactMarkdown>\n              </div>\n            ) : (\n              <div style={{ overflow: 'auto', maxHeight: '100%' }}>\n                <JsonView\n                  src={artifacts.requirements}\n                  theme=\"dark\"\n                  displayObjectSize={false}\n                  enableClipboard={false}\n                  indentWidth={2}\n                  collapsed={false}\n                  quotesOnKeys={false}\n                  sortKeys={false}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.features) {\n    const featViewMode = viewModes['features'] || 'doc';\n    items.push({\n      key: 'features',\n      label: <span><DatabaseOutlined /> Features</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div style={{ \n            padding: '10px 20px', \n            borderBottom: '1px solid #303030', \n            display: 'flex', \n            justifyContent: 'space-between', \n            alignItems: 'center',\n            background: '#1f1f1f',\n            flexShrink: 0\n          }}>\n            <span style={{ fontWeight: 'bold', color: '#fff' }}>\n              Features ({artifacts.features.features.length})\n            </span>\n            <Space>\n              <Button \n                size=\"small\" \n                type={featViewMode === 'doc' ? 'primary' : 'default'}\n                icon={<FileMarkdownOutlined />}\n                onClick={() => toggleViewMode('features')}\n              >\n                Doc\n              </Button>\n              <Button \n                size=\"small\" \n                type={featViewMode === 'json' ? 'primary' : 'default'}\n                onClick={() => toggleViewMode('features')}\n              >\n                JSON\n              </Button>\n            </Space>\n          </div>\n          <div className=\"artifact-content\" style={{ flex: 1, overflow: 'auto', padding: '20px' }}>\n            {featViewMode === 'doc' ? (\n              <div className=\"markdown-content\">\n                <ReactMarkdown\n                  remarkPlugins={[remarkGfm]}\n                  rehypePlugins={[rehypeHighlight, rehypeRaw]}\n                >\n                  {featuresToMarkdown(artifacts.features)}\n                </ReactMarkdown>\n              </div>\n            ) : (\n              <div style={{ overflow: 'auto', maxHeight: '100%' }}>\n                <JsonView\n                  src={artifacts.features}\n                  theme=\"dark\"\n                  displayObjectSize={false}\n                  enableClipboard={false}\n                  indentWidth={2}\n                  collapsed={false}\n                  quotesOnKeys={false}\n                  sortKeys={false}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.design_raw || artifacts.design) {\n    const designViewMode = viewModes['design'] || 'doc';\n    const designContent = artifacts.design_raw || designToMarkdown(artifacts.design);\n    items.push({\n      key: 'design',\n      label: <span><BuildOutlined /> Design</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div style={{\n            padding: '10px 20px',\n            borderBottom: '1px solid #303030',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            background: '#1f1f1f',\n            flexShrink: 0\n          }}>\n            <span style={{ fontWeight: 'bold', color: '#fff' }}>\n              Design Specification\n            </span>\n            {!artifacts.design_raw && (\n              <Space>\n                <Button\n                  size=\"small\"\n                  type={designViewMode === 'doc' ? 'primary' : 'default'}\n                  icon={<FileMarkdownOutlined />}\n                  onClick={() => toggleViewMode('design')}\n                >\n                  Doc\n                </Button>\n                <Button\n                  size=\"small\"\n                  type={designViewMode === 'json' ? 'primary' : 'default'}\n                  onClick={() => toggleViewMode('design')}\n                >\n                  JSON\n                </Button>\n              </Space>\n            )}\n          </div>\n          <div className=\"artifact-content\" style={{ flex: 1, overflow: 'auto', padding: '20px' }}>\n            {artifacts.design_raw || designViewMode === 'doc' ? (\n              <div className=\"markdown-content\">\n                <ReactMarkdown\n                  remarkPlugins={[remarkGfm]}\n                  rehypePlugins={[rehypeHighlight, rehypeRaw]}\n                >\n                  {designContent}\n                </ReactMarkdown>\n              </div>\n            ) : (\n              <div style={{ overflow: 'auto', maxHeight: '100%' }}>\n                <JsonView\n                  src={artifacts.design}\n                  theme=\"dark\"\n                  displayObjectSize={false}\n                  enableClipboard={false}\n                  indentWidth={2}\n                  collapsed={false}\n                  quotesOnKeys={false}\n                  sortKeys={false}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.plan_raw || artifacts.plan) {\n    const planViewMode = viewModes['plan'] || 'doc';\n    const planContent = artifacts.plan_raw || planToMarkdown(artifacts.plan);\n    items.push({\n      key: 'plan',\n      label: <span><CheckCircleOutlined /> Plan</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div style={{\n            padding: '10px 20px',\n            borderBottom: '1px solid #303030',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            background: '#1f1f1f',\n            flexShrink: 0\n          }}>\n            <span style={{ fontWeight: 'bold', color: '#fff' }}>\n              Implementation Plan\n            </span>\n            {!artifacts.plan_raw && (\n              <Space>\n                <Button\n                  size=\"small\"\n                  type={planViewMode === 'doc' ? 'primary' : 'default'}\n                  icon={<FileMarkdownOutlined />}\n                  onClick={() => toggleViewMode('plan')}\n                >\n                  Doc\n                </Button>\n                <Button\n                  size=\"small\"\n                  type={planViewMode === 'json' ? 'primary' : 'default'}\n                  onClick={() => toggleViewMode('plan')}\n                >\n                  JSON\n                </Button>\n              </Space>\n            )}\n          </div>\n          <div className=\"artifact-content\" style={{ flex: 1, overflow: 'auto', padding: '20px' }}>\n            {artifacts.plan_raw || planViewMode === 'doc' ? (\n              <div className=\"markdown-content\">\n                <ReactMarkdown\n                  remarkPlugins={[remarkGfm]}\n                  rehypePlugins={[rehypeHighlight, rehypeRaw]}\n                >\n                  {planContent}\n                </ReactMarkdown>\n              </div>\n            ) : (\n              <div style={{ overflow: 'auto', maxHeight: '100%' }}>\n                <JsonView\n                  src={artifacts.plan}\n                  theme=\"dark\"\n                  displayObjectSize={false}\n                  enableClipboard={false}\n                  indentWidth={2}\n                  collapsed={false}\n                  quotesOnKeys={false}\n                  sortKeys={false}\n                />\n              </div>\n            )}\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.code_files && artifacts.code_files.length > 0) {\n    items.push({\n      key: 'code',\n      label: <span><FileTextOutlined /> Code Files</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div style={{\n            padding: '10px 20px',\n            borderBottom: '1px solid #303030',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            background: '#1f1f1f',\n            flexShrink: 0\n          }}>\n            <span style={{ fontWeight: 'bold', color: '#fff' }}>\n              Code Files ({artifacts.code_files.length})\n            </span>\n          </div>\n          <div className=\"artifact-content\" style={{ flex: 1, overflow: 'auto', padding: '20px' }}>\n            <div style={{ overflow: 'auto', maxHeight: '100%' }}>\n              <JsonView\n                src={artifacts.code_files}\n                theme=\"dark\"\n                displayObjectSize={false}\n                enableClipboard={false}\n                indentWidth={2}\n                collapsed={false}\n                quotesOnKeys={false}\n                sortKeys={false}\n              />\n            </div>\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  if (artifacts.delivery_report) {\n    items.push({\n      key: 'report',\n      label: <span><CheckCircleOutlined /> Report</span>,\n      children: (\n        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n          <div className=\"artifact-content markdown-content\" style={{ flex: 1, overflow: 'auto' }}>\n            <ReactMarkdown\n              remarkPlugins={[remarkGfm]}\n              rehypePlugins={[rehypeHighlight, rehypeRaw]}\n            >\n              {artifacts.delivery_report}\n            </ReactMarkdown>\n          </div>\n        </div>\n      ),\n    });\n  }\n\n  // Handle tab change\n  const handleTabChange = (key) => {\n    setActiveTab(key);\n    if (onTabChange) {\n      onTabChange(key);\n    }\n  };\n\n  return (\n    <div className=\"artifacts-viewer\" style={{ height: '100%' }}>\n      <Tabs\n        activeKey={activeTab}\n        onChange={handleTabChange}\n        type=\"card\"\n        size=\"large\"\n        items={items}\n        style={{ height: '100%' }}\n        className=\"artifacts-tabs\"\n      />\n    </div>\n  );\n};\n\nexport default ArtifactsViewer;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 51.0,
      "lines_of_code": 622,
      "number_of_classes": 0,
      "number_of_functions": 8
    },
    "dependencies": [
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "react-markdown",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "remark-gfm",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "rehype-highlight",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "rehype-raw",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "react-json-view",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "highlight.js",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "runtime",
        "is_external": true,
        "line_number": null,
        "name": "react",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "ArtifactsViewer is a frontend UI page component that displays structured artifacts related to a software iteration or session. It fetches artifact data via Tauri's invoke API, supports multiple artifact types (idea, requirements, features, design, plan, code files, delivery report), and provides dual-view functionality (Markdown documentation and JSON raw data) for most artifact types. The component uses Ant Design's Tabs for navigation, ReactMarkdown for rendering Markdown content with syntax highlighting, and ReactJsonView for displaying structured data. It dynamically generates Markdown from nested JSON structures when raw Markdown is not available, and maintains view mode preferences per artifact type using React state. The component is designed to be embedded in larger UIs and supports external tab control via props.",
    "interfaces": [],
    "responsibilities": [
      "Fetch and display iteration/session artifacts from backend via Tauri IPC",
      "Render multiple artifact types with consistent UI patterns",
      "Provide dual-view toggle (Markdown documentation vs raw JSON) for structured artifacts",
      "Manage tab navigation state and synchronize with parent component",
      "Convert structured JSON data to formatted Markdown when raw Markdown is unavailable"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": "A full-featured code editor component with file tree navigation, multi-tab editing, Monaco Editor integration, code formatting capabilities, and virtual scrolling optimization for large file trees.",
      "file_path": "crates\\cowork-gui\\src\\components\\CodeEditor.jsx",
      "functions": [
        "loadFileTree",
        "formatAllCode",
        "formatActiveFile",
        "loadFileContent",
        "saveFileContent",
        "handleFileSelect",
        "handleToggleFolder",
        "handleCloseFile",
        "handleEditorChange",
        "getLanguageFromPath",
        "renderFileTreeRow"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "CodeEditor.jsx",
      "source_summary": "import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport Editor from '@monaco-editor/react';\nimport { Tabs, Spin, Alert, Empty, Dropdown, Button, Space } from 'antd';\nimport { FolderOutlined, FileOutlined, ReloadOutlined, CaretRightOutlined, CaretDownOutlined, CodeOutlined, DownOutlined } from '@ant-design/icons';\nimport { showError, showSuccess, tryExecute } from '../utils/errorHandler.jsx';\n\n// Try to import react-window if available\nlet FixedSizeList = null;\ntry {\n  FixedSizeList = require('react-window').FixedSizeList;\n} catch (e) {\n  console.warn('react-window not installed. Install it with: npm install react-window');\n}\n\nconst CodeEditor = ({ iterationId }) => {\n  const [fileTree, setFileTree] = useState(null);\n  const [openFiles, setOpenFiles] = useState([]);\n  const [activeFile, setActiveFile] = useState(null);\n  const [fileContents, setFileContents] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [formatting, setFormatting] = useState(false);\n\n  useEffect(() => {\n    if (iterationId) {\n      loadFileTree();\n    }\n  }, [iterationId]);\n\n  // Flatten file tree for virtual scrolling\n  const flatFileTree = useMemo(() => {\n    if (!fileTree) return [];\n    \n    const flatten = (node, depth = 0, result = []) => {\n      if (!node) return result;\n      \n      result.push({\n        ...node,\n        depth,\n        key: node.path,\n      });\n      \n      if (node.children && node.is_expanded) {\n        node.children.forEach(child => flatten(child, depth + 1, result));\n      }\n      \n      return result;\n    };\n    \n    return flatten(fileTree);\n  }, [fileTree]);\n\n  const loadFileTree = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Try new V2 API first, fall back to legacy API\n      const tree = await invoke('get_iteration_file_tree', { iterationId })\n        .catch(() => invoke('get_file_tree', { sessionId: iterationId }));\n      setFileTree(tree);\n    } catch (err) {\n      setError(err.toString());\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const formatAllCode = async () => {\n    setFormatting(true);\n    const result = await tryExecute(async () => {\n      return await invoke('format_code', { iterationId, filePath: null })\n        .catch(() => invoke('format_code', { sessionId: iterationId, filePath: null }));\n    }, 'Failed to format code');\n    \n    setFormatting(false);\n    \n    if (result && result.success) {\n      showSuccess(`Formatted ${result.formatted_files.length} file(s)`);\n      // Reload all open files to show formatted content\n      for (const filePath of openFiles) {\n        await loadFileContent(filePath);\n      }\n    }\n  };\n\n  const formatActiveFile = async () => {\n    if (!activeFile) return;\n    \n    setFormatting(true);\n    const result = await tryExecute(async () => {\n      return await invoke('format_code', { iterationId, filePath: activeFile })\n        .catch(() => invoke('format_code', { sessionId: iterationId, filePath: activeFile }));\n    }, 'Failed to format file');\n    \n    setFormatting(false);\n    \n    if (result && result.success) {\n      showSuccess(`Formatted ${result.formatted_files.length} file(s)`);\n      // Reload active file to show formatted content\n      await loadFileContent(activeFile);\n    }\n  };\n\n  const loadFileContent = async (filePath) => {\n    const result = await tryExecute(async () => {\n      const result = await invoke('read_iteration_file', { \n        iterationId, \n        filePath,\n        offset: null,\n        limit: null\n      }).catch(() => invoke('read_file_content', { \n        sessionId: iterationId, \n        filePath,\n        offset: null,\n        limit: null\n      }));\n      \n      // Handle both old format (string) and new format (FileReadResult)\n      let content = result;\n      if (typeof result === 'object' && result.content !== undefined) {\n        content = result.content;\n        if (result.is_partial) {\n          showWarning(`Large file loaded partially (${result.offset / 1024}KB - ${(result.offset + content.length) / 1024}KB of ${result.total_size / 1024}KB)`);\n        }\n      }\n      \n      setFileContents(prev => ({ ...prev, [filePath]: content }));\n      return content;\n    }, 'Failed to load file content');\n    \n    return result;\n  };\n\n  const saveFileContent = async (filePath, content) => {\n    const success = await tryExecute(async () => {\n      await invoke('save_iteration_file', { iterationId, filePath, content })\n        .catch(() => invoke('save_file_content', { sessionId: iterationId, filePath, content }));\n      return true;\n    }, 'Failed to save file');\n    \n    if (success) {\n      showSuccess('File saved successfully');\n    }\n  };\n\n  const handleFileSelect = useCallback(async (filePath) => {\n    if (!openFiles.includes(filePath)) {\n      setOpenFiles(prev => [...prev, filePath]);\n      await loadFileContent(filePath);\n    }\n    setActiveFile(filePath);\n  }, [openFiles]);\n\n  const handleToggleFolder = useCallback((path) => {\n    const toggleNode = (node) => {\n      if (node.path === path) {\n        return { ...node, is_expanded: !node.is_expanded };\n      }\n      if (node.children) {\n        return {\n          ...node,\n          children: node.children.map(toggleNode)\n        };\n      }\n      return node;\n    };\n    setFileTree(toggleNode(fileTree));\n  }, [fileTree]);\n\n  const handleCloseFile = (targetKey) => {\n    const newOpenFiles = openFiles.filter(key => key !== targetKey);\n    setOpenFiles(newOpenFiles);\n    if (activeFile === targetKey) {\n      setActiveFile(newOpenFiles[newOpenFiles.length - 1] || null);\n    }\n  };\n\n  const handleEditorChange = (value) => {\n    if (activeFile) {\n      setFileContents(prev => ({ ...prev, [activeFile]: value }));\n    }\n  };\n\n  const getLanguageFromPath = (filePath) => {\n    const ext = filePath.split('.').pop().toLowerCase();\n    const langMap = {\n      'rs': 'rust',\n      'js': 'javascript',\n      'jsx': 'javascript',\n      'ts': 'typescript',\n      'tsx': 'typescript',\n      'py': 'python',\n      'html': 'html',\n      'css': 'css',\n      'json': 'json',\n      'md': 'markdown',\n      'toml': 'toml',\n      'yaml': 'yaml',\n      'yml': 'yaml',\n    };\n    return langMap[ext] || 'plaintext';\n  };\n\n  // Render single file tree row for virtual scrolling\n  const renderFileTreeRow = useCallback(({ index, style }) => {\n    const node = flatFileTree[index];\n    if (!node) return null;\n\n    return (\n      <div\n        style={{\n          ...style,\n          paddingLeft: `${node.depth * 20 + 10}px`,\n          display: 'flex',\n          alignItems: 'center',\n          gap: '8px',\n          cursor: 'pointer',\n          color: 'var(--text-primary)',\n        }}\n        onClick={() => {\n          if (node.is_dir) {\n            handleToggleFolder(node.path);\n          } else {\n            handleFileSelect(node.path);\n          }\n        }}\n      >\n        {node.is_dir ? (\n          <>\n            {node.is_expanded ? (\n              <CaretDownOutlined style={{ fontSize: '12px', color: 'var(--text-secondary)' }} />\n            ) : (\n              <CaretRightOutlined style={{ fontSize: '12px', color: 'var(--text-secondary)' }} />\n            )}\n            <FolderOutlined style={{ color: 'var(--primary)' }} />\n          </>\n        ) : (\n          <>\n            <span style={{ width: '12px' }} />\n            <FileOutlined style={{ color: 'var(--text-secondary)' }} />\n          </>\n        )}\n        <span style={{ fontSize: '13px' }}>{node.name}</span>\n      </div>\n    );\n  }, [flatFileTree, handleToggleFolder, handleFileSelect]);\n\n  if (loading) {\n    return (\n      <div style={{ textAlign: 'center', padding: '40px' }}>\n        <Spin size=\"large\" tip=\"Loading files...\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <Alert\n        message=\"Error loading files\"\n        description={error}\n        type=\"error\"\n        showIcon\n        action={\n          <button onClick={loadFileTree}>Retry</button>\n        }\n      />\n    );\n  }\n\n  const tabItems = openFiles.map(filePath => ({\n    key: filePath,\n    label: <span><FileOutlined /> {filePath.split('/').pop()}</span>,\n    closable: true,\n    children: (\n      <div style={{ height: '100%', display: 'flex', flexDirection: 'column', position: 'relative' }}>\n        <div style={{ flex: 1, overflow: 'hidden' }}>\n          {activeFile === filePath ? (\n            <Editor\n              height=\"100%\"\n              language={getLanguageFromPath(filePath)}\n              value={fileContents[filePath] || ''}\n              onChange={(value) => handleEditorChange(value)}\n              theme=\"vs-dark\"\n              options={{\n                minimap: { enabled: true },\n                fontSize: 14,\n                lineNumbers: 'on',\n                renderWhitespace: 'selection',\n                scrollBeyondLastLine: false,\n                automaticLayout: true,\n              }}\n              saveViewState={true}\n              onMount={(editor) => {\n                editor.addCommand(\n                  0,\n                  () => {\n                    if (activeFile) {\n                      saveFileContent(activeFile, editor.getValue());\n                    }\n                  },\n                  'save'\n                );\n              }}\n            />\n          ) : null}\n        </div>\n      </div>\n    ),\n  }));\n\n  return (\n    <div className=\"code-editor-container\" style={{ display: 'flex', height: '100%' }}>\n      {/* File Tree */}\n      <div style={{ \n        width: '250px', \n        borderRight: '1px solid var(--border-color)', \n        background: 'var(--bg-container)',\n        display: 'flex',\n        flexDirection: 'column'\n      }}>\n        <div style={{ padding: '10px', borderBottom: '1px solid var(--border-color)' }}>\n          <h3 style={{ color: 'var(--text-primary)', margin: 0, display: 'flex', alignItems: 'center', gap: '8px' }}>\n            <FolderOutlined /> Files\n            <Dropdown menu={{\n              items: [\n                {\n                  key: 'format-all',\n                  label: <span><CodeOutlined /> Format All Files</span>,\n                  onClick: formatAllCode,\n                },\n                {\n                  key: 'format-active',\n                  label: <span><CodeOutlined /> Format Active File</span>,\n                  onClick: formatActiveFile,\n                  disabled: !activeFile,\n                },\n              ]\n            }}>\n              <Button\n                size=\"small\"\n                icon={<CodeOutlined />}\n                loading={formatting}\n                disabled={!openFiles.length}\n              >\n                Format <DownOutlined />\n              </Button>\n            </Dropdown>\n            <button\n              onClick={loadFileTree}\n              style={{ float: 'right', border: 'none', background: 'none', color: 'var(--primary)', cursor: 'pointer' }}\n            >\n              <ReloadOutlined />\n            </button>\n          </h3>\n        </div>\n        {/* File Tree Content with Virtual Scrolling */}\n        <div style={{ flex: 1, overflow: 'hidden' }}>\n          {FixedSizeList && flatFileTree.length > 50 ? (\n            // Use virtual scrolling for large file trees\n            <FixedSizeList\n              height={600}\n              itemCount={flatFileTree.length}\n              itemSize={32}\n              width=\"100%\"\n            >\n              {renderFileTreeRow}\n            </FixedSizeList>\n          ) : (\n            // Fallback to regular rendering for small file trees\n            <div style={{ overflow: 'auto', height: '100%' }}>\n              {flatFileTree.map((node) => renderFileTreeRow({ index: flatFileTree.indexOf(node), style: {} }))}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Editor */}\n      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', minHeight: 0 }}>\n        <Tabs\n          type=\"editable-card\"\n          activeKey={activeFile}\n          onChange={handleFileSelect}\n          onEdit={(targetKey, action) => {\n            if (action === 'remove') {\n              handleCloseFile(targetKey);\n            }\n          }}\n          hideAdd\n          items={tabItems}\n          animated={false}\n          style={{ \n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column'\n          }}\n          tabBarStyle={{ \n            margin: 0, \n            background: 'var(--bg-container)'\n          }}\n          className=\"code-editor-tabs\"\n        />\n        \n        {openFiles.length === 0 && (\n          <div style={{ \n            flex: 1, \n            display: 'flex', \n            alignItems: 'center', \n            justifyContent: 'center',\n            color: 'var(--text-secondary)'\n          }}>\n            <Empty description=\"Select a file from the tree to start editing\" />\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CodeEditor;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 28.0,
      "lines_of_code": 420,
      "number_of_classes": 0,
      "number_of_functions": 11
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "@monaco-editor/react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 5,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 6,
        "name": "../utils/errorHandler.jsx",
        "path": "crates\\cowork-gui\\src\\utils\\errorHandler.jsx",
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 8,
        "name": "react-window",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Functional Description\n\nThe CodeEditor.jsx is a sophisticated React component that provides a comprehensive code editing interface for a Tauri-based GUI application. It serves as the primary user interface for viewing, editing, and managing code files within a project iteration or session.\n\n### Core Functionality:\n\n**1. File Tree Visualization**\n- Displays a hierarchical tree structure of files and directories fetched from the backend\n- Supports expand/collapse functionality for folder navigation\n- Implements virtual scrolling using react-window for performance optimization with large file trees (50+ items)\n- Falls back to regular rendering for smaller trees\n- Visual indicators for folders (FolderOutlined) and files (FileOutlined) with depth-based indentation\n\n**2. Multi-Tab Code Editing**\n- Allows opening multiple files simultaneously in tabbed interface\n- Supports tab switching, closing, and automatic active file management\n- Integrates Monaco Editor (VS Code's editor engine) for syntax highlighting and advanced editing features\n- Auto-detects programming language based on file extension (supports Rust, JavaScript, TypeScript, Python, HTML, CSS, JSON, Markdown, TOML, YAML)\n- Configurable editor options including minimap, line numbers, whitespace rendering, and automatic layout\n\n**3. Backend Integration**\n- Communicates with Tauri backend using the `@tauri-apps/api/core` invoke function\n- Implements dual API support (V2 and legacy APIs) for backward compatibility\n- Operations include:\n  - `get_iteration_file_tree` / `get_file_tree` - Load file hierarchy\n  - `read_iteration_file` / `read_file_content` - Read file contents with partial loading support for large files\n  - `save_iteration_file` / `save_file_content` - Persist file changes\n  - `format_code` - Format code files\n\n**4. Code Formatting**\n- Supports formatting all open files or just the active file\n- Reloads file contents after formatting to display changes\n- Displays success/error feedback to users\n\n**5. Error Handling and User Feedback**\n- Integrated error handling using custom errorHandler utilities\n- Loading states with spinners during async operations\n- Error alerts with retry functionality\n- Success notifications for save and format operations\n\n### State Management:\nThe component manages seven state variables:\n- `fileTree`: Hierarchical structure of files and folders\n- `openFiles`: Array of currently open file paths\n- `activeFile`: Currently selected file for editing\n- `fileContents`: Object mapping file paths to their content\n- `loading`: Loading state indicator\n- `error`: Error message state\n- `formatting`: Formatting operation state\n\n### Performance Optimizations:\n- `useMemo` for flattening file tree structure\n- `useCallback` for event handlers to prevent unnecessary re-renders\n- Virtual scrolling for large file trees\n- Conditional rendering based on file tree size",
    "interfaces": [],
    "responsibilities": [
      "File tree visualization and navigation - Displays hierarchical file structure with expand/collapse functionality and virtual scrolling optimization",
      "Code editing and management - Provides Monaco Editor integration with multi-tab support, syntax highlighting, and language detection",
      "Backend integration - Handles Tauri API communication for file operations (read, write, format) with dual API version support",
      "User interface state management - Manages component state for open files, active file, loading, errors, and formatting operations",
      "Code formatting - Implements code formatting capabilities for individual files or all open files with automatic content refresh"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": "A command palette modal component that provides quick access to application features through searchable, keyboard-navigable command interface organized by categories including Project, File, View, Tools, and Settings.",
      "file_path": "crates\\cowork-gui\\src\\components\\CommandPalette.jsx",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "CommandPalette.jsx",
      "source_summary": "// Command Palette - Quick access to all features\nimport { useState, useEffect, useMemo } from 'react';\nimport { Modal, Input, List, Typography, Tag, Space } from 'antd';\nimport { SearchOutlined, ThunderboltOutlined, FolderOpenOutlined, FileTextOutlined, CodeOutlined, SettingOutlined } from '@ant-design/icons';\n\nconst { Text } = Typography;\n\nconst CommandPalette = ({ visible, onClose, onCommandSelect }) => {\n  const [searchText, setSearchText] = useState('');\n  const [selectedIndex, setSelectedIndex] = useState(0);\n\n  // Command definitions\n  const commands = useMemo(() => [\n    // Project commands\n    {\n      id: 'create-project',\n      label: 'Create New Project',\n      icon: <ThunderboltOutlined />,\n      category: 'Project',\n      shortcut: 'Ctrl+N',\n      action: () => onCommandSelect('create-project'),\n    },\n    {\n      id: 'open-project',\n      label: 'Open Project',\n      icon: <FolderOpenOutlined />,\n      category: 'Project',\n      shortcut: 'Ctrl+O',\n      action: () => onCommandSelect('open-project'),\n    },\n    {\n      id: 'recent-projects',\n      label: 'Recent Projects',\n      icon: <FolderOpenOutlined />,\n      category: 'Project',\n      shortcut: 'Ctrl+R',\n      action: () => onCommandSelect('recent-projects'),\n    },\n    // File commands\n    {\n      id: 'new-file',\n      label: 'New File',\n      icon: <FileTextOutlined />,\n      category: 'File',\n      shortcut: 'Ctrl+Shift+N',\n      action: () => onCommandSelect('new-file'),\n    },\n    {\n      id: 'save-file',\n      label: 'Save File',\n      icon: <FileTextOutlined />,\n      category: 'File',\n      shortcut: 'Ctrl+S',\n      action: () => onCommandSelect('save-file'),\n    },\n    {\n      id: 'format-code',\n      label: 'Format Code',\n      icon: <CodeOutlined />,\n      category: 'File',\n      shortcut: 'Ctrl+Shift+F',\n      action: () => onCommandSelect('format-code'),\n    },\n    // View commands\n    {\n      id: 'view-iterations',\n      label: 'View Iterations',\n      icon: <ThunderboltOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+0',\n      action: () => onCommandSelect('view-iterations'),\n    },\n    {\n      id: 'view-chat',\n      label: 'View Chat',\n      icon: <FileTextOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+1',\n      action: () => onCommandSelect('view-chat'),\n    },\n    {\n      id: 'view-artifacts',\n      label: 'View Artifacts',\n      icon: <FileTextOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+2',\n      action: () => onCommandSelect('view-artifacts'),\n    },\n    {\n      id: 'view-code',\n      label: 'View Code',\n      icon: <CodeOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+3',\n      action: () => onCommandSelect('view-code'),\n    },\n    {\n      id: 'view-preview',\n      label: 'View Preview',\n      icon: <FileTextOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+4',\n      action: () => onCommandSelect('view-preview'),\n    },\n    {\n      id: 'view-run',\n      label: 'View Run',\n      icon: <ThunderboltOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+5',\n      action: () => onCommandSelect('view-run'),\n    },\n    {\n      id: 'view-memory',\n      label: 'View Memory',\n      icon: <FileTextOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+6',\n      action: () => onCommandSelect('view-memory'),\n    },\n    {\n      id: 'view-projects',\n      label: 'View Projects',\n      icon: <FolderOpenOutlined />,\n      category: 'View',\n      shortcut: 'Ctrl+7',\n      action: () => onCommandSelect('view-projects'),\n    },\n    // Tools commands\n    {\n      id: 'format-all',\n      label: 'Format All Files',\n      icon: <CodeOutlined />,\n      category: 'Tools',\n      shortcut: '',\n      action: () => onCommandSelect('format-all'),\n    },\n    {\n      id: 'check-formatter',\n      label: 'Check Formatter Availability',\n      icon: <CodeOutlined />,\n      category: 'Tools',\n      shortcut: '',\n      action: () => onCommandSelect('check-formatter'),\n    },\n    {\n      id: 'get-templates',\n      label: 'Get Templates',\n      icon: <FolderOpenOutlined />,\n      category: 'Tools',\n      shortcut: '',\n      action: () => onCommandSelect('get-templates'),\n    },\n    // Settings commands\n    {\n      id: 'settings',\n      label: 'Settings',\n      icon: <SettingOutlined />,\n      category: 'Settings',\n      shortcut: 'Ctrl+,',\n      action: () => onCommandSelect('settings'),\n    },\n    {\n      id: 'preferences',\n      label: 'Preferences',\n      icon: <SettingOutlined />,\n      category: 'Settings',\n      shortcut: '',\n      action: () => onCommandSelect('preferences'),\n    },\n  ], [onCommandSelect]);\n\n  // Filter commands based on search text\n  const filteredCommands = useMemo(() => {\n    if (!searchText) {\n      return commands;\n    }\n    \n    const searchLower = searchText.toLowerCase();\n    return commands.filter(cmd => \n      cmd.label.toLowerCase().includes(searchLower) ||\n      cmd.category.toLowerCase().includes(searchLower)\n    );\n  }, [commands, searchText]);\n\n  // Group commands by category\n  const groupedCommands = useMemo(() => {\n    const groups = {};\n    filteredCommands.forEach(cmd => {\n      if (!groups[cmd.category]) {\n        groups[cmd.category] = [];\n      }\n      groups[cmd.category].push(cmd);\n    });\n    return groups;\n  }, [filteredCommands]);\n\n  // Handle keyboard navigation\n  useEffect(() => {\n    const handleKeyDown = (e) => {\n      if (!visible) return;\n      \n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          setSelectedIndex(prev => \n            Math.min(prev + 1, filteredCommands.length - 1)\n          );\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          setSelectedIndex(prev => Math.max(prev - 1, 0));\n          break;\n        case 'Enter':\n          e.preventDefault();\n          if (filteredCommands[selectedIndex]) {\n            filteredCommands[selectedIndex].action();\n            handleClose();\n          }\n          break;\n        case 'Escape':\n          e.preventDefault();\n          handleClose();\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [visible, filteredCommands, selectedIndex]);\n\n  // Reset search and selection when modal opens\n  useEffect(() => {\n    if (visible) {\n      setSearchText('');\n      setSelectedIndex(0);\n    }\n  }, [visible]);\n\n  const handleClose = () => {\n    onClose();\n  };\n\n  const handleSearchChange = (e) => {\n    setSearchText(e.target.value);\n    setSelectedIndex(0);\n  };\n\n  const flattenedCommands = useMemo(() => {\n    return Object.values(groupedCommands).flat();\n  }, [groupedCommands]);\n\n  return (\n    <Modal\n      title=\"Command Palette\"\n      open={visible}\n      onCancel={handleClose}\n      footer={null}\n      width={600}\n      centered\n    >\n      <Input\n        placeholder=\"Search commands...\"\n        prefix={<SearchOutlined />}\n        value={searchText}\n        onChange={handleSearchChange}\n        autoFocus\n        style={{ marginBottom: 16 }}\n        size=\"large\"\n      />\n      \n      <List\n        style={{ maxHeight: 400, overflow: 'auto' }}\n        dataSource={flattenedCommands}\n        renderItem={(item, index) => (\n          <List.Item\n            key={item.id}\n            onClick={() => {\n              item.action();\n              handleClose();\n            }}\n            style={{\n              cursor: 'pointer',\n              padding: '12px',\n              backgroundColor: index === selectedIndex ? '#1890ff22' : 'transparent',\n              borderRadius: '4px',\n            }}\n          >\n            <List.Item.Meta\n              avatar={item.icon}\n              title={\n                <Space>\n                  <Text>{item.label}</Text>\n                  <Tag color=\"blue\">{item.category}</Tag>\n                </Space>\n              }\n              description={item.shortcut && (\n                <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                  {item.shortcut}\n                </Text>\n              )}\n            />\n          </List.Item>\n        )}\n      />\n    </Modal>\n  );\n};\n\nexport default CommandPalette;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 11.0,
      "lines_of_code": 310,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The CommandPalette is a sophisticated UI widget that implements a command palette interface similar to those found in modern IDEs and productivity tools (like VS Code's Command Palette, Spotlight, or Alfred). The component provides a centralized, searchable interface for accessing various application features through keyboard shortcuts and mouse interactions.\n\n**Functional Architecture:**\n\nThe component operates as a modal dialog that presents a comprehensive set of commands organized into logical categories:\n- **Project Commands**: Create new project, open project, view recent projects (Ctrl+N, Ctrl+O, Ctrl+R)\n- **File Commands**: New file, save file, format code (Ctrl+Shift+N, Ctrl+S, Ctrl+Shift+F)\n- **View Commands**: Switch between different application views - iterations, chat, artifacts, code, preview, run, memory, and projects (Ctrl+0 through Ctrl+7)\n- **Tools Commands**: Format all files, check formatter availability, get templates\n- **Settings Commands**: Access settings and preferences (Ctrl+,)\n\n**Key Features:**\n\n1. **Real-time Search Filtering**: Users can type in the search input to filter commands. The search matches against both command labels and categories using case-insensitive substring matching.\n\n2. **Keyboard Navigation**: Full keyboard support with ArrowUp/ArrowDown for navigation, Enter to execute the selected command, and Escape to close the palette. The selected item is visually highlighted.\n\n3. **Categorized Display**: Commands are grouped by category (Project, File, View, Tools, Settings) and rendered with appropriate icons and category tags for better visual organization.\n\n4. **Smart State Management**: The component uses React hooks for efficient state management. useMemo is employed to optimize command filtering and grouping operations, preventing unnecessary recalculations.\n\n5. **Event-driven Architecture**: Commands are executed via a callback pattern (onCommandSelect), delegating actual command implementation to parent components while maintaining a clean separation of concerns.\n\n**Technical Implementation:**\n\nThe component leverages Ant Design's Modal, Input, List, and Typography components for consistent UI styling. It maintains local state for searchText and selectedIndex, which are reset when the modal opens. Keyboard event listeners are dynamically attached and detached based on modal visibility to prevent global keyboard interference.",
    "interfaces": [],
    "responsibilities": [
      "Command registry and management - defining, organizing, and maintaining a comprehensive catalog of application commands with metadata (id, label, icon, category, shortcut, action)",
      "Search and filtering functionality - providing real-time, case-insensitive search across command labels and categories to help users quickly locate desired actions",
      "Keyboard navigation and accessibility - implementing intuitive keyboard shortcuts (Arrow keys, Enter, Escape) and managing focus for efficient command selection",
      "UI presentation and visual feedback - rendering the command palette modal with categorized command groups, highlighting selected items, and displaying keyboard shortcuts",
      "Command execution orchestration - acting as an intermediary that captures user selections and delegates execution to parent components through callback mechanisms"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": null,
      "file_path": "crates\\cowork-gui\\src\\components\\IterationsPanel.jsx",
      "functions": [
        "loadData",
        "handleCreateIteration",
        "handleExecuteIteration",
        "handleContinueIteration",
        "handleDeleteIteration",
        "handleViewDetails",
        "resetForm",
        "handleInitProject",
        "getStatusColor",
        "getStatusIcon",
        "calculateProgress",
        "formatDate"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "IterationsPanel.jsx",
      "source_summary": "import { useState, useEffect } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport { listen } from '@tauri-apps/api/event';\nimport {\n  Card,\n  Button,\n  Modal,\n  Input,\n  Tag,\n  Empty,\n  message,\n  Spin,\n  Space,\n  Tooltip,\n  Progress,\n  Badge,\n  Timeline,\n  Radio,\n  Form,\n  Select,\n} from 'antd';\nimport {\n  PlusOutlined,\n  PlayCircleOutlined,\n  PauseCircleOutlined,\n  CheckCircleOutlined,\n  CloseCircleOutlined,\n  DeleteOutlined,\n  ReloadOutlined,\n  BranchesOutlined,\n  RocketOutlined,\n  CodeOutlined,\n  FileTextOutlined,\n  EyeOutlined,\n} from '@ant-design/icons';\n\nconst { TextArea } = Input;\nconst { Option } = Select;\n\n// Stage definitions\nconst STAGES = [\n  { key: 'idea', label: 'Idea', icon: <RocketOutlined />, color: '#1890ff' },\n  { key: 'prd', label: 'PRD', icon: <FileTextOutlined />, color: '#52c41a' },\n  { key: 'design', label: 'Design', icon: <EyeOutlined />, color: '#722ed1' },\n  { key: 'plan', label: 'Plan', icon: <FileTextOutlined />, color: '#fa8c16' },\n  { key: 'coding', label: 'Coding', icon: <CodeOutlined />, color: '#13c2c2' },\n  { key: 'check', label: 'Check', icon: <CheckCircleOutlined />, color: '#eb2f96' },\n  { key: 'delivery', label: 'Delivery', icon: <RocketOutlined />, color: '#52c41a' },\n];\n\nconst IterationsPanel = ({ onSelectIteration, selectedIterationId, onExecuteStatusChange }) => {\n  const [iterations, setIterations] = useState([]);\n  const [project, setProject] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [showCreateModal, setShowCreateModal] = useState(false);\n  const [showDetailsModal, setShowDetailsModal] = useState(false);\n  const [showInitProjectModal, setShowInitProjectModal] = useState(false);\n  const [selectedIteration, setSelectedIteration] = useState(null);\n  const [executingId, setExecutingId] = useState(null);\n  const [newProjectName, setNewProjectName] = useState('');\n\n  // Form state\n  const [newIterationTitle, setNewIterationTitle] = useState('');\n  const [newIterationDescription, setNewIterationDescription] = useState('');\n  const [newIterationBase, setNewIterationBase] = useState(null);\n  const [newIterationInheritance, setNewIterationInheritance] = useState('full');\n\n  const loadData = async () => {\n    setLoading(true);\n    try {\n      // Load project\n      const projectData = await invoke('gui_get_project');\n      setProject(projectData);\n\n      // Load iterations\n      const iterationsData = await invoke('gui_get_iterations');\n      setIterations(iterationsData || []);\n    } catch (error) {\n      console.error('[IterationsPanel] Failed to load data:', error);\n      message.error('Failed to load data: ' + error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadData();\n\n    // Listen for events\n    const unlistenCreated = listen('iteration_created', () => loadData());\n    const unlistenCompleted = listen('iteration_completed', () => {\n      loadData();\n      setExecutingId(null);\n    });\n    const unlistenFailed = listen('iteration_failed', () => {\n      loadData();\n      setExecutingId(null);\n    });\n\n    return () => {\n      unlistenCreated.then(fn => fn()).catch(() => {});\n      unlistenCompleted.then(fn => fn()).catch(() => {});\n      unlistenFailed.then(fn => fn()).catch(() => {});\n    };\n  }, []);\n\n  const handleCreateIteration = async () => {\n    if (!newIterationTitle.trim()) {\n      message.warning('Please enter a title');\n      return;\n    }\n\n    try {\n      const request = {\n        title: newIterationTitle,\n        description: newIterationDescription || newIterationTitle,\n        base_iteration_id: newIterationBase,\n        inheritance: newIterationInheritance,\n      };\n\n      await invoke('gui_create_iteration', { request });\n      message.success('Iteration created successfully');\n      setShowCreateModal(false);\n      resetForm();\n      loadData();\n    } catch (error) {\n      message.error('Failed to create iteration: ' + error);\n    }\n  };\n\n  const handleExecuteIteration = async (iterationId) => {\n    try {\n      setExecutingId(iterationId);\n      // Notify parent about execution status change\n      onExecuteStatusChange?.(iterationId, 'running');\n      await invoke('gui_execute_iteration', { iterationId });\n      message.info('Iteration execution started');\n    } catch (error) {\n      message.error('Failed to execute iteration: ' + error);\n      setExecutingId(null);\n      onExecuteStatusChange?.(iterationId, 'error');\n    }\n  };\n\n  const handleContinueIteration = async (iterationId) => {\n    try {\n      setExecutingId(iterationId);\n      // Notify parent about execution status change\n      onExecuteStatusChange?.(iterationId, 'running');\n      // Auto-select the iteration being continued\n      onSelectIteration?.(iterationId);\n      await invoke('gui_continue_iteration', { iterationId });\n      message.info('Iteration continued');\n    } catch (error) {\n      message.error('Failed to continue iteration: ' + error);\n      setExecutingId(null);\n      onExecuteStatusChange?.(iterationId, 'error');\n    }\n  };\n\n  const handleDeleteIteration = (iteration) => {\n    Modal.confirm({\n      title: 'Delete Iteration',\n      content: `Are you sure you want to delete \"${iteration.title}\"?`,\n      okText: 'Delete',\n      okType: 'danger',\n      onOk: async () => {\n        try {\n          await invoke('gui_delete_iteration', { iterationId: iteration.id });\n          message.success('Iteration deleted');\n          loadData();\n        } catch (error) {\n          message.error('Failed to delete iteration: ' + error);\n        }\n      },\n    });\n  };\n\n  const handleViewDetails = (iteration) => {\n    setSelectedIteration(iteration);\n    setShowDetailsModal(true);\n  };\n\n  const resetForm = () => {\n    setNewIterationTitle('');\n    setNewIterationDescription('');\n    setNewIterationBase(null);\n    setNewIterationInheritance('full');\n  };\n\n  const handleInitProject = async () => {\n    if (!newProjectName.trim()) {\n      message.warning('Please enter a project name');\n      return;\n    }\n\n    try {\n      await invoke('gui_init_project', { name: newProjectName });\n      message.success('Project initialized successfully');\n      setShowInitProjectModal(false);\n      setNewProjectName('');\n      loadData();\n    } catch (error) {\n      message.error('Failed to initialize project: ' + error);\n    }\n  };\n\n  const getStatusColor = (status) => {\n    switch (status?.toLowerCase()) {\n      case 'completed': return 'success';\n      case 'running': return 'processing';\n      case 'paused': return 'warning';\n      case 'failed': return 'error';\n      case 'draft': return 'default';\n      default: return 'default';\n    }\n  };\n\n  const getStatusIcon = (status) => {\n    switch (status?.toLowerCase()) {\n      case 'completed': return <CheckCircleOutlined style={{ color: '#52c41a' }} />;\n      case 'running': return <PlayCircleOutlined style={{ color: '#1890ff' }} />;\n      case 'paused': return <PauseCircleOutlined style={{ color: '#faad14' }} />;\n      case 'failed': return <CloseCircleOutlined style={{ color: '#ff4d4f' }} />;\n      default: return null;\n    }\n  };\n\n  const calculateProgress = (completedStages) => {\n    if (!completedStages) return 0;\n    return Math.round((completedStages.length / STAGES.length) * 100);\n  };\n\n  const formatDate = (dateString) => {\n    if (!dateString) return 'N/A';\n    return new Date(dateString).toLocaleString();\n  };\n\n  if (loading && iterations.length === 0) {\n    return (\n      <div style={{ padding: '40px', textAlign: 'center' }}>\n        <Spin size=\"large\" />\n        <div style={{ marginTop: '16px', color: '#999' }}>Loading iterations...</div>\n      </div>\n    );\n  }\n\n  if (!project) {\n    return (\n      <div style={{ padding: '40px' }}>\n        <Empty\n          description=\"No project initialized\"\n          image={Empty.PRESENTED_IMAGE_SIMPLE}\n        >\n          <Button type=\"primary\" onClick={() => setShowInitProjectModal(true)}>\n            Initialize Project\n          </Button>\n        </Empty>\n\n        {/* Initialize Project Modal */}\n        <Modal\n          title=\"Initialize Project\"\n          open={showInitProjectModal}\n          onOk={handleInitProject}\n          onCancel={() => {\n            setShowInitProjectModal(false);\n            setNewProjectName('');\n          }}\n          okText=\"Initialize\"\n          cancelText=\"Cancel\"\n        >\n          <div style={{ marginBottom: '16px' }}>\n            <label style={{ display: 'block', marginBottom: '8px', fontWeight: 'bold' }}>\n              Project Name:\n            </label>\n            <Input\n              value={newProjectName}\n              onChange={(e) => setNewProjectName(e.target.value)}\n              placeholder=\"Enter project name\"\n              autoFocus\n              onPressEnter={handleInitProject}\n            />\n          </div>\n        </Modal>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{ padding: '24px', height: '100%', overflow: 'auto' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <div>\n          <h2 style={{ margin: 0 }}>{project.name}</h2>\n          <div style={{ color: '#888', fontSize: '14px', marginTop: '4px' }}>\n            {iterations.length} iteration{iterations.length !== 1 ? 's' : ''}\n          </div>\n        </div>\n        <Button\n          type=\"primary\"\n          icon={<PlusOutlined />}\n          onClick={() => setShowCreateModal(true)}\n        >\n          New Iteration\n        </Button>\n      </div>\n\n      {/* Iterations List */}\n      {iterations.length === 0 ? (\n        <Empty\n          description=\"No iterations yet\"\n          image={Empty.PRESENTED_IMAGE_SIMPLE}\n        >\n          <Button type=\"primary\" onClick={() => setShowCreateModal(true)}>\n            Create First Iteration\n          </Button>\n        </Empty>\n      ) : (\n        <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>\n          {iterations.map((iteration) => (\n            <Card\n              key={iteration.id}\n              hoverable\n              className={selectedIterationId === iteration.id ? 'selected-iteration' : ''}\n              style={{\n                border: selectedIterationId === iteration.id ? '2px solid #1890ff' : undefined,\n              }}\n              onClick={() => onSelectIteration?.(iteration.id)}\n              actions={[\n                iteration.status === 'Draft' && (\n                  <Button\n                    type=\"link\"\n                    icon={<PlayCircleOutlined />}\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleExecuteIteration(iteration.id);\n                    }}\n                  >\n                    Start\n                  </Button>\n                ),\n                iteration.status === 'Paused' && (\n                  <Button\n                    type=\"link\"\n                    icon={<ReloadOutlined />}\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleContinueIteration(iteration.id);\n                    }}\n                  >\n                    Continue\n                  </Button>\n                ),\n                iteration.status === 'Running' && (\n                  <Spin size=\"small\" style={{ marginRight: '8px' }} />\n                ),\n                <Button\n                  type=\"link\"\n                  icon={<EyeOutlined />}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    handleViewDetails(iteration);\n                  }}\n                >\n                  Details\n                </Button>,\n                iteration.status !== 'Running' && (\n                  <Button\n                    type=\"link\"\n                    danger\n                    icon={<DeleteOutlined />}\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleDeleteIteration(iteration);\n                    }}\n                  >\n                    Delete\n                  </Button>\n                ),\n              ].filter(Boolean)}\n            >\n              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>\n                <div style={{ flex: 1 }}>\n                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>\n                    <span style={{ fontSize: '18px', fontWeight: 'bold' }}>\n                      #{iteration.number}\n                    </span>\n                    <span style={{ fontSize: '16px' }}>{iteration.title}</span>\n                    <Badge\n                      status={getStatusColor(iteration.status)}\n                      text={\n                        <span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>\n                          {getStatusIcon(iteration.status)}\n                          {iteration.status}\n                        </span>\n                      }\n                    />\n                  </div>\n\n                  <div style={{ color: '#666', marginBottom: '12px' }}>\n                    {iteration.description}\n                  </div>\n\n                  {iteration.base_iteration_id && (\n                    <div style={{ fontSize: '12px', color: '#888', marginBottom: '8px' }}>\n                      <BranchesOutlined style={{ marginRight: '4px' }} />\n                      Based on iteration: {iteration.base_iteration_id.substring(0, 12)}...\n                      <Tag size=\"small\" style={{ marginLeft: '8px' }}>\n                        {iteration.inheritance}\n                      </Tag>\n                    </div>\n                  )}\n\n                  {/* Progress */}\n                  <div style={{ marginTop: '12px' }}>\n                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>\n                      <span style={{ fontSize: '12px', color: '#888' }}>Progress</span>\n                      <span style={{ fontSize: '12px', color: '#888' }}>\n                        {calculateProgress(iteration.completed_stages)}%\n                      </span>\n                    </div>\n                    <Progress\n                      percent={calculateProgress(iteration.completed_stages)}\n                      size=\"small\"\n                      status={iteration.status === 'Failed' ? 'exception' : 'active'}\n                    />\n                  </div>\n\n                  {/* Current Stage */}\n                  {iteration.current_stage && (\n                    <div style={{ marginTop: '8px', fontSize: '12px', color: '#1890ff' }}>\n                      Current: {iteration.current_stage}\n                    </div>\n                  )}\n\n                  {/* Stages */}\n                  <div style={{ marginTop: '12px', display: 'flex', flexWrap: 'wrap', gap: '4px' }}>\n                    {STAGES.map((stage) => {\n                      const isCompleted = iteration.completed_stages?.includes(stage.key);\n                      const isCurrent = iteration.current_stage === stage.key;\n\n                      return (\n                        <Tag\n                          key={stage.key}\n                          size=\"small\"\n                          color={isCompleted ? 'success' : isCurrent ? 'processing' : 'default'}\n                          style={{\n                            opacity: isCompleted || isCurrent ? 1 : 0.5,\n                          }}\n                        >\n                          {isCompleted && <CheckCircleOutlined style={{ marginRight: '4px' }} />}\n                          {stage.label}\n                        </Tag>\n                      );\n                    })}\n                  </div>\n                </div>\n\n                <div style={{ textAlign: 'right', color: '#888', fontSize: '12px' }}>\n                  <div>Created</div>\n                  <div>{formatDate(iteration.created_at)}</div>\n                </div>\n              </div>\n            </Card>\n          ))}\n        </div>\n      )}\n\n      {/* Create Iteration Modal */}\n      <Modal\n        title=\"Create New Iteration\"\n        open={showCreateModal}\n        onOk={handleCreateIteration}\n        onCancel={() => {\n          setShowCreateModal(false);\n          resetForm();\n        }}\n        width={600}\n      >\n        <Form layout=\"vertical\">\n          <Form.Item label=\"Title\" required>\n            <Input\n              value={newIterationTitle}\n              onChange={(e) => setNewIterationTitle(e.target.value)}\n              placeholder=\"e.g., Add user authentication\"\n              autoFocus\n            />\n          </Form.Item>\n\n          <Form.Item label=\"Description\">\n            <TextArea\n              value={newIterationDescription}\n              onChange={(e) => setNewIterationDescription(e.target.value)}\n              placeholder=\"Describe what you want to achieve in this iteration...\"\n              rows={4}\n            />\n          </Form.Item>\n\n          {iterations.length > 0 && (\n            <>\n              <Form.Item label=\"Base Iteration (Optional)\">\n                <Select\n                  value={newIterationBase}\n                  onChange={setNewIterationBase}\n                  placeholder=\"Select a base iteration to inherit from\"\n                  allowClear\n                >\n                  {iterations\n                    .filter((i) => i.status === 'Completed')\n                    .map((iteration) => (\n                      <Option key={iteration.id} value={iteration.id}>\n                        #{iteration.number} - {iteration.title}\n                      </Option>\n                    ))}\n                </Select>\n                <div style={{ marginTop: '4px', fontSize: '12px', color: '#888' }}>\n                  Leave empty to start from scratch (Genesis iteration)\n                </div>\n              </Form.Item>\n\n              {newIterationBase && (\n                <Form.Item label=\"Inheritance Mode\">\n                  <Radio.Group\n                    value={newIterationInheritance}\n                    onChange={(e) => setNewIterationInheritance(e.target.value)}\n                  >\n                    <Radio.Button value=\"full\">Full (All code)</Radio.Button>\n                    <Radio.Button value=\"partial\">Partial (Artifacts only)</Radio.Button>\n                    <Radio.Button value=\"none\">None (Fresh start)</Radio.Button>\n                  </Radio.Group>\n                </Form.Item>\n              )}\n            </>\n          )}\n        </Form>\n      </Modal>\n\n      {/* Iteration Details Modal */}\n      <Modal\n        title=\"Iteration Details\"\n        open={showDetailsModal}\n        onCancel={() => setShowDetailsModal(false)}\n        footer={null}\n        width={700}\n      >\n        {selectedIteration && (\n          <div>\n            <div style={{ marginBottom: '24px' }}>\n              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>\n                <span style={{ fontSize: '24px', fontWeight: 'bold' }}>\n                  #{selectedIteration.number}\n                </span>\n                <span style={{ fontSize: '18px' }}>{selectedIteration.title}</span>\n              </div>\n              <Badge\n                status={getStatusColor(selectedIteration.status)}\n                text={selectedIteration.status}\n                style={{ marginRight: '16px' }}\n              />\n              <span style={{ color: '#888', fontSize: '12px' }}>\n                ID: {selectedIteration.id}\n              </span>\n            </div>\n\n            <div style={{ marginBottom: '24px' }}>\n              <h4>Description</h4>\n              <div style={{ padding: '12px', background: '#f5f5f5', borderRadius: '4px' }}>\n                {selectedIteration.description}\n              </div>\n            </div>\n\n            {selectedIteration.base_iteration_id && (\n              <div style={{ marginBottom: '24px' }}>\n                <h4>Inheritance</h4>\n                <div>\n                  Based on: <code>{selectedIteration.base_iteration_id}</code>\n                  <Tag style={{ marginLeft: '8px' }}>{selectedIteration.inheritance}</Tag>\n                </div>\n              </div>\n            )}\n\n            <div style={{ marginBottom: '24px' }}>\n              <h4>Stages</h4>\n              <Timeline\n                items={STAGES.map((stage) => {\n                  const isCompleted = selectedIteration.completed_stages?.includes(stage.key);\n                  const isCurrent = selectedIteration.current_stage === stage.key;\n\n                  return {\n                    color: isCompleted ? 'green' : isCurrent ? 'blue' : 'gray',\n                    dot: isCompleted ? <CheckCircleOutlined /> : isCurrent ? <PlayCircleOutlined /> : null,\n                    children: (\n                      <div>\n                        <strong>{stage.label}</strong>\n                        {isCurrent && <Tag color=\"blue\" style={{ marginLeft: '8px' }}>Current</Tag>}\n                      </div>\n                    ),\n                  };\n                })}\n              />\n            </div>\n\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }}>\n              <div>\n                <h4>Created</h4>\n                <div>{formatDate(selectedIteration.created_at)}</div>\n              </div>\n              {selectedIteration.completed_at && (\n                <div>\n                  <h4>Completed</h4>\n                  <div>{formatDate(selectedIteration.completed_at)}</div>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </Modal>\n    </div>\n  );\n};\n\nexport default IterationsPanel;\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 19.0,
      "lines_of_code": 622,
      "number_of_classes": 0,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "@tauri-apps/api/event",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "antd",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "IterationsPanel.jsx is a frontend UI component that manages and displays project iterations in a visual timeline format. It provides functionality to create, view, execute, continue, pause, and delete iterations. The component interacts with a backend via Tauri RPC calls (gui_get_project, gui_get_iterations, gui_create_iteration, gui_execute_iteration, gui_continue_iteration, gui_delete_iteration, gui_init_project). It maintains state for iterations, project metadata, and user interactions through modals. The UI includes a list of iteration cards with progress indicators, stage tracking, status badges, and detailed views. It supports inheritance between iterations and tracks completion of 8 predefined stages (Idea, PRD, Design, Plan, Coding, Check, Delivery). Event listeners respond to iteration_created, iteration_completed, and iteration_failed events to auto-refresh data.",
    "interfaces": [],
    "responsibilities": [
      "Manage iteration lifecycle (create, execute, continue, delete)",
      "Display iterations with visual progress tracking and stage completion indicators",
      "Handle user interactions through modals and form inputs",
      "Integrate with backend via Tauri RPC calls for data persistence and execution",
      "Respond to real-time events (iteration_created, completed, failed) to maintain UI consistency"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": null,
      "file_path": "crates\\cowork-gui\\src\\components\\MemoryPanel.jsx",
      "functions": [
        "loadMemories",
        "handleSearch",
        "handleViewDetail",
        "getCategoryColor",
        "getImpactColor",
        "formatDate"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "MemoryPanel.jsx",
      "source_summary": "import { useState, useEffect } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport { Card, Input, Select, Button, Tag, Empty, Spin, Modal, Tabs, Typography, Space, Divider } from 'antd';\nimport { SearchOutlined, EyeOutlined, DatabaseOutlined, ClockCircleOutlined } from '@ant-design/icons';\n\nconst { TextArea } = Input;\nconst { Option } = Select;\nconst { Text, Paragraph } = Typography;\n\nfunction MemoryPanel({ currentSession }) {\n  const [memories, setMemories] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [queryType, setQueryType] = useState('all');\n  const [category, setCategory] = useState('all');\n  const [stage, setStage] = useState('');\n  const [limit, setLimit] = useState(20);\n  const [selectedMemory, setSelectedMemory] = useState(null);\n  const [memoryDetail, setMemoryDetail] = useState(null);\n  const [detailLoading, setDetailLoading] = useState(false);\n  const [total, setTotal] = useState(0);\n\n  useEffect(() => {\n    loadMemories();\n  }, [queryType, category, stage, limit, currentSession]);\n\n  const loadMemories = async () => {\n    setLoading(true);\n    try {\n      const params = {\n        queryType: queryType,\n        category: category,\n        stage: stage || null,\n        limit: limit\n      };\n      \n      const result = await invoke('query_memory_index', params);\n      setMemories(result.results || []);\n      setTotal(result.total || 0);\n    } catch (error) {\n      console.error('[MemoryPanel] Failed to load memories:', error);\n      setMemories([]);\n      setTotal(0);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleSearch = () => {\n    loadMemories();\n  };\n\n  const handleViewDetail = async (memory) => {\n    setSelectedMemory(memory);\n    setDetailLoading(true);\n    try {\n      const detail = await invoke('load_memory_detail', {\n        memoryId: memory.id,\n        file: memory.file\n      });\n      setMemoryDetail(detail);\n    } catch (error) {\n      console.error('[MemoryPanel] Failed to load memory detail:', error);\n      setMemoryDetail(null);\n    } finally {\n      setDetailLoading(false);\n    }\n  };\n\n  const getCategoryColor = (cat) => {\n    switch (cat) {\n      case 'decision': return 'blue';\n      case 'experience': return 'green';\n      case 'pattern': return 'purple';\n      case 'record': return 'orange';\n      default: return 'default';\n    }\n  };\n\n  const getImpactColor = (impact) => {\n    switch (impact) {\n      case 'high': return 'red';\n      case 'medium': return 'orange';\n      case 'low': return 'green';\n      default: return 'default';\n    }\n  };\n\n  const formatDate = (dateStr) => {\n    if (!dateStr) return 'N/A';\n    try {\n      const date = new Date(dateStr);\n      return date.toLocaleString();\n    } catch {\n      return dateStr;\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', height: '100%', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>\n      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '20px', flexShrink: 0 }}>\n        <h2 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '10px' }}>\n          <DatabaseOutlined />\n          Memory Browser\n        </h2>\n        <Space>\n          <Text type=\"secondary\">Total: {total}</Text>\n          <Button icon={<SearchOutlined />} onClick={handleSearch} loading={loading}>\n            Refresh\n          </Button>\n        </Space>\n      </div>\n\n      <Card size=\"small\" style={{ marginBottom: '20px', flexShrink: 0 }}>\n        <Space direction=\"vertical\" style={{ width: '100%' }} size=\"small\">\n          <div style={{ display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap' }}>\n            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', minWidth: '150px' }}>\n              <Text strong>Query Type:</Text>\n              <Select\n                value={queryType}\n                onChange={setQueryType}\n                style={{ flex: 1, minWidth: '120px' }}\n                size=\"small\"\n              >\n                <Option value=\"all\">All</Option>\n                <Option value=\"project\">Project</Option>\n                <Option value=\"session\">Session</Option>\n              </Select>\n            </div>\n\n            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', minWidth: '150px' }}>\n              <Text strong>Category:</Text>\n              <Select\n                value={category}\n                onChange={setCategory}\n                style={{ flex: 1, minWidth: '120px' }}\n                size=\"small\"\n              >\n                <Option value=\"all\">All</Option>\n                <Option value=\"decision\">Decisions</Option>\n                <Option value=\"experience\">Experiences</Option>\n                <Option value=\"pattern\">Patterns</Option>\n                <Option value=\"record\">Records</Option>\n              </Select>\n            </div>\n\n            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', minWidth: '150px' }}>\n              <Text strong>Stage:</Text>\n              <Select\n                value={stage}\n                onChange={setStage}\n                style={{ flex: 1, minWidth: '120px' }}\n                size=\"small\"\n                allowClear\n                placeholder=\"All\"\n              >\n                <Option value=\"idea\">Idea</Option>\n                <Option value=\"prd\">PRD</Option>\n                <Option value=\"design\">Design</Option>\n                <Option value=\"plan\">Plan</Option>\n                <Option value=\"coding\">Coding</Option>\n                <Option value=\"check\">Check</Option>\n              </Select>\n            </div>\n\n            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', minWidth: '100px' }}>\n              <Text strong>Limit:</Text>\n              <Select\n                value={limit}\n                onChange={setLimit}\n                style={{ flex: 1, minWidth: '80px' }}\n                size=\"small\"\n              >\n                <Option value={10}>10</Option>\n                <Option value={20}>20</Option>\n                <Option value={50}>50</Option>\n                <Option value={100}>100</Option>\n              </Select>\n            </div>\n          </div>\n        </Space>\n      </Card>\n\n      <div style={{ flex: 1, overflow: 'auto', display: 'flex', flexDirection: 'column' }}>\n        {loading ? (\n          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%' }}>\n            <Spin size=\"large\" />\n          </div>\n        ) : memories.length === 0 ? (\n          <Empty \n            description=\"No memories found\" \n            style={{ marginTop: '50px' }}\n          />\n        ) : (\n          <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n            {memories.map((memory) => (\n              <Card\n                key={memory.id}\n                size=\"small\"\n                hoverable\n                style={{ cursor: 'pointer' }}\n                onClick={() => handleViewDetail(memory)}\n              >\n                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }}>\n                  <div style={{ flex: 1 }}>\n                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>\n                      <Text strong>{memory.title}</Text>\n                      <Tag color={getCategoryColor(memory.category)}>{memory.category}</Tag>\n                      {memory.stage && <Tag>{memory.stage}</Tag>}\n                    </div>\n                    <Paragraph \n                      ellipsis={{ rows: 2 }} \n                      style={{ margin: 0, fontSize: '13px', color: '#888' }}\n                    >\n                      {memory.summary}\n                    </Paragraph>\n                  </div>\n                  <Button\n                    type=\"text\"\n                    icon={<EyeOutlined />}\n                    size=\"small\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleViewDetail(memory);\n                    }}\n                  />\n                </div>\n                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', fontSize: '12px', color: '#666' }}>\n                  <Space size=\"small\">\n                    <span><ClockCircleOutlined /> {formatDate(memory.created_at)}</span>\n                    {memory.impact && <Tag color={getImpactColor(memory.impact)} size=\"small\">{memory.impact}</Tag>}\n                  </Space>\n                  <Space size=\"small\">\n                    {memory.tags && memory.tags.slice(0, 2).map((tag, idx) => (\n                      <Tag key={idx} style={{ fontSize: '11px' }}>{tag}</Tag>\n                    ))}\n                  </Space>\n                </div>\n              </Card>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <Modal\n        title={selectedMemory?.title}\n        open={!!selectedMemory}\n        onCancel={() => {\n          setSelectedMemory(null);\n          setMemoryDetail(null);\n        }}\n        footer={[\n          <Button key=\"close\" onClick={() => {\n            setSelectedMemory(null);\n            setMemoryDetail(null);\n          }}>\n            Close\n          </Button>\n        ]}\n        width={800}\n        style={{ top: 20 }}\n      >\n        {detailLoading ? (\n          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '200px' }}>\n            <Spin size=\"large\" />\n          </div>\n        ) : (\n          <Tabs defaultActiveKey=\"content\">\n            <Tabs.TabPane tab=\"Content\" key=\"content\">\n              {memoryDetail ? (\n                <div>\n                  <div style={{ marginBottom: '16px', padding: '12px', background: '#f5f5f5', borderRadius: '4px' }}>\n                    <Space direction=\"vertical\" style={{ width: '100%' }} size=\"small\">\n                      <div>\n                        <Text strong>ID: </Text>\n                        <Text code>{selectedMemory.id}</Text>\n                      </div>\n                      <div>\n                        <Text strong>Category: </Text>\n                        <Tag color={getCategoryColor(selectedMemory.category)}>{selectedMemory.category}</Tag>\n                      </div>\n                      {selectedMemory.stage && (\n                        <div>\n                          <Text strong>Stage: </Text>\n                          <Tag>{selectedMemory.stage}</Tag>\n                        </div>\n                      )}\n                      <div>\n                        <Text strong>Created: </Text>\n                        <Text>{formatDate(selectedMemory.created_at)}</Text>\n                      </div>\n                      {selectedMemory.impact && (\n                        <div>\n                          <Text strong>Impact: </Text>\n                          <Tag color={getImpactColor(selectedMemory.impact)}>{selectedMemory.impact}</Tag>\n                        </div>\n                      )}\n                      {selectedMemory.tags && selectedMemory.tags.length > 0 && (\n                        <div>\n                          <Text strong>Tags: </Text>\n                          <Space size=\"small\">\n                            {selectedMemory.tags.map((tag, idx) => (\n                              <Tag key={idx}>{tag}</Tag>\n                            ))}\n                          </Space>\n                        </div>\n                      )}\n                    </Space>\n                  </div>\n                  <Divider />\n                  <div style={{ maxHeight: '400px', overflow: 'auto' }}>\n                    <pre style={{ whiteSpace: 'pre-wrap', fontFamily: 'inherit', fontSize: '14px' }}>\n                      {memoryDetail.content}\n                    </pre>\n                  </div>\n                </div>\n              ) : (\n                <Empty description=\"Failed to load memory detail\" />\n              )}\n            </Tabs.TabPane>\n            <Tabs.TabPane tab=\"Summary\" key=\"summary\">\n              {selectedMemory && (\n                <div>\n                  <Paragraph>\n                    <Text strong>Summary: </Text>\n                    {selectedMemory.summary}\n                  </Paragraph>\n                  {selectedMemory.file && (\n                    <Paragraph>\n                      <Text strong>File: </Text>\n                      <Text code>{selectedMemory.file}</Text>\n                    </Paragraph>\n                  )}\n                </div>\n              )}\n            </Tabs.TabPane>\n          </Tabs>\n        )}\n      </Modal>\n    </div>\n  );\n}\n\nexport default MemoryPanel;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 11.0,
      "lines_of_code": 343,
      "number_of_classes": 0,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "MemoryPanel.jsx is a React functional component that serves as a Memory Browser interface in a coworking/AI system. The component provides a comprehensive UI for browsing, filtering, and viewing memory items stored in the system. \n\nKey functionality includes:\n- Multi-dimensional filtering: Users can filter memories by query type (all, project, session), category (decisions, experiences, patterns, records), development stage (idea, PRD, design, plan, coding, check), and result limit (10, 20, 50, 100)\n- Memory listing: Displays memories in a card-based format showing title, category tags, summary, creation timestamp, impact level, and associated tags\n- Detail viewing: Modal dialog with tabbed interface showing detailed memory content, metadata (ID, category, stage, created time, impact), and summary information\n- Asynchronous data loading: Fetches memory index and details through Tauri's invoke API with proper loading states and error handling\n- Visual categorization: Color-coded tags for different memory categories (blue for decisions, green for experiences, purple for patterns, orange for records) and impact levels (red for high, orange for medium, green for low)\n- Automatic refresh: Uses React useEffect hook to reload data when filter parameters or current session change\n\nThe component integrates with Ant Design UI library and communicates with backend services via Tauri's inter-process communication mechanism.",
    "interfaces": [],
    "responsibilities": [
      "Memory data management and state lifecycle control",
      "UI rendering and presentation of memory browser with filtering controls",
      "Backend API communication for memory index and detail retrieval",
      "User interaction handling (search, filter selection, memory viewing)",
      "Visual formatting and categorization of memory metadata with color-coded display"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "page",
      "description": "A React component that provides preview functionality for application iterations, allowing users to start, stop, and refresh previews through a web interface",
      "file_path": "crates\\cowork-gui\\src\\components\\PreviewPanel.jsx",
      "functions": [
        "startPreview",
        "stopPreview",
        "refreshPreview"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "iterationId: string | number - The identifier of the iteration to preview",
        "previewUrl: string | null - The URL of the running preview",
        "isRunning: boolean - Whether the preview is currently active",
        "loading: boolean - Whether an operation is in progress",
        "error: string | null - Error message if any operation failed"
      ],
      "name": "PreviewPanel.jsx",
      "source_summary": "import { useState, useEffect } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport { Spin, Alert, Button, Space } from 'antd';\nimport { ReloadOutlined, FullscreenOutlined, StopOutlined } from '@ant-design/icons';\n\nconst PreviewPanel = ({ iterationId }) => {\n  const [previewUrl, setPreviewUrl] = useState(null);\n  const [isRunning, setIsRunning] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const startPreview = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Try new V2 API first, fall back to legacy API\n      const result = await invoke('start_iteration_preview', { iterationId })\n        .catch(() => invoke('start_preview', { sessionId: iterationId }));\n      setPreviewUrl(result.url);\n      setIsRunning(true);\n    } catch (err) {\n      setError(err.toString());\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const stopPreview = async () => {\n    setLoading(true);\n    try {\n      await invoke('stop_iteration_preview', { iterationId })\n        .catch(() => invoke('stop_preview', { sessionId: iterationId }));\n      setPreviewUrl(null);\n      setIsRunning(false);\n    } catch (err) {\n      setError(err.toString());\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const refreshPreview = () => {\n    if (previewUrl) {\n      const iframe = document.querySelector('.preview-frame');\n      if (iframe) {\n        iframe.src = iframe.src;\n      }\n    }\n  };\n\n  return (\n    <div className=\"preview-panel\" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n      <div style={{ padding: '10px', borderBottom: '1px solid #303030', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <h3>🌐 Preview</h3>\n        <Space>\n          {!isRunning ? (\n            <Button\n              type=\"primary\"\n              icon={<span>▶</span>}\n              onClick={startPreview}\n              loading={loading}\n            >\n              Start Preview\n            </Button>\n          ) : (\n            <>\n              <Button icon={<ReloadOutlined />} onClick={refreshPreview}>\n                Refresh\n              </Button>\n              <Button icon={<FullscreenOutlined />} onClick={() => alert('Fullscreen feature coming soon')}>\n                Fullscreen\n              </Button>\n              <Button danger icon={<StopOutlined />} onClick={stopPreview} loading={loading}>\n                Stop\n              </Button>\n            </>\n          )}\n        </Space>\n      </div>\n\n      {error && (\n        <Alert\n          message=\"Preview Error\"\n          description={error}\n          type=\"error\"\n          showIcon\n          closable\n          style={{ margin: '10px' }}\n        />\n      )}\n\n      {isRunning && previewUrl ? (\n        <iframe\n          src={previewUrl}\n          className=\"preview-frame\"\n          style={{\n            flex: 1,\n            width: '100%',\n            border: 'none',\n            background: '#fff',\n          }}\n          title=\"Preview\"\n        />\n      ) : (\n        <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#888', flexDirection: 'column', gap: '10px' }}>\n          {loading ? (\n            <>\n              <Spin />\n              <div>Starting preview...</div>\n            </>\n          ) : 'Click \"Start Preview\" to preview your application'}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default PreviewPanel;"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 3.0,
      "lines_of_code": 118,
      "number_of_classes": 0,
      "number_of_functions": 3
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The PreviewPanel is a React functional component designed to provide live preview functionality for application iterations in a collaborative development environment. The component serves as a user interface that manages the entire lifecycle of preview sessions through integration with Tauri's backend API.\n\nCore functionality includes: (1) Starting a preview session by invoking backend APIs with fallback support for both V2 and legacy API versions, (2) Stopping active preview sessions and cleaning up resources, (3) Refreshing the preview by reloading the iframe content, (4) Displaying the preview in an embedded iframe when active, and (5) Providing comprehensive error handling and user feedback.\n\nThe component maintains five key state variables: previewUrl (the URL to load in the iframe), isRunning (whether a preview session is active), loading (loading state for async operations), error (error messages), and iterationId (prop representing the iteration to preview). The UI dynamically renders different states: a control panel with Start/Stop/Refresh buttons, error alerts when issues occur, an iframe for the live preview, or loading/placeholder messages.\n\nThe component employs a dual API strategy, attempting the newer V2 API first ('start_iteration_preview' and 'stop_iteration_preview') and falling back to legacy APIs ('start_preview' and 'stop_preview') if needed, ensuring backward compatibility. The iframe refresh is implemented through direct DOM manipulation by setting the src property to its current value.",
    "interfaces": [
      {
        "description": "Component props interface accepting iterationId parameter",
        "interface_type": "ComponentProps",
        "name": "props",
        "parameters": [
          {
            "description": "The unique identifier of the iteration to preview",
            "is_optional": false,
            "name": "iterationId",
            "param_type": "string | number"
          }
        ],
        "return_type": "JSX.Element",
        "visibility": "public"
      },
      {
        "description": "Async function to start a preview session by calling backend APIs with fallback support",
        "interface_type": "AsyncFunction",
        "name": "startPreview",
        "parameters": [],
        "return_type": "Promise<void>",
        "visibility": "private"
      },
      {
        "description": "Async function to stop the active preview session and clean up resources",
        "interface_type": "AsyncFunction",
        "name": "stopPreview",
        "parameters": [],
        "return_type": "Promise<void>",
        "visibility": "private"
      },
      {
        "description": "Function to refresh the iframe content by reloading its src property",
        "interface_type": "Function",
        "name": "refreshPreview",
        "parameters": [],
        "return_type": "void",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Preview lifecycle management - controlling the start, stop, and refresh operations of preview sessions",
      "Backend API integration - communicating with Tauri backend services to manage preview servers and retrieve preview URLs",
      "State management - maintaining and updating component state for preview status, loading states, errors, and URL information",
      "User interface rendering - providing controls for preview operations and displaying the preview iframe or status messages",
      "Error handling and user feedback - capturing, displaying, and managing error states with appropriate UI feedback"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": "A React functional component that provides a project management interface for displaying, opening, editing, and deleting projects in a Tauri-based desktop GUI application.",
      "file_path": "crates\\cowork-gui\\src\\components\\ProjectsPanel.jsx",
      "functions": [
        "loadProjects",
        "handleEditProject",
        "handleDeleteProject",
        "handleOpenProject",
        "handleOpenEditModal",
        "handleOpenDirectory",
        "handleSelectDirectory",
        "formatDate",
        "getDisplayPath",
        "getStatusColor"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "ProjectsPanel.jsx",
      "source_summary": "import { useState, useEffect } from \"react\";\nimport { invoke } from \"@tauri-apps/api/core\";\nimport { getCurrentWindow } from \"@tauri-apps/api/window\";\nimport { listen } from \"@tauri-apps/api/event\";\nimport { open } from \"@tauri-apps/plugin-dialog\";\nimport {\n  Card,\n  Button,\n  Modal,\n  Input,\n  Tag,\n  Empty,\n  message,\n  Spin,\n  Space,\n  Tooltip,\n} from \"antd\";\nimport {\n  FolderOpenOutlined,\n  DeleteOutlined,\n  EditOutlined,\n  CheckCircleOutlined,\n  ClockCircleOutlined,\n} from \"@ant-design/icons\";\n\nconst ProjectsPanel = () => {\n  const [projects, setProjects] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [showEditModal, setShowEditModal] = useState(false);\n  const [showOpenDirModal, setShowOpenDirModal] = useState(false);\n  const [selectedProject, setSelectedProject] = useState(null);\n  const [openDirPath, setOpenDirPath] = useState(\"\");\n  const [editProjectName, setEditProjectName] = useState(\"\");\n  const [editProjectDescription, setEditProjectDescription] = useState(\"\");\n\n  const loadProjects = async () => {\n    setLoading(true);\n    try {\n      const data = await invoke(\"get_all_projects\", {\n        status: null,\n        search: null,\n        limit: null,\n      });\n      setProjects(data || []);\n    } catch (error) {\n      console.error(\"[ProjectsPanel] Failed to load projects:\", error);\n      message.error(\"Failed to load projects: \" + error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadProjects();\n\n    // Listen for project registration events to refresh the list\n    const unlistenProjectLoaded = listen(\"project_loaded\", () => {\n      console.log(\n        \"[ProjectsPanel] Project loaded event received, reloading projects...\",\n      );\n      loadProjects();\n    });\n\n    const unlistenProjectCreated = listen(\"project_created\", () => {\n      console.log(\n        \"[ProjectsPanel] Project created event received, reloading projects...\",\n      );\n      loadProjects();\n    });\n\n    return () => {\n      unlistenProjectLoaded\n        .then((fn) => fn())\n        .catch((e) =>\n          console.error(\n            \"[ProjectsPanel] Failed to unlisten project_loaded:\",\n            e,\n          ),\n        );\n      unlistenProjectCreated\n        .then((fn) => fn())\n        .catch((e) =>\n          console.error(\n            \"[ProjectsPanel] Failed to unlisten project_created:\",\n            e,\n          ),\n        );\n    };\n  }, []);\n\n  const handleEditProject = async () => {\n    if (!editProjectName.trim()) {\n      message.warning(\"Please enter project name\");\n      return;\n    }\n\n    try {\n      await invoke(\"update_project\", {\n        projectId: selectedProject.project_id,\n        name: editProjectName,\n        description: editProjectDescription || null,\n        status: null,\n      });\n      message.success(\"Project updated successfully\");\n      setShowEditModal(false);\n      setSelectedProject(null);\n      setEditProjectName(\"\");\n      setEditProjectDescription(\"\");\n      loadProjects();\n    } catch (error) {\n      message.error(\"Failed to update project: \" + error);\n    }\n  };\n\n  const handleDeleteProject = async (project) => {\n    Modal.confirm({\n      title: \"Delete Project\",\n      content: `Are you sure you want to delete \"${project.name}\"?`,\n      okText: \"Delete Record Only\",\n      okType: \"default\",\n      cancelText: \"Delete All (Files & Record)\",\n      onOk: async () => {\n        try {\n          // Check if current window has this project open\n          const currentWorkspace = await invoke(\"get_workspace\");\n          const isCurrentWindowProject =\n            currentWorkspace === project.workspacePath;\n\n          await invoke(\"delete_project\", {\n            projectId: project.project_id,\n            deleteFiles: false,\n          });\n          message.success(\"Project record deleted\");\n          loadProjects();\n\n          // If the deleted project was open in current window, clear workspace\n          if (isCurrentWindowProject) {\n            message.info(\n              \"Project was open in current window. Workspace cleared.\",\n            );\n            // Reload the page to clear all state\n            window.location.reload();\n          }\n        } catch (error) {\n          message.error(\"Failed to delete project: \" + error);\n        }\n      },\n      onCancel: async () => {\n        try {\n          // Check if current window has this project open\n          const currentWorkspace = await invoke(\"get_workspace\");\n          const isCurrentWindowProject =\n            currentWorkspace === project.workspacePath;\n\n          await invoke(\"delete_project\", {\n            projectId: project.project_id,\n            deleteFiles: true,\n          });\n          message.success(\"Project deleted (files and record)\");\n          loadProjects();\n\n          // If the deleted project was open in current window, clear workspace\n          if (isCurrentWindowProject) {\n            message.info(\n              \"Project was open in current window. Workspace cleared.\",\n            );\n            // Reload the page to clear all state\n            window.location.reload();\n          }\n        } catch (error) {\n          message.error(\"Failed to delete project: \" + error);\n        }\n      },\n    });\n  };\n\n  const handleOpenProject = async (projectId) => {\n    try {\n      // Check if current window already has a project\n      const hasProject = await invoke(\"has_open_project\");\n\n      if (hasProject) {\n        // Open in new window\n        await invoke(\"open_project\", { projectId });\n        message.info(\"Opening project in new window...\");\n      } else {\n        // Open in current window\n        await invoke(\"open_project_in_current_window\", { projectId });\n        message.success(\"Project opened successfully\");\n        // The frontend will automatically reload sessions when 'project_loaded' event is received\n      }\n    } catch (error) {\n      message.error(\"Failed to open project: \" + error);\n    }\n  };\n  const handleOpenEditModal = (project) => {\n    setSelectedProject(project);\n    setEditProjectName(project.name);\n    setEditProjectDescription(project.description || \"\");\n    setShowEditModal(true);\n  };\n\n  const handleOpenDirectory = async () => {\n    if (!openDirPath.trim()) {\n      message.warning(\"Please enter a directory path\");\n      return;\n    }\n\n    try {\n      // Check if current window already has a project\n      const hasProject = await invoke(\"has_open_project\");\n\n      if (hasProject) {\n        // Register the project and open in new window\n        const projectName = openDirPath.split(/[/\\\\]/).pop() || openDirPath;\n        await invoke(\"register_project\", {\n          workspacePath: openDirPath,\n          name: projectName,\n          description: `Project at ${openDirPath}`,\n        });\n\n        // Get the newly registered project\n        const allProjects = await invoke(\"get_all_projects\", {\n          status: null,\n          search: null,\n          limit: null,\n        });\n        const newProject = allProjects.find(\n          (p) => p.workspacePath === openDirPath,\n        );\n\n        if (newProject) {\n          await invoke(\"open_project\", { projectId: newProject.projectId });\n          message.success(\"Opening project in new window...\");\n        } else {\n          message.error(\"Failed to find newly registered project\");\n        }\n\n        setShowOpenDirModal(false);\n        setOpenDirPath(\"\");\n        loadProjects();\n      } else {\n        // Open in current window\n        await invoke(\"set_workspace\", { workspacePath: openDirPath });\n        message.success(\"Workspace set successfully\");\n        setShowOpenDirModal(false);\n        setOpenDirPath(\"\");\n        // The frontend will automatically reload sessions when 'project_loaded' event is received\n      }\n    } catch (error) {\n      message.error(\"Failed to open directory: \" + error);\n    }\n  };\n\n  const handleSelectDirectory = async () => {\n    try {\n      const selected = await open({\n        directory: true,\n        multiple: false,\n        title: \"Select Directory\",\n      });\n      \n      if (selected && typeof selected === \"string\") {\n        setOpenDirPath(selected);\n      }\n    } catch (error) {\n      console.error(\"Failed to open directory dialog:\", error);\n      message.error(\"Failed to open directory dialog: \" + error);\n    }\n  };\n\n  const formatDate = (dateString) => {\n    if (!dateString) return \"Never\";\n    const date = new Date(dateString);\n    return date.toLocaleDateString(\"en-US\", {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n  };\n\n  const getDisplayPath = (fullPath) => {\n    if (!fullPath) return \"No path\";\n    const parts = fullPath.split(/[/\\\\]/);\n    // 只显示最后两个部分（文件夹名和它的父目录）\n    if (parts.length >= 2) {\n      return \".../\" + parts.slice(-2).join(\"/\");\n    }\n    return fullPath;\n  };\n\n  const getStatusColor = (status) => {\n    switch (status) {\n      case \"active\":\n        return \"green\";\n      case \"archived\":\n        return \"default\";\n      case \"deleted\":\n        return \"red\";\n      default:\n        return \"default\";\n    }\n  };\n\n  return (\n    <div style={{ padding: \"24px\" }}>\n      <div\n        style={{\n          marginBottom: \"24px\",\n          display: \"flex\",\n          justifyContent: \"space-between\",\n          alignItems: \"center\",\n        }}\n      >\n        <h2 style={{ margin: 0 }}>Projects</h2>\n        <Button\n          icon={<FolderOpenOutlined />}\n          onClick={() => setShowOpenDirModal(true)}\n        >\n          Open Directory\n        </Button>\n      </div>\n\n      {loading ? (\n        <div style={{ textAlign: \"center\", padding: \"60px 0\" }}>\n          <Spin size=\"large\" />\n          <div style={{ marginTop: \"16px\", color: \"#999\" }}>\n            Loading projects...\n          </div>\n        </div>\n      ) : projects.length === 0 ? (\n        <Empty\n          description=\"No projects yet\"\n          image={Empty.PRESENTED_IMAGE_SIMPLE}\n        >\n          <Button\n            type=\"primary\"\n            icon={<FolderOpenOutlined />}\n            onClick={() => setShowOpenDirModal(true)}\n          >\n            Open Directory to Start\n          </Button>\n        </Empty>\n      ) : (\n        <div\n          style={{\n            display: \"grid\",\n            gridTemplateColumns: \"repeat(auto-fill, minmax(350px, 1fr))\",\n            gap: \"20px\",\n          }}\n        >\n          {projects.map((project) => (\n            <Card\n              key={project.project_id}\n              hoverable\n              actions={[\n                <Button\n                  type=\"link\"\n                  icon={<FolderOpenOutlined />}\n                  onClick={() => handleOpenProject(project.project_id)}\n                  style={{ color: \"#1890ff\", width: \"90%\" }}\n                >\n                  Open\n                </Button>,\n                <Button\n                  type=\"link\"\n                  icon={<EditOutlined />}\n                  style={{ color: \"#1890ff\", width: \"90%\" }}\n                  onClick={() => handleOpenEditModal(project)}\n                >\n                  Edit\n                </Button>,\n                <Button\n                  type=\"link\"\n                  danger\n                  icon={<DeleteOutlined />}\n                  style={{ width: \"90%\" }}\n                  onClick={() => handleDeleteProject(project)}\n                >\n                  Delete\n                </Button>,\n              ]}\n            >\n              <Card.Meta\n                title={\n                  <div\n                    style={{\n                      display: \"flex\",\n                      alignItems: \"center\",\n                      gap: \"8px\",\n                    }}\n                  >\n                    <span>{project.name}</span>\n                    <Tag\n                      color={getStatusColor(project.status)}\n                      style={{ margin: 0 }}\n                    >\n                      {project.status}\n                    </Tag>\n                  </div>\n                }\n                description={\n                  <div\n                    style={{\n                      display: \"flex\",\n                      flexDirection: \"column\",\n                      gap: \"8px\",\n                    }}\n                  >\n                    <Tooltip title={project.description || \"No description provided\"}>\n                      <div\n                        style={{\n                          color: \"#666\",\n                          fontSize: \"14px\",\n                          whiteSpace: \"nowrap\",\n                          overflow: \"hidden\",\n                          textOverflow: \"ellipsis\",\n                          cursor: \"help\",\n                        }}\n                      >\n                        {project.description || \"No description provided\"}\n                      </div>\n                    </Tooltip>\n                    <div\n                      style={{ fontSize: \"12px\", color: \"#999\", minWidth: 0 }}\n                    >\n                      <Tooltip title={project.workspace_path || \"No path\"}>\n                        <span\n                          style={{\n                            display: \"flex\",\n                            alignItems: \"center\",\n                            maxWidth: \"100%\",\n                            overflow: \"hidden\",\n                            textOverflow: \"ellipsis\",\n                            whiteSpace: \"nowrap\",\n                          }}\n                        >\n                          <FolderOpenOutlined\n                            style={{ marginRight: \"4px\", flexShrink: 0 }}\n                          />\n                          {getDisplayPath(project.workspace_path)}\n                        </span>\n                      </Tooltip>\n                    </div>\n                    <div\n                      style={{\n                        display: \"flex\",\n                        gap: \"16px\",\n                        fontSize: \"12px\",\n                        color: \"#999\",\n                      }}\n                    >\n                      <span>\n                        <CheckCircleOutlined style={{ marginRight: \"4px\" }} />\n                        {project.metadata.session_count} sessions\n                      </span>\n                      <span>\n                        <ClockCircleOutlined style={{ marginRight: \"4px\" }} />\n                        Last opened: {formatDate(project.last_opened_at)}\n                      </span>\n                    </div>\n                    {project.metadata.technology_stack.length > 0 && (\n                      <div\n                        style={{\n                          display: \"flex\",\n                          flexWrap: \"wrap\",\n                          gap: \"4px\",\n                        }}\n                      >\n                        {project.metadata.technology_stack\n                          .slice(0, 4)\n                          .map((tech, idx) => (\n                            <Tag key={idx} size=\"small\" color=\"blue\">\n                              {tech}\n                            </Tag>\n                          ))}\n                        {project.metadata.technology_stack.length > 4 && (\n                          <Tag size=\"small\" color=\"default\">\n                            +{project.metadata.technology_stack.length - 4}\n                          </Tag>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                }\n              />\n            </Card>\n          ))}\n        </div>\n      )}\n\n      {/* Edit Project Modal */}\n      <Modal\n        title=\"Edit Project\"\n        open={showEditModal}\n        onOk={handleEditProject}\n        onCancel={() => {\n          setShowEditModal(false);\n          setSelectedProject(null);\n          setEditProjectName(\"\");\n          setEditProjectDescription(\"\");\n        }}\n        okText=\"Save\"\n        cancelText=\"Cancel\"\n      >\n        <div style={{ marginBottom: \"16px\" }}>\n          <label\n            style={{\n              display: \"block\",\n              marginBottom: \"8px\",\n              fontWeight: \"bold\",\n            }}\n          >\n            Project Name:\n          </label>\n          <Input\n            value={editProjectName}\n            onChange={(e) => setEditProjectName(e.target.value)}\n            placeholder=\"Project name\"\n            autoFocus\n          />\n        </div>\n        <div>\n          <label\n            style={{\n              display: \"block\",\n              marginBottom: \"8px\",\n              fontWeight: \"bold\",\n            }}\n          >\n            Description:\n          </label>\n          <Input.TextArea\n            value={editProjectDescription}\n            onChange={(e) => setEditProjectDescription(e.target.value)}\n            placeholder=\"Project description\"\n            rows={4}\n          />\n        </div>\n      </Modal>\n\n      {/* Open Directory Modal */}\n      <Modal\n        title=\"Open Directory\"\n        open={showOpenDirModal}\n        onOk={handleOpenDirectory}\n        onCancel={() => {\n          setShowOpenDirModal(false);\n          setOpenDirPath(\"\");\n        }}\n        okText=\"Open\"\n        cancelText=\"Cancel\"\n      >\n        <div>\n          <label\n            style={{\n              display: \"block\",\n              marginBottom: \"8px\",\n              fontWeight: \"bold\",\n            }}\n          >\n            Directory Path:\n          </label>\n          <Space.Compact style={{ width: \"100%\" }}>\n            <Input\n              value={openDirPath}\n              onChange={(e) => setOpenDirPath(e.target.value)}\n              placeholder=\"e.g., D:\\\\Workspace\\\\tmp\\\\cowork_workspace\"\n              autoFocus\n            />\n            <Button\n              icon={<FolderOpenOutlined />}\n              onClick={handleSelectDirectory}\n            >\n              Browse\n            </Button>\n          </Space.Compact>\n          <div style={{ marginTop: \"8px\", fontSize: \"12px\", color: \"#999\" }}>\n            Path to any directory (with or without .cowork folder). This will\n            open the directory in a new workspace context.\n          </div>\n        </div>\n      </Modal>\n    </div>\n  );\n};\n\nexport default ProjectsPanel;\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 21.0,
      "lines_of_code": 590,
      "number_of_classes": 0,
      "number_of_functions": 10
    },
    "dependencies": [
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 2,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 3,
        "name": "@tauri-apps/api/window",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 4,
        "name": "@tauri-apps/api/event",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 5,
        "name": "@tauri-apps/plugin-dialog",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 6,
        "name": "antd",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "ProjectsPanel.jsx is a comprehensive project management UI component built with React and Ant Design for a Tauri-based desktop application. The component serves as the central interface for managing software projects within the cowork-gui system.\n\n## Functional Description:\n\n**Project Display & Management:**\n- Renders projects in a responsive grid layout using Card components\n- Each project card displays: name, status tag, description, workspace path, session count, last opened timestamp, and technology stack tags\n- Handles empty states and loading states with appropriate UI feedback\n\n**Project Operations:**\n- **Opening Projects:** Intelligently determines whether to open a project in the current window or a new window based on whether the current window already has an open project. Uses Tauri IPC commands: `has_open_project`, `open_project`, and `open_project_in_current_window`\n- **Editing Projects:** Allows modifying project names and descriptions through a modal dialog using the `update_project` Tauri command\n- **Deleting Projects:** Provides a sophisticated deletion workflow with two options: delete record only, or delete files and record. Includes safety checks to clear workspace if the deleted project was open in the current window\n\n**Directory Management:**\n- **Opening Directories:** Users can open any directory path. If the current window has no project, it sets the workspace directly using `set_workspace`. If a project is already open, it registers the directory as a new project using `register_project` and opens it in a new window\n- **Directory Selection:** Integrates with Tauri's file dialog plugin to provide a native directory browsing experience\n\n**Event-Driven Architecture:**\n- Implements real-time updates by listening to Tauri events (`project_loaded` and `project_created`)\n- Automatically reloads the project list when these events are received\n- Properly cleans up event listeners in the useEffect cleanup function\n\n**UI/UX Features:**\n- Truncated path display with tooltip for full path\n- Color-coded status tags (active=green, archived=default, deleted=red)\n- Responsive grid layout that adapts to screen size\n- Loading spinners and empty states for better user experience\n- Confirmation dialogs for destructive actions\n- Form validation with user feedback via Ant Design message system\n\n**Helper Functions:**\n- `formatDate`: Converts ISO date strings to localized date format\n- `getDisplayPath`: Truncates long paths to show only the last two directory levels\n- `getStatusColor`: Maps status strings to appropriate color codes",
    "interfaces": [],
    "responsibilities": [
      "Project List Management - Loading, displaying, and refreshing project data from backend via Tauri IPC calls",
      "Project CRUD Operations - Handling project creation (via directory registration), editing (name/description updates), and deletion (record-only or full deletion)",
      "Window/Workspace Management - Intelligently routing project opens to current or new windows, managing workspace context, and clearing workspace on deletion",
      "Event-Driven State Synchronization - Listening to and responding to Tauri backend events for real-time project list updates",
      "User Interface Presentation - Rendering project cards, modals, and interactive controls with proper loading states, empty states, and error handling"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "widget",
      "description": "A React UI component for managing project execution and displaying real-time logs with filtering capabilities.",
      "file_path": "crates\\cowork-gui\\src\\components\\RunnerPanel.jsx",
      "functions": [
        "startProject",
        "stopProject",
        "clearLogs",
        "copyLogs"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "RunnerPanel.jsx",
      "source_summary": "import { useState, useEffect, useRef } from 'react';\nimport { invoke } from '@tauri-apps/api/core';\nimport { listen } from '@tauri-apps/api/event';\nimport { Spin, Button, Space, Tag, Input, Select, Checkbox } from 'antd';\nimport { PlayCircleOutlined, StopOutlined, CopyOutlined, ClearOutlined, SearchOutlined } from '@ant-design/icons';\nimport { showError, showSuccess } from '../utils/errorHandler.jsx';\n\nconst { TextArea } = Input;\n\nconst RunnerPanel = ({ iterationId }) => {\n  const [logs, setLogs] = useState([]);\n  const [isRunning, setIsRunning] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [searchText, setSearchText] = useState('');\n  const [filterType, setFilterType] = useState('all'); // all, stdout, stderr\n  const [autoScroll, setAutoScroll] = useState(true);\n  const [maxLogs, setMaxLogs] = useState(5000);\n  const logsEndRef = useRef(null);\n  const logsContainerRef = useRef(null);\n  const listenersRegistered = useRef(false);\n\n  // Auto-scroll to bottom when new logs arrive\n  useEffect(() => {\n    if (autoScroll && logsEndRef.current) {\n      logsEndRef.current.scrollTop = logsEndRef.current.scrollHeight;\n    }\n  }, [logs, autoScroll]);\n\n  // Register event listeners\n  useEffect(() => {\n    if (listenersRegistered.current) {\n      return;\n    }\n    listenersRegistered.current = true;\n\n    const cleanupFunctions = [];\n\n    // Listen for project log events\n    listen('project_log', (event) => {\n      const { iteration_id: logIterationId, session_id: logSessionId, stream, content } = event.payload;\n      \n      // Only process logs for current iteration (support both new and old event format)\n      const targetId = logIterationId || logSessionId;\n      if (targetId !== iterationId) {\n        return;\n      }\n\n      setLogs(prev => {\n        // Keep only last maxLogs entries to prevent memory issues\n        const newLogs = [...prev, { type: stream, content, timestamp: new Date() }];\n        return newLogs.slice(-maxLogs);\n      });\n    }).then(unlisten => cleanupFunctions.push(unlisten));\n\n    // Listen for project stopped events\n    listen('project_stopped', (event) => {\n      const { iteration_id: stoppedIterationId, session_id: stoppedSessionId } = event.payload;\n      const targetId = stoppedIterationId || stoppedSessionId;\n      if (targetId === iterationId) {\n        setIsRunning(false);\n      }\n    }).then(unlisten => cleanupFunctions.push(unlisten));\n\n    return () => {\n      cleanupFunctions.forEach(unlisten => {\n        try { unlisten(); } catch (e) {}\n      });\n      listenersRegistered.current = false;\n    };\n  }, [sessionId, maxLogs]);\n\n  const startProject = async () => {\n    setLoading(true);\n    setLogs(prev => [...prev, { type: 'system', content: '> Starting project...\\n', timestamp: new Date() }]);\n    \n    const result = await tryExecute(async () => {\n      // Try new V2 API first, fall back to legacy API\n      return await invoke('start_iteration_project', { iterationId })\n        .catch(() => invoke('start_project', { sessionId: iterationId }));\n    }, 'Failed to start project');\n    \n    setLoading(false);\n    \n    if (result) {\n      setIsRunning(true);\n      setLogs(prev => [...prev, { type: 'system', content: `> Project started (PID: ${result.process_id})\\n`, timestamp: new Date() }]);\n    }\n  };\n\n  const stopProject = async () => {\n    setLoading(true);\n    setLogs(prev => [...prev, { type: 'system', content: '> Stopping project...\\n', timestamp: new Date() }]);\n    \n    const success = await tryExecute(async () => {\n      await invoke('stop_iteration_project', { iterationId })\n        .catch(() => invoke('stop_project', { sessionId: iterationId }));\n      return true;\n    }, 'Failed to stop project');\n    \n    setLoading(false);\n    \n    if (success) {\n      setIsRunning(false);\n      setLogs(prev => [...prev, { type: 'system', content: '> Project stopped\\n', timestamp: new Date() }]);\n    }\n  };\n\n  const clearLogs = () => {\n    setLogs([]);\n  };\n\n  const copyLogs = () => {\n    const logsText = logs.map(log => log.content).join('');\n    navigator.clipboard.writeText(logsText);\n  };\n\n  // Filter logs based on search text and type\n  const filteredLogs = logs.filter(log => {\n    // Filter by type\n    if (filterType !== 'all' && log.type !== filterType) {\n      return false;\n    }\n    \n    // Filter by search text\n    if (searchText && !log.content.toLowerCase().includes(searchText.toLowerCase())) {\n      return false;\n    }\n    \n    return true;\n  });\n\n  return (\n    <div className=\"runner-panel\" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>\n      {/* Header */}\n      <div style={{ padding: '10px', borderBottom: '1px solid #303030', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <h3>🚀 Run Project</h3>\n        <Space>\n          {!isRunning ? (\n            <Button\n              type=\"primary\"\n              icon={<PlayCircleOutlined />}\n              onClick={startProject}\n              loading={loading}\n            >\n              Start\n            </Button>\n          ) : (\n            <Button danger icon={<StopOutlined />} onClick={stopProject} loading={loading}>\n              Stop\n            </Button>\n          )}\n          <Button icon={<ClearOutlined />} onClick={clearLogs} disabled={logs.length === 0}>\n            Clear\n          </Button>\n          <Button icon={<CopyOutlined />} onClick={copyLogs} disabled={logs.length === 0}>\n            Copy\n          </Button>\n        </Space>\n      </div>\n\n      {/* Filter Bar */}\n      <div style={{ padding: '8px 10px', borderBottom: '1px solid #303030', display: 'flex', gap: '10px', alignItems: 'center', background: '#1a1a1a' }}>\n        <Input\n          placeholder=\"Search logs...\"\n          prefix={<SearchOutlined />}\n          value={searchText}\n          onChange={(e) => setSearchText(e.target.value)}\n          style={{ width: '200px' }}\n          allowClear\n        />\n        <Select\n          value={filterType}\n          onChange={setFilterType}\n          style={{ width: '120px' }}\n        >\n          <Select.Option value=\"all\">All Logs</Select.Option>\n          <Select.Option value=\"stdout\">Stdout</Select.Option>\n          <Select.Option value=\"stderr\">Stderr</Select.Option>\n          <Select.Option value=\"system\">System</Select.Option>\n        </Select>\n        <Checkbox checked={autoScroll} onChange={(e) => setAutoScroll(e.target.checked)}>\n          Auto-scroll\n        </Checkbox>\n        <span style={{ color: '#888', fontSize: '12px', marginLeft: 'auto' }}>\n          {filteredLogs.length}/{logs.length} lines\n        </span>\n      </div>\n\n      {/* Logs Display */}\n      <div\n        ref={logsEndRef}\n        style={{\n          flex: 1,\n          backgroundColor: '#1e1e1e',\n          color: '#d4d4d4',\n          fontFamily: 'Consolas, \"Courier New\", monospace',\n          fontSize: '13px',\n          padding: '10px',\n          overflow: 'auto',\n          whiteSpace: 'pre-wrap',\n          wordBreak: 'break-all',\n        }}\n      >\n        {logs.length === 0 ? (\n          <div style={{ color: '#888', textAlign: 'center', marginTop: '50px' }}>\n            Click \"Start\" to run your project\n          </div>\n        ) : filteredLogs.length === 0 ? (\n          <div style={{ color: '#888', textAlign: 'center', marginTop: '50px' }}>\n            No logs match the current filter\n          </div>\n        ) : (\n          filteredLogs.map((log, index) => (\n            <div key={index} style={{ \n              color: log.type === 'stderr' ? '#ff6b6b' : \n                    log.type === 'system' ? '#52c41a' : '#d4d4d4',\n              marginBottom: '2px'\n            }}>\n              {log.content}\n            </div>\n          ))\n        )}\n      </div>\n\n      {/* Footer */}\n      <div style={{ padding: '5px 10px', borderTop: '1px solid #303030', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: '#1a1a1a' }}>\n        <Tag color={isRunning ? 'green' : 'default'}>\n          Status: {isRunning ? 'Running' : 'Stopped'}\n        </Tag>\n        <span style={{ color: '#888', fontSize: '12px' }}>\n          {isRunning ? 'Project is running' : 'Project is stopped'}\n        </span>\n      </div>\n    </div>\n  );\n};\n\nexport default RunnerPanel; "
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 13.0,
      "lines_of_code": 238,
      "number_of_classes": 0,
      "number_of_functions": 4
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 1,
        "name": "react",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 2,
        "name": "@tauri-apps/api/core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 3,
        "name": "@tauri-apps/api/event",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 4,
        "name": "antd",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": 5,
        "name": "@ant-design/icons",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 6,
        "name": "../utils/errorHandler.jsx",
        "path": "crates\\cowork-gui\\src\\utils\\errorHandler.jsx",
        "version": null
      }
    ],
    "detailed_description": "The RunnerPanel is a frontend UI widget component built with React and Ant Design, integrated with Tauri's IPC system. Its primary function is to provide a comprehensive interface for executing and monitoring project runs within a cowork-gui application. The component manages the complete lifecycle of project execution, including initiating runs, terminating processes, and displaying real-time log output from stdout, stderr, and system messages. It implements sophisticated log management features including search functionality, type-based filtering (stdout/stderr/system), auto-scroll behavior, and memory optimization by limiting the maximum number of log entries (default: 5000). The component establishes event-driven communication with the backend through Tauri's event system, listening for 'project_log' and 'project_stopped' events, and invokes backend commands for project control. It handles API version compatibility by attempting new V2 APIs ('start_iteration_project', 'stop_iteration_project') with fallback to legacy APIs. The UI is divided into a header with action buttons, a filter bar for log management, a main log display area with syntax highlighting based on log type, and a footer showing execution status.",
    "interfaces": [],
    "responsibilities": [
      "Project lifecycle management - controlling project start/stop operations through Tauri IPC invoke commands with API version fallback support",
      "Real-time log aggregation and display - receiving, storing, and rendering log events from backend through Tauri's event listener system with memory optimization",
      "Log filtering and search functionality - providing user-controlled filtering by log type (stdout/stderr/system) and text-based search capabilities",
      "State management and user interaction - managing component state for running status, loading states, auto-scroll preferences, and user-triggered actions (clear, copy logs)",
      "Event listener lifecycle management - properly registering and cleanup of Tauri event listeners with ref-based deduplication to prevent multiple registrations"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "util",
      "description": "Error handling utility that converts technical backend error messages into user-friendly Chinese messages with actionable solutions",
      "file_path": "crates\\cowork-gui\\src\\utils\\errorHandler.jsx",
      "functions": [
        "parseError",
        "showError",
        "showWarning",
        "showSuccess",
        "showInfo",
        "tryExecute"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "errorHandler.jsx",
      "source_summary": "// Error Handler - Convert technical errors to user-friendly messages\nimport { message } from 'antd';\n\n// Error message mappings and solutions\nconst ERROR_MAPPINGS = {\n  // File system errors\n  'Failed to read file': {\n    userMessage: '无法读取文件',\n    solution: '请检查文件路径是否正确，确保文件存在且有读取权限',\n    severity: 'error'\n  },\n  'Failed to write file': {\n    userMessage: '无法写入文件',\n    solution: '请检查是否有写入权限，或磁盘空间是否充足',\n    severity: 'error'\n  },\n  'Failed to create directory': {\n    userMessage: '无法创建目录',\n    solution: '请检查路径是否有效，或是否有创建目录的权限',\n    severity: 'error'\n  },\n  \n  // Session errors\n  'No project found': {\n    userMessage: '未找到项目',\n    solution: '请先创建一个项目，或确保项目目录存在',\n    severity: 'warning'\n  },\n  'No active session found': {\n    userMessage: '未找到活动会话',\n    solution: '请先启动一个项目会话',\n    severity: 'warning'\n  },\n  'Session not found': {\n    userMessage: '会话不存在',\n    solution: '该会话可能已被删除，请刷新页面后重试',\n    severity: 'warning'\n  },\n  \n  // Project errors\n  'Failed to load project index': {\n    userMessage: '无法加载项目索引',\n    solution: '项目可能已损坏，请尝试重新初始化项目',\n    severity: 'error'\n  },\n  'Failed to save project index': {\n    userMessage: '无法保存项目索引',\n    solution: '请检查磁盘空间和写入权限',\n    severity: 'error'\n  },\n  \n  // LLM errors\n  'Failed to load LLM config': {\n    userMessage: '无法加载 AI 配置',\n    solution: '请检查 config.toml 文件是否存在且格式正确',\n    severity: 'error'\n  },\n  'Failed to create LLM client': {\n    userMessage: '无法创建 AI 客户端',\n    solution: '请检查 API 密钥是否正确，网络连接是否正常',\n    severity: 'error'\n  },\n  'LLM request failed': {\n    userMessage: 'AI 请求失败',\n    solution: '请检查网络连接和 API 配额',\n    severity: 'error'\n  },\n  \n  // Pipeline errors\n  'Failed to create pipeline': {\n    userMessage: '无法创建工作流',\n    solution: '请检查项目配置是否完整',\n    severity: 'error'\n  },\n  'Pipeline execution failed': {\n    userMessage: '工作流执行失败',\n    solution: '请查看日志了解详细错误信息，然后重试',\n    severity: 'error'\n  },\n  \n  // Memory errors\n  'Failed to read session index': {\n    userMessage: '无法读取会话索引',\n    solution: '会话数据可能已损坏，请尝试从备份恢复',\n    severity: 'error'\n  },\n  'Failed to save session memory index': {\n    userMessage: '无法保存会话记忆',\n    solution: '请检查磁盘空间和写入权限',\n    severity: 'error'\n  },\n  \n  // Preview errors\n  'Failed to start preview server': {\n    userMessage: '无法启动预览服务器',\n    solution: '端口可能被占用，请尝试使用其他端口',\n    severity: 'error'\n  },\n  'Failed to stop preview server': {\n    userMessage: '无法停止预览服务器',\n    solution: '服务器可能已经停止，请刷新页面',\n    severity: 'warning'\n  },\n  \n  // Runner errors\n  'Failed to start': {\n    userMessage: '无法启动项目',\n    solution: '请检查项目配置和依赖是否正确安装',\n    severity: 'error'\n  },\n  'Failed to stop': {\n    userMessage: '无法停止项目',\n    solution: '进程可能已经停止，请刷新页面',\n    severity: 'warning'\n  },\n  'Code directory not found': {\n    userMessage: '代码目录不存在',\n    solution: '项目可能还没有生成代码，请先运行代码生成',\n    severity: 'warning'\n  },\n  \n  // Project manager errors\n  'Failed to acquire lock': {\n    userMessage: '无法获取项目锁',\n    solution: '其他操作可能正在进行，请稍后重试',\n    severity: 'warning'\n  },\n  'Failed to open project': {\n    userMessage: '无法打开项目',\n    solution: '项目路径可能不存在或无效',\n    severity: 'error'\n  },\n  \n  // Generic errors\n  'Failed to get project root': {\n    userMessage: '无法获取项目根目录',\n    solution: '请确保在有效的项目目录中运行',\n    severity: 'error'\n  },\n  'Failed to get current dir': {\n    userMessage: '无法获取当前目录',\n    solution: '请确保有权限访问当前目录',\n    severity: 'error'\n  },\n};\n\n/**\n * Parse error and return user-friendly information\n * @param {string} error - The error message from backend\n * @returns {object} - Parsed error information\n */\nexport function parseError(error) {\n  const errorStr = String(error);\n  \n  // Try to find a matching error mapping\n  for (const [key, mapping] of Object.entries(ERROR_MAPPINGS)) {\n    if (errorStr.includes(key)) {\n      return {\n        originalError: errorStr,\n        userMessage: mapping.userMessage,\n        solution: mapping.solution,\n        severity: mapping.severity\n      };\n    }\n  }\n  \n  // If no match found, return generic error\n  return {\n    originalError: errorStr,\n    userMessage: '发生未知错误',\n    solution: '请查看详细错误信息，如果问题持续存在，请联系支持',\n    severity: 'error'\n  };\n}\n\n/**\n * Display error to user with user-friendly message and solution\n * @param {string} error - The error message\n * @param {string} customMessage - Optional custom message to override default\n */\nexport function showError(error, customMessage = null) {\n  const parsed = parseError(error);\n  const displayMessage = customMessage || parsed.userMessage;\n  \n  // Show error with solution\n  message.error({\n    content: (\n      <div>\n        <div style={{ fontWeight: 'bold', marginBottom: 4 }}>{displayMessage}</div>\n        <div style={{ fontSize: '12px', color: '#888' }}>\n          {parsed.solution}\n        </div>\n      </div>\n    ),\n    duration: 5\n  });\n  \n  // Log original error for debugging\n  console.error('[Error Handler]', parsed.originalError);\n}\n\n/**\n * Display warning to user\n * @param {string} warning - The warning message\n */\nexport function showWarning(warning) {\n  const parsed = parseError(warning);\n  \n  message.warning({\n    content: (\n      <div>\n        <div style={{ fontWeight: 'bold', marginBottom: 4 }}>{parsed.userMessage}</div>\n        <div style={{ fontSize: '12px', color: '#888' }}>\n          {parsed.solution}\n        </div>\n      </div>\n    ),\n    duration: 3\n  });\n}\n\n/**\n * Display success message\n * @param {string} success - The success message\n */\nexport function showSuccess(success) {\n  message.success(success, 3);\n}\n\n/**\n * Display info message\n * @param {string} info - The info message\n */\nexport function showInfo(info) {\n  message.info(info, 3);\n}\n\n/**\n * Try-execute async function with error handling\n * @param {Function} fn - Async function to execute\n * @param {string} customErrorMessage - Optional custom error message\n * @returns {Promise} - Promise with result or null on error\n */\nexport async function tryExecute(fn, customErrorMessage = null) {\n  try {\n    return await fn();\n  } catch (error) {\n    showError(error, customErrorMessage);\n    return null;\n  }\n}\n\nexport default {\n  parseError,\n  showError,\n  showWarning,\n  showSuccess,\n  showInfo,\n  tryExecute\n};"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 5.0,
      "lines_of_code": 260,
      "number_of_classes": 0,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "npm_package",
        "is_external": true,
        "line_number": 2,
        "name": "antd",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Detailed Functional Description\n\nThe `errorHandler.jsx` is a frontend utility component designed to bridge the gap between technical backend errors and end-user comprehension. It serves as a centralized error handling system that transforms raw error messages from the backend into localized, user-friendly Chinese messages accompanied by actionable solutions.\n\n### Core Business Logic Flow:\n\n1. **Error Mapping System**: The component maintains a comprehensive `ERROR_MAPPINGS` dictionary containing 24 predefined error scenarios across 7 categories (file system, session, project, LLM, pipeline, memory, and runner errors). Each mapping includes:\n   - `userMessage`: Localized Chinese error description\n   - `solution`: Step-by-step resolution guidance\n   - `severity`: Error severity level (error/warning)\n\n2. **Error Parsing Process**: The `parseError()` function receives a technical error string and performs substring matching against the ERROR_MAPPINGS keys. When a match is found, it returns structured error information; otherwise, it falls back to a generic error message.\n\n3. **User Notification System**: Multiple display functions (`showError`, `showWarning`, `showSuccess`, `showInfo`) utilize Ant Design's message component to render formatted notifications with bold titles and subtle solution hints.\n\n4. **Async Execution Wrapper**: The `tryExecute()` higher-order function wraps async operations with automatic error handling, catching exceptions and displaying user-friendly error messages while logging the original error for debugging.\n\nThe component follows a declarative pattern where error definitions are centralized, making it easy to maintain and extend error handling across the application.",
    "interfaces": [
      {
        "description": "Parses technical error messages and returns structured user-friendly error information with originalError, userMessage, solution, and severity fields",
        "interface_type": "function",
        "name": "parseError",
        "parameters": [
          {
            "description": "The error message from backend to be parsed",
            "is_optional": false,
            "name": "error",
            "param_type": "string"
          }
        ],
        "return_type": "object",
        "visibility": "export"
      },
      {
        "description": "Displays an error notification to the user with the error message and solution, formatted with bold title and subtle solution text",
        "interface_type": "function",
        "name": "showError",
        "parameters": [
          {
            "description": "The error message to display",
            "is_optional": false,
            "name": "error",
            "param_type": "string"
          },
          {
            "description": "Optional custom message to override default userMessage",
            "is_optional": true,
            "name": "customMessage",
            "param_type": "string"
          }
        ],
        "return_type": "void",
        "visibility": "export"
      },
      {
        "description": "Displays a warning notification to the user with the warning message and solution, using shorter duration (3 seconds)",
        "interface_type": "function",
        "name": "showWarning",
        "parameters": [
          {
            "description": "The warning message to display",
            "is_optional": false,
            "name": "warning",
            "param_type": "string"
          }
        ],
        "return_type": "void",
        "visibility": "export"
      },
      {
        "description": "Displays a success notification message to the user with 3-second duration",
        "interface_type": "function",
        "name": "showSuccess",
        "parameters": [
          {
            "description": "The success message to display",
            "is_optional": false,
            "name": "success",
            "param_type": "string"
          }
        ],
        "return_type": "void",
        "visibility": "export"
      },
      {
        "description": "Displays an informational notification message to the user with 3-second duration",
        "interface_type": "function",
        "name": "showInfo",
        "parameters": [
          {
            "description": "The information message to display",
            "is_optional": false,
            "name": "info",
            "param_type": "string"
          }
        ],
        "return_type": "void",
        "visibility": "export"
      },
      {
        "description": "Wraps async function execution with try-catch block, returning result on success or null on error while displaying error notification",
        "interface_type": "function",
        "name": "tryExecute",
        "parameters": [
          {
            "description": "Async function to execute with error handling",
            "is_optional": false,
            "name": "fn",
            "param_type": "Function"
          },
          {
            "description": "Optional custom error message to display on failure",
            "is_optional": true,
            "name": "customErrorMessage",
            "param_type": "string"
          }
        ],
        "return_type": "Promise",
        "visibility": "export"
      }
    ],
    "responsibilities": [
      "Error Translation and Localization: Converting technical backend error messages into user-friendly Chinese messages with actionable resolution guidance",
      "User Notification Management: Providing consistent error, warning, success, and information message display through the UI using Ant Design's message component",
      "Error Recovery Guidance: Offering specific, actionable solutions to help users understand and resolve errors without needing technical expertise",
      "Async Operation Error Handling: Wrapping async function calls with automatic try-catch blocks to prevent unhandled promise rejections and provide graceful error fallback",
      "Centralized Error Configuration: Maintaining a comprehensive error mapping dictionary that serves as the single source of truth for error presentation across the application"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "command",
      "description": null,
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\gui_commands.rs",
      "functions": [
        "init_app_handle",
        "get_iteration_artifacts",
        "get_session_artifacts",
        "read_file_content",
        "read_iteration_file",
        "save_file_content",
        "save_iteration_file",
        "get_file_tree",
        "get_iteration_file_tree",
        "start_preview",
        "stop_preview",
        "start_project",
        "stop_project",
        "start_iteration_preview",
        "stop_iteration_preview",
        "start_iteration_project",
        "stop_iteration_project",
        "execute_project_command",
        "query_memory_index",
        "load_memory_detail",
        "save_session_memory",
        "promote_to_project_memory",
        "get_memory_context",
        "format_code",
        "check_formatter_available",
        "get_templates",
        "export_template",
        "import_template",
        "delete_template",
        "apply_template",
        "get_templates_dir",
        "get_built_in_templates",
        "collect_template_files",
        "replace_template_variables",
        "parse_requirements_from_prd",
        "extract_section"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "gui_commands.rs",
      "source_summary": "// GUI-specific commands for enhanced functionality\nuse super::gui_types::*;\nuse super::gui_types::FileReadResult;\nuse crate::AppState;\nuse crate::preview_server::PreviewServerManager;\nuse crate::project_runner::ProjectRunner;\nuse cowork_core::storage::*;\nuse cowork_core::persistence::IterationStore;\nuse cowork_core::data::{Requirements, DesignSpec, ImplementationPlan};\nuse tauri::{State, Window};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n// Global instances\nlazy_static::lazy_static! {\n    static ref PREVIEW_SERVER_MANAGER: PreviewServerManager = PreviewServerManager::new();\n    static ref PROJECT_RUNNER: ProjectRunner = ProjectRunner::new();\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\npub fn init_app_handle(handle: tauri::AppHandle) {\n    PROJECT_RUNNER.set_app_handle(handle);\n}\n\n// ============================================================================\n// Get Iteration Artifacts (New V2 API)\n// ============================================================================\n\n#[tauri::command]\npub async fn get_iteration_artifacts(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<SessionArtifacts, String> {\n    println!(\"[GUI] Getting artifacts for iteration: {}\", iteration_id);\n\n    let iteration_store = IterationStore::new();\n    let _iteration = iteration_store.load(&iteration_id)\n        .map_err(|e| format!(\"Failed to load iteration: {}\", e))?;\n\n    // Get iteration artifacts directory\n    let iteration_dir = iteration_store.iteration_path(&iteration_id)\n        .map_err(|e| format!(\"Failed to get iteration dir: {}\", e))?;\n    let artifacts_dir = iteration_dir.join(\"artifacts\");\n\n    // Load artifacts from .cowork-v2 structure\n    let idea = fs::read_to_string(artifacts_dir.join(\"idea.md\")).ok();\n    let prd = fs::read_to_string(artifacts_dir.join(\"prd.md\")).ok();\n    let design_raw = fs::read_to_string(artifacts_dir.join(\"design.md\")).ok();\n    let plan_raw = fs::read_to_string(artifacts_dir.join(\"plan.md\")).ok();\n    let delivery_report = fs::read_to_string(artifacts_dir.join(\"delivery_report.md\")).ok();\n    let _check_report = fs::read_to_string(artifacts_dir.join(\"check_report.md\")).ok();\n\n    // Load workspace code files if available\n    let workspace = iteration_store.workspace_path(&iteration_id)\n        .map_err(|e| format!(\"Failed to get workspace: {}\", e))?;\n    let code_files = if workspace.exists() {\n        collect_files(&workspace)\n    } else {\n        vec![]\n    };\n\n    // Parse PRD content into structured requirements\n    let requirements = prd.as_ref().and_then(|content| {\n        use chrono::Utc;\n        \n        let parsed_reqs = parse_requirements_from_prd(content);\n        \n        Some(Requirements {\n            schema_version: \"1.0\".to_string(),\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n            requirements: parsed_reqs,\n        })\n    });\n\n    // Parse design content - return None for now as DesignSpec has complex structure\n    let design: Option<DesignSpec> = None; // TODO: Parse from markdown\n\n    // Parse plan content - return None for now as ImplementationPlan has complex structure\n    let plan: Option<ImplementationPlan> = None; // TODO: Parse from markdown\n\n    Ok(SessionArtifacts {\n        session_id: iteration_id.clone(),\n        idea,\n        requirements,\n        features: None,\n        design,\n        plan,\n        design_raw,\n        plan_raw,\n        code_files,\n        delivery_report,\n    })\n}\n\n// ============================================================================\n// Get Session Artifacts (Legacy - for backward compatibility)\n// ============================================================================\n\n#[tauri::command]\npub async fn get_session_artifacts(\n    session_id: String,\n    window: Window,\n    state: State<'_, AppState>,\n) -> Result<SessionArtifacts, String> {\n    // Try to load as iteration first (V2)\n    let iteration_store = IterationStore::new();\n    if iteration_store.exists(&session_id) {\n        return get_iteration_artifacts(session_id, window, state).await;\n    }\n\n    // Fall back to legacy session-based loading (V1)\n    println!(\"[GUI] Getting artifacts for session (legacy): {}\", session_id);\n\n    let session_dir = get_session_dir(&session_id)\n        .map_err(|e| format!(\"Failed to get session dir: {}\", e))?;\n\n    let code_dir = session_dir.join(\"code\");\n\n    let idea = load_idea(&session_id).ok();\n    let requirements = load_requirements(&session_id).ok();\n    let features = load_feature_list(&session_id).ok();\n    let design = load_design_spec(&session_id).ok();\n    let plan = load_implementation_plan(&session_id).ok();\n\n    let code_files = if code_dir.exists() {\n        collect_files(&code_dir)\n    } else {\n        vec![]\n    };\n\n    let delivery_report = fs::read_to_string(session_dir.join(\"delivery_report.md\")).ok();\n\n    Ok(SessionArtifacts {\n        session_id,\n        idea,\n        requirements,\n        features,\n        design,\n        plan,\n        design_raw: None,\n        plan_raw: None,\n        code_files,\n        delivery_report,\n    })\n}\n\n// ============================================================================\n// File Operations (Iteration-based V2 API)\n// ============================================================================\n\n// Legacy alias for read_iteration_file\n#[tauri::command]\npub async fn read_file_content(\n    session_id: String,\n    file_path: String,\n    offset: Option<usize>,\n    limit: Option<usize>,\n    window: Window,\n    state: State<'_, AppState>,\n) -> Result<FileReadResult, String> {\n    // Delegate to the V2 implementation\n    read_iteration_file(session_id, file_path, offset, limit, window, state).await\n}\n\n#[tauri::command]\npub async fn read_iteration_file(\n    iteration_id: String,\n    file_path: String,\n    offset: Option<usize>,\n    limit: Option<usize>,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<FileReadResult, String> {\n    println!(\"[GUI] Reading file for iteration {}: {}\", iteration_id, file_path);\n\n    let iteration_store = IterationStore::new();\n    let workspace = iteration_store.workspace_path(&iteration_id)\n        .map_err(|e| format!(\"Failed to get workspace: {}\", e))?;\n\n    let full_path = workspace.join(&file_path);\n\n    // Get file metadata\n    let metadata = fs::metadata(&full_path)\n        .map_err(|e| format!(\"Failed to get file metadata: {}\", e))?;\n    \n    let file_size = metadata.len() as usize;\n    const MAX_FILE_SIZE: usize = 10 * 1024 * 1024; // 10MB limit for full read\n\n    // If file is too large or offset/limit specified, read in chunks\n    if file_size > MAX_FILE_SIZE || offset.is_some() || limit.is_some() {\n        let offset = offset.unwrap_or(0);\n        let limit = limit.unwrap_or(1024 * 1024); // Default 1MB chunks\n        \n        let mut file = fs::File::open(&full_path)\n            .map_err(|e| format!(\"Failed to open file: {}\", e))?;\n        \n        use std::io::{Seek, Read};\n        \n        file.seek(std::io::SeekFrom::Start(offset as u64))\n            .map_err(|e| format!(\"Failed to seek in file: {}\", e))?;\n        \n        let mut buffer = vec![0; limit.min(file_size - offset)];\n        let bytes_read = file.read(&mut buffer)\n            .map_err(|e| format!(\"Failed to read file: {}\", e))?;\n        \n        buffer.truncate(bytes_read);\n        \n        let content = String::from_utf8_lossy(&buffer).to_string();\n        \n        Ok(FileReadResult {\n            content,\n            offset: offset as u64,\n            total_size: file_size as u64,\n            is_partial: true,\n        })\n    } else {\n        // Read full file for small files\n        let content = fs::read_to_string(&full_path)\n            .map_err(|e| format!(\"Failed to read file: {}\", e))?;\n        \n        Ok(FileReadResult {\n            content,\n            offset: 0,\n            total_size: file_size as u64,\n            is_partial: false,\n        })\n    }\n}\n\n#[tauri::command]\npub async fn save_file_content(\n    _session_id: String,\n    file_path: String,\n    content: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Saving file: {}\", file_path);\n\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let full_path = project_root.join(&file_path);\n\n    // Create parent directories if needed\n    if let Some(parent) = full_path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| format!(\"Failed to create directories: {}\", e))?;\n    }\n\n    fs::write(&full_path, content)\n        .map_err(|e| format!(\"Failed to write file: {}\", e))?;\n\n    println!(\"[GUI] File saved successfully\");\n    Ok(())\n}\n\n#[tauri::command]\npub async fn save_iteration_file(\n    iteration_id: String,\n    file_path: String,\n    content: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Saving file for iteration {}: {}\", iteration_id, file_path);\n\n    let iteration_store = IterationStore::new();\n    let workspace = iteration_store.workspace_path(&iteration_id)\n        .map_err(|e| format!(\"Failed to get workspace: {}\", e))?;\n\n    let full_path = workspace.join(&file_path);\n\n    // Create parent directories if needed\n    if let Some(parent) = full_path.parent() {\n        fs::create_dir_all(parent)\n            .map_err(|e| format!(\"Failed to create directories: {}\", e))?;\n    }\n\n    fs::write(&full_path, content)\n        .map_err(|e| format!(\"Failed to write file: {}\", e))?;\n\n    println!(\"[GUI] File saved successfully\");\n    Ok(())\n}\n\n// ============================================================================\n// File Tree\n// ============================================================================\n\n#[tauri::command]\npub async fn get_file_tree(\n    session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<FileTreeNode, String> {\n    println!(\"[GUI] Getting file tree for session: {}\", session_id);\n\n    // Use project root directory instead of session code directory\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    if !project_root.exists() {\n        return Ok(FileTreeNode {\n            name: project_root.file_name().unwrap_or(project_root.as_os_str()).to_string_lossy().to_string(),\n            path: \".\".to_string(),\n            is_dir: true,\n            children: Some(vec![]),\n            is_expanded: true,\n            language: None,\n        });\n    }\n\n    build_file_tree(&project_root, &project_root, 0)\n        .map_err(|e| format!(\"Failed to build file tree: {}\", e))\n}\n\n#[tauri::command]\npub async fn get_iteration_file_tree(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<FileTreeNode, String> {\n    println!(\"[GUI] Getting file tree for iteration: {}\", iteration_id);\n\n    let iteration_store = IterationStore::new();\n    let workspace = iteration_store.workspace_path(&iteration_id)\n        .map_err(|e| format!(\"Failed to get workspace: {}\", e))?;\n\n    if !workspace.exists() {\n        return Ok(FileTreeNode {\n            name: workspace.file_name().unwrap_or(workspace.as_os_str()).to_string_lossy().to_string(),\n            path: \".\".to_string(),\n            is_dir: true,\n            children: Some(vec![]),\n            is_expanded: true,\n            language: None,\n        });\n    }\n\n    build_file_tree(&workspace, &workspace, 0)\n        .map_err(|e| format!(\"Failed to build file tree: {}\", e))\n}\n\n// ============================================================================\n// Preview and Run Commands\n// ============================================================================\n\n#[tauri::command]\npub async fn start_preview(\n    session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<PreviewInfo, String> {\n    println!(\"[GUI] Starting preview for session: {}\", session_id);\n\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    if !project_root.exists() {\n        return Err(format!(\"Project directory not found: {}\", project_root.display()));\n    }\n\n    PREVIEW_SERVER_MANAGER.start(session_id, project_root).await\n}\n\n#[tauri::command]\npub async fn stop_preview(\n    session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Stopping preview for session: {}\", session_id);\n    PREVIEW_SERVER_MANAGER.stop(session_id).await\n}\n\n#[tauri::command]\npub async fn start_project(\n    session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<RunInfo, String> {\n    println!(\"[GUI] Starting project for session: {}\", session_id);\n\n    // Use project root directory\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let command = detect_start_command(&project_root)?;\n\n    println!(\"[GUI] Detected start command: {}\", command);\n\n    let command_clone = command.clone();\n    let pid = PROJECT_RUNNER.start(session_id, command).await?;\n\n    Ok(RunInfo {\n        status: RunStatus::Running,\n        process_id: Some(pid),\n        command: Some(command_clone),\n    })\n}\n\n#[tauri::command]\npub async fn stop_project(\n    session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Stopping project for session: {}\", session_id);\n    PROJECT_RUNNER.stop(session_id).await\n}\n\n// ============================================================================\n// Iteration-based Preview and Run Commands (V2 API)\n// ============================================================================\n\n#[tauri::command]\npub async fn start_iteration_preview(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<PreviewInfo, String> {\n    println!(\"[GUI] Starting preview for iteration: {}\", iteration_id);\n\n    // Use project root directory for preview (delivered code location)\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    if !project_root.exists() {\n        return Err(format!(\"Project directory not found: {}\", project_root.display()));\n    }\n\n    PREVIEW_SERVER_MANAGER.start(iteration_id, project_root).await\n}\n\n#[tauri::command]\npub async fn stop_iteration_preview(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Stopping preview for iteration: {}\", iteration_id);\n    PREVIEW_SERVER_MANAGER.stop(iteration_id).await\n}\n\n#[tauri::command]\npub async fn start_iteration_project(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<RunInfo, String> {\n    println!(\"[GUI] Starting project for iteration: {}\", iteration_id);\n\n    // Use project root directory for running (delivered code location)\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let command = detect_start_command(&project_root)?;\n\n    println!(\"[GUI] Detected start command: {}\", command);\n\n    let command_clone = command.clone();\n    let pid = PROJECT_RUNNER.start(iteration_id.clone(), command).await?;\n\n    Ok(RunInfo {\n        status: RunStatus::Running,\n        process_id: Some(pid),\n        command: Some(command_clone),\n    })\n}\n\n#[tauri::command]\npub async fn stop_iteration_project(\n    iteration_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Stopping project for iteration: {}\", iteration_id);\n    PROJECT_RUNNER.stop(iteration_id).await\n}\n\n#[tauri::command]\npub async fn execute_project_command(\n    session_id: String,\n    command: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<CommandResult, String> {\n    println!(\"[GUI] Executing command for session {}: {}\", session_id, command);\n\n    let result = PROJECT_RUNNER.execute_command(session_id, command).await?;\n\n    Ok(CommandResult {\n        status: \"completed\".to_string(),\n        exit_code: Some(0),\n        stdout: result,\n        stderr: String::new(),\n    })\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nfn collect_files(dir: &Path) -> Vec<FileInfo> {\n    let mut files = Vec::new();\n\n    if let Ok(entries) = fs::read_dir(dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            let metadata = entry.metadata().ok();\n\n            if let Some(meta) = metadata {\n                let name = path.file_name()\n                    .unwrap()\n                    .to_string_lossy()\n                    .to_string();\n\n                let relative_path = path.strip_prefix(dir)\n                    .unwrap()\n                    .to_string_lossy()\n                    .to_string();\n\n                let language = detect_language(&name);\n\n                files.push(FileInfo {\n                    path: relative_path,\n                    name,\n                    size: meta.len(),\n                    is_dir: meta.is_dir(),\n                    language,\n                    modified_at: meta.modified()\n                        .ok()\n                        .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())\n                        .map(|d| d.as_secs().to_string()),\n                });\n            }\n        }\n    }\n\n    files\n}\n\nfn build_file_tree(dir: &Path, root: &Path, depth: usize) -> Result<FileTreeNode, String> {\n    let name = dir.file_name()\n        .unwrap()\n        .to_string_lossy()\n        .to_string();\n\n    let path = dir.strip_prefix(root)\n        .unwrap()\n        .to_string_lossy()\n        .to_string();\n\n    let is_dir = dir.is_dir();\n\n    let children = if is_dir && depth < 10 {\n        let mut entries: Vec<_> = fs::read_dir(dir)\n            .map_err(|e| format!(\"Failed to read directory: {}\", e))?\n            .filter_map(|e| e.ok())\n            .collect();\n\n        entries.sort_by(|a, b| {\n            let a_is_dir = a.path().is_dir();\n            let b_is_dir = b.path().is_dir();\n            // Directories first\n            b_is_dir.cmp(&a_is_dir)\n                .then_with(|| a.file_name().cmp(&b.file_name()))\n        });\n\n        Some(entries.into_iter()\n            .filter_map(|entry| {\n                let path = entry.path();\n                let name = path.file_name().unwrap().to_string_lossy().to_string();\n                // Skip hidden files\n                if name.starts_with('.') {\n                    return None;\n                }\n                build_file_tree(&path, root, depth + 1).ok()\n            })\n            .collect())\n    } else {\n        None\n    };\n\n    let language = if !is_dir {\n        detect_language(&name)\n    } else {\n        None\n    };\n\n    Ok(FileTreeNode {\n        name,\n        path,\n        is_dir,\n        children,\n        is_expanded: depth < 3,\n        language,\n    })\n}\n\nfn detect_language(filename: &str) -> Option<String> {\n    let ext = std::path::Path::new(filename)\n        .extension()\n        .and_then(|e| e.to_str())\n        .map(|s| s.to_lowercase());\n\n    match ext.as_deref() {\n        Some(\"rs\") => Some(\"rust\".to_string()),\n        Some(\"js\") | Some(\"jsx\") => Some(\"javascript\".to_string()),\n        Some(\"ts\") | Some(\"tsx\") => Some(\"typescript\".to_string()),\n        Some(\"py\") => Some(\"python\".to_string()),\n        Some(\"html\") => Some(\"html\".to_string()),\n        Some(\"css\") | Some(\"scss\") | Some(\"sass\") => Some(\"css\".to_string()),\n        Some(\"json\") => Some(\"json\".to_string()),\n        Some(\"md\") => Some(\"markdown\".to_string()),\n        Some(\"xml\") => Some(\"xml\".to_string()),\n        Some(\"toml\") => Some(\"toml\".to_string()),\n        Some(\"yaml\") | Some(\"yml\") => Some(\"yaml\".to_string()),\n        _ => None,\n    }\n}\n\n// ============================================================================\n// Project Detection\n// ============================================================================\n\nfn detect_start_command(code_dir: &Path) -> Result<String, String> {\n    let package_json = code_dir.join(\"package.json\");\n    let cargo_toml = code_dir.join(\"Cargo.toml\");\n    let index_html = code_dir.join(\"index.html\");\n\n    // Check for Node.js/React/Vue projects\n    if package_json.exists() {\n        let pkg = fs::read_to_string(&package_json)\n            .map_err(|e| format!(\"Failed to read package.json: {}\", e))?;\n\n        let pkg_json: serde_json::Value = serde_json::from_str(&pkg)\n            .map_err(|e| format!(\"Failed to parse package.json: {}\", e))?;\n\n        // Check for scripts\n        if let Some(scripts) = pkg_json.get(\"scripts\").and_then(|s| s.as_object()) {\n            // Priority: dev -> start -> serve -> build\n            for script_name in &[\"dev\", \"start\", \"serve\", \"build\"] {\n                if scripts.contains_key(*script_name) {\n                    return Ok(format!(\"npm run {}\", script_name));\n                }\n            }\n        }\n    }\n\n    // Check for Rust projects\n    if cargo_toml.exists() {\n        // Check if it's a binary project\n        let cargo_content = fs::read_to_string(&cargo_toml)\n            .map_err(|e| format!(\"Failed to read Cargo.toml: {}\", e))?;\n\n        if cargo_content.contains(\"[[bin]]\") || cargo_content.contains(\"[[lib]]\") {\n            return Ok(\"cargo run\".to_string());\n        }\n    }\n\n    // Check for static HTML\n    if index_html.exists() {\n        return Ok(\"python -m http.server 8000\".to_string());\n    }\n\n    Err(\"Unable to detect project type\".to_string())\n}\n\n// ============================================================================\n// Memory Commands\n// ============================================================================\n\n#[tauri::command]\npub async fn query_memory_index(\n    query_type: String,\n    category: String,\n    stage: Option<String>,\n    limit: i64,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<serde_json::Value, String> {\n    println!(\"[GUI] Querying memory index: query_type={}, category={}, stage={:?}, limit={}\", \n             query_type, category, stage, limit);\n\n    use cowork_core::tools::QueryMemoryIndexTool;\n    use adk_core::Tool;\n\n    let tool = QueryMemoryIndexTool;\n    \n    let args = serde_json::json!({\n        \"query_type\": query_type,\n        \"category\": category,\n        \"stage\": stage,\n        \"limit\": limit\n    });\n\n    // Create a simple tool context - we don't need full context for memory tools\n    // Since our memory tools use _ctx parameter, they don't actually use it\n    let ctx = std::sync::Arc::new(DummyToolContext);\n    \n    tool.execute(ctx, args)\n        .await\n        .map_err(|e| format!(\"Failed to query memory index: {}\", e))\n}\n\n#[tauri::command]\npub async fn load_memory_detail(\n    memory_id: String,\n    file: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<serde_json::Value, String> {\n    println!(\"[GUI] Loading memory detail: memory_id={}, file={}\", memory_id, file);\n\n    use cowork_core::tools::LoadMemoryDetailTool;\n    use adk_core::Tool;\n\n    let tool = LoadMemoryDetailTool;\n    \n    let args = serde_json::json!({\n        \"memory_id\": memory_id,\n        \"file\": file\n    });\n\n    let ctx = std::sync::Arc::new(DummyToolContext);\n    \n    tool.execute(ctx, args)\n        .await\n        .map_err(|e| format!(\"Failed to load memory detail: {}\", e))\n}\n\n#[tauri::command]\npub async fn save_session_memory(\n    memory_type: String,\n    title: String,\n    summary: String,\n    content: String,\n    stage: String,\n    category: Option<String>,\n    impact: Option<String>,\n    tags: Option<Vec<String>>,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<serde_json::Value, String> {\n    println!(\"[GUI] Saving session memory: memory_type={}, title={}\", memory_type, title);\n\n    use cowork_core::tools::SaveSessionMemoryTool;\n    use adk_core::Tool;\n\n    let tool = SaveSessionMemoryTool;\n    \n    let args = serde_json::json!({\n        \"memory_type\": memory_type,\n        \"title\": title,\n        \"summary\": summary,\n        \"content\": content,\n        \"stage\": stage,\n        \"category\": category.unwrap_or(\"general\".to_string()),\n        \"impact\": impact.unwrap_or(\"medium\".to_string()),\n        \"tags\": tags.unwrap_or_default()\n    });\n\n    let ctx = std::sync::Arc::new(DummyToolContext);\n    \n    tool.execute(ctx, args)\n        .await\n        .map_err(|e| format!(\"Failed to save session memory: {}\", e))\n}\n\n#[tauri::command]\npub async fn promote_to_project_memory(\n    memory_id: String,\n    reason: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<serde_json::Value, String> {\n    println!(\"[GUI] Promoting to project memory: memory_id={}, reason={}\", memory_id, reason);\n\n    use cowork_core::tools::PromoteToProjectMemoryTool;\n    use adk_core::Tool;\n\n    let tool = PromoteToProjectMemoryTool;\n    \n    let args = serde_json::json!({\n        \"memory_id\": memory_id,\n        \"reason\": reason\n    });\n\n    let ctx = std::sync::Arc::new(DummyToolContext);\n    \n    tool.execute(ctx, args)\n        .await\n        .map_err(|e| format!(\"Failed to promote to project memory: {}\", e))\n}\n\n#[tauri::command]\npub async fn get_memory_context(\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<serde_json::Value, String> {\n    println!(\"[GUI] Getting memory context\");\n\n    use cowork_core::tools::GetMemoryContextTool;\n    use adk_core::Tool;\n\n    let tool = GetMemoryContextTool;\n    \n    let args = serde_json::json!({});\n\n    let ctx = std::sync::Arc::new(DummyToolContext);\n    \n    tool.execute(ctx, args)\n        .await\n        .map_err(|e| format!(\"Failed to get memory context: {}\", e))\n}\n\n// ============================================================================\n// Dummy Tool Context for GUI Commands\n// ============================================================================\n\nuse adk_core::{ToolContext, CallbackContext, ReadonlyContext, EventActions, AdkError};\n\n/// Dummy tool context used for GUI commands that don't need full tool context\npub struct DummyToolContext;\n\nimpl CallbackContext for DummyToolContext {\n    fn artifacts(&self) -> Option<std::sync::Arc<dyn adk_core::Artifacts>> {\n        None\n    }\n}\n\nimpl ReadonlyContext for DummyToolContext {\n    fn invocation_id(&self) -> &str {\n        \"dummy_invocation\"\n    }\n    \n    fn session_id(&self) -> &str {\n        \"dummy_session\"\n    }\n    \n    fn agent_name(&self) -> &str {\n        \"dummy_agent\"\n    }\n    \n    fn user_id(&self) -> &str {\n        \"dummy_user\"\n    }\n    \n    fn app_name(&self) -> &str {\n        \"cowork_gui\"\n    }\n    \n    fn branch(&self) -> &str {\n        \"main\"\n    }\n    \n    fn user_content(&self) -> &adk_core::Content {\n        use std::sync::OnceLock;\n        static CONTENT: OnceLock<adk_core::Content> = OnceLock::new();\n        CONTENT.get_or_init(|| adk_core::Content::new(\"user\"))\n    }\n}\n\n#[async_trait::async_trait]\nimpl ToolContext for DummyToolContext {\n    fn function_call_id(&self) -> &str {\n        \"dummy\"\n    }\n\n    fn actions(&self) -> EventActions {\n        EventActions::default()\n    }\n\n    fn set_actions(&self, _actions: EventActions) {\n        // No-op\n    }\n\n    async fn search_memory<'life0: 'async_trait, 'life1: 'async_trait>(\n        &'life0 self,\n        _query: &'life1 str,\n    ) -> Result<Vec<adk_core::MemoryEntry>, AdkError> {\n        Ok(vec![])\n    }\n}\n\n// ============================================================================\n// Code Formatting Commands\n// ============================================================================\n\n#[tauri::command]\npub async fn format_code(\n    _session_id: String,\n    _file_path: Option<String>,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<FormatResult, String> {\n    println!(\"[GUI] Formatting code in project root\");\n\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let code_dir = &project_root;\n    \n    if !code_dir.exists() {\n        return Err(\"Project directory not found\".to_string());\n    }\n\n    // Detect project type and run appropriate formatter\n    let package_json = code_dir.join(\"package.json\");\n    let cargo_toml = code_dir.join(\"Cargo.toml\");\n\n    let mut formatted_files = Vec::new();\n    let mut errors = Vec::new();\n\n    // Check for Prettier (JavaScript/TypeScript)\n    if package_json.exists() {\n        // Try to run prettier\n        let output = tokio::process::Command::new(\"npx\")\n            .args([\"prettier\", \"--write\", \".\"])\n            .current_dir(&code_dir)\n            .output()\n            .await;\n\n        match output {\n            Ok(output) => {\n                let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n                let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n                \n                if output.status.success() {\n                    // Parse formatted files from output\n                    for line in stdout.lines() {\n                        if line.trim().len() > 0 {\n                            formatted_files.push(line.to_string());\n                        }\n                    }\n                } else {\n                    errors.push(format!(\"Prettier failed: {}\", stderr));\n                }\n            }\n            Err(e) => {\n                errors.push(format!(\"Failed to run prettier: {}\", e));\n            }\n        }\n    }\n\n    // Check for rustfmt (Rust)\n    if cargo_toml.exists() {\n        let output = tokio::process::Command::new(\"cargo\")\n            .args([\"fmt\"])\n            .current_dir(&code_dir)\n            .output()\n            .await;\n\n        match output {\n            Ok(output) => {\n                let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n                \n                if output.status.success() {\n                    // rustfmt doesn't output formatted files by default\n                    formatted_files.push(\"All Rust files formatted\".to_string());\n                } else {\n                    errors.push(format!(\"rustfmt failed: {}\", stdout));\n                }\n            }\n            Err(e) => {\n                errors.push(format!(\"Failed to run rustfmt: {}\", e));\n            }\n        }\n    }\n\n    // If no formatter found\n    if formatted_files.is_empty() && errors.is_empty() {\n        return Err(\"No supported formatter found for this project type\".to_string());\n    }\n\n    let success = errors.is_empty();\n    Ok(FormatResult {\n        formatted_files,\n        errors,\n        success,\n    })\n}\n\n#[tauri::command]\npub async fn check_formatter_available(\n    _session_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<FormatterAvailability, String> {\n    println!(\"[GUI] Checking formatter availability in project root\");\n\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let code_dir = &project_root;\n    \n    let mut prettier_available = false;\n    let mut rustfmt_available = false;\n\n    // Check for Prettier\n    let package_json = code_dir.join(\"package.json\");\n    if package_json.exists() {\n        let output = tokio::process::Command::new(\"npx\")\n            .args([\"prettier\", \"--version\"])\n            .output()\n            .await;\n\n        prettier_available = output.is_ok() && output.unwrap().status.success();\n    }\n\n    // Check for rustfmt\n    let cargo_toml = code_dir.join(\"Cargo.toml\");\n    if cargo_toml.exists() {\n        let output = tokio::process::Command::new(\"cargo\")\n            .args([\"fmt\", \"--version\"])\n            .output()\n            .await;\n\n        rustfmt_available = output.is_ok() && output.unwrap().status.success();\n    }\n\n    Ok(FormatterAvailability {\n        prettier: prettier_available,\n        rustfmt: rustfmt_available,\n    })\n}\n\n// ============================================================================\n// Project Template Commands\n// ============================================================================\n\n#[tauri::command]\npub async fn get_templates(\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<Vec<ProjectTemplate>, String> {\n    println!(\"[GUI] Getting templates\");\n\n    // Get templates directory\n    let templates_dir = get_templates_dir()?;\n    \n    if !templates_dir.exists() {\n        return Ok(vec![]);\n    }\n\n    let mut templates = Vec::new();\n\n    // Read built-in templates\n    let built_in_templates = get_built_in_templates();\n    templates.extend(built_in_templates);\n\n    // Read custom templates\n    if let Ok(entries) = fs::read_dir(&templates_dir) {\n        for entry in entries.flatten() {\n            if let Ok(meta) = entry.metadata() {\n                if meta.is_file() {\n                    let path = entry.path();\n                    if path.extension().and_then(|e| e.to_str()) == Some(\"json\") {\n                        if let Ok(content) = fs::read_to_string(&path) {\n                            if let Ok(template) = serde_json::from_str::<ProjectTemplate>(&content) {\n                                templates.push(template);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(templates)\n}\n\n#[tauri::command]\npub async fn export_template(\n    _session_id: String,\n    name: String,\n    description: String,\n    category: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<ProjectTemplate, String> {\n    println!(\"[GUI] Exporting template from project root\");\n\n    let project_root = cowork_core::storage::get_project_root()\n        .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n    let code_dir = &project_root;\n    \n    if !code_dir.exists() {\n        return Err(\"Project directory not found\".to_string());\n    }\n\n    // Collect all files\n    let mut files = Vec::new();\n    collect_template_files(&code_dir, &mut files)?;\n\n    // Create template\n    let template_id = format!(\"template-{}\", chrono::Utc::now().timestamp_millis());\n    let template = ProjectTemplate {\n        id: template_id.clone(),\n        name,\n        description,\n        category,\n        technology_stack: vec![], // TODO: detect from files\n        created_at: chrono::Utc::now().to_rfc3339(),\n        updated_at: chrono::Utc::now().to_rfc3339(),\n        is_built_in: false,\n        files,\n        config: TemplateConfig {\n            variables: vec![],\n            post_creation_commands: vec![],\n        },\n    };\n\n    // Save template\n    let templates_dir = get_templates_dir()?;\n    fs::create_dir_all(&templates_dir)\n        .map_err(|e| format!(\"Failed to create templates directory: {}\", e))?;\n\n    let template_file = templates_dir.join(format!(\"{}.json\", template_id));\n    fs::write(&template_file, serde_json::to_string_pretty(&template).unwrap())\n        .map_err(|e| format!(\"Failed to save template: {}\", e))?;\n\n    Ok(template)\n}\n\n#[tauri::command]\npub async fn import_template(\n    template_data: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<ProjectTemplate, String> {\n    println!(\"[GUI] Importing template\");\n\n    let template: ProjectTemplate = serde_json::from_str(&template_data)\n        .map_err(|e| format!(\"Failed to parse template data: {}\", e))?;\n\n    // Validate template\n    if template.id.is_empty() || template.name.is_empty() {\n        return Err(\"Invalid template: missing id or name\".to_string());\n    }\n\n    // Save template\n    let templates_dir = get_templates_dir()?;\n    fs::create_dir_all(&templates_dir)\n        .map_err(|e| format!(\"Failed to create templates directory: {}\", e))?;\n\n    let template_file = templates_dir.join(format!(\"{}.json\", template.id));\n    fs::write(&template_file, serde_json::to_string_pretty(&template).unwrap())\n        .map_err(|e| format!(\"Failed to save template: {}\", e))?;\n\n    Ok(template)\n}\n\n#[tauri::command]\npub async fn delete_template(\n    template_id: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<(), String> {\n    println!(\"[GUI] Deleting template: {}\", template_id);\n\n    let templates_dir = get_templates_dir()?;\n    let template_file = templates_dir.join(format!(\"{}.json\", template_id));\n\n    if !template_file.exists() {\n        return Err(\"Template not found\".to_string());\n    }\n\n    fs::remove_file(&template_file)\n        .map_err(|e| format!(\"Failed to delete template: {}\", e))?;\n\n    Ok(())\n}\n\n#[tauri::command]\npub async fn apply_template(\n    template_id: String,\n    variables: serde_json::Value,\n    target_dir: String,\n    _window: Window,\n    _state: State<'_, AppState>,\n) -> Result<Vec<String>, String> {\n    println!(\"[GUI] Applying template: {} to {}\", template_id, target_dir);\n\n    // Get template\n    let templates_dir = get_templates_dir()?;\n    let template_file = templates_dir.join(format!(\"{}.json\", template_id));\n\n    if !template_file.exists() {\n        return Err(\"Template not found\".to_string());\n    }\n\n    let template_content = fs::read_to_string(&template_file)\n        .map_err(|e| format!(\"Failed to read template: {}\", e))?;\n\n    let template: ProjectTemplate = serde_json::from_str(&template_content)\n        .map_err(|e| format!(\"Failed to parse template: {}\", e))?;\n\n    // Create target directory\n    let target_path = Path::new(&target_dir);\n    fs::create_dir_all(target_path)\n        .map_err(|e| format!(\"Failed to create target directory: {}\", e))?;\n\n    // Apply template files\n    let mut created_files = Vec::new();\n    for file in &template.files {\n        let file_path = target_path.join(&file.path);\n        \n        // Create parent directories\n        if let Some(parent) = file_path.parent() {\n            fs::create_dir_all(parent)\n                .map_err(|e| format!(\"Failed to create directory: {}\", e))?;\n        }\n\n        // Replace variables in content\n        let content = replace_template_variables(&file.content, &variables, &template.config.variables);\n\n        // Write file\n        fs::write(&file_path, content)\n            .map_err(|e| format!(\"Failed to write file {}: {}\", file.path, e))?;\n\n        created_files.push(file.path.clone());\n    }\n\n    Ok(created_files)\n}\n\n// ============================================================================\n// Template Helper Functions\n// ============================================================================\n\nfn get_templates_dir() -> Result<PathBuf, String> {\n    let config_dir = dirs::config_dir()\n        .ok_or(\"Failed to get config directory\")?;\n    \n    let templates_dir = config_dir.join(\"CoworkCreative\").join(\"templates\");\n    Ok(templates_dir)\n}\n\nfn get_built_in_templates() -> Vec<ProjectTemplate> {\n    // Return built-in templates\n    vec![\n        ProjectTemplate {\n            id: \"react-basic\".to_string(),\n            name: \"React Basic\".to_string(),\n            description: \"Basic React project structure\".to_string(),\n            category: \"Frontend\".to_string(),\n            technology_stack: vec![\"React\".to_string(), \"JavaScript\".to_string()],\n            created_at: chrono::Utc::now().to_rfc3339(),\n            updated_at: chrono::Utc::now().to_rfc3339(),\n            is_built_in: true,\n            files: vec![],\n            config: TemplateConfig {\n                variables: vec![],\n                post_creation_commands: vec![\"npm install\".to_string()],\n            },\n        },\n        ProjectTemplate {\n            id: \"rust-cli\".to_string(),\n            name: \"Rust CLI\".to_string(),\n            description: \"Basic Rust CLI project structure\".to_string(),\n            category: \"Backend\".to_string(),\n            technology_stack: vec![\"Rust\".to_string()],\n            created_at: chrono::Utc::now().to_rfc3339(),\n            updated_at: chrono::Utc::now().to_rfc3339(),\n            is_built_in: true,\n            files: vec![],\n            config: TemplateConfig {\n                variables: vec![],\n                post_creation_commands: vec![\"cargo build\".to_string()],\n            },\n        },\n    ]\n}\n\nfn collect_template_files(dir: &Path, files: &mut Vec<TemplateFile>) -> Result<(), String> {\n    if let Ok(entries) = fs::read_dir(dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if let Ok(meta) = entry.metadata() {\n                if meta.is_file() {\n                    if let Ok(content) = fs::read_to_string(&path) {\n                        let relative_path = path.strip_prefix(dir)\n                            .map_err(|e| format!(\"Failed to get relative path: {}\", e))?\n                            .to_string_lossy()\n                            .to_string();\n                        \n                        files.push(TemplateFile {\n                            path: relative_path,\n                            content,\n                            is_template: true,\n                        });\n                    }\n                } else if meta.is_dir() {\n                    collect_template_files(&path, files)?;\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\nfn replace_template_variables(content: &str, variables: &serde_json::Value, config_vars: &[TemplateVariable]) -> String {\n    let mut result = content.to_string();\n    \n    // Replace variables\n    for var in config_vars {\n        let placeholder = format!(\"{{{{{}}}}}\", var.name);\n        let value = variables.get(&var.name)\n            .and_then(|v| v.as_str())\n            .unwrap_or(&var.default_value);\n        result = result.replace(&placeholder, value);\n    }\n    \n    result\n}\n\n// ============================================================================\n// PRD Parsing Helper Functions\n// ============================================================================\n\nuse cowork_core::data::{Requirement, Priority, RequirementCategory};\n\n/// Parse requirements from PRD markdown content\nfn parse_requirements_from_prd(content: &str) -> Vec<Requirement> {\n    let mut requirements = Vec::new();\n    let mut req_id_counter = 1;\n    \n    // Parse functional requirements section\n    if let Some(func_section) = extract_section(content, \"Functional Requirements\", \"Non-Functional\") {\n        for line in func_section.lines() {\n            let line = line.trim();\n            if line.starts_with('-') || line.starts_with(\"*\") || \n               (line.len() > 3 && line.chars().nth(0).map(|c| c.is_numeric()).unwrap_or(false)) {\n                // Extract requirement text\n                let text = line.trim_start_matches(|c: char| !c.is_alphabetic())\n                    .trim_start_matches(\"-\")\n                    .trim_start_matches(\"*\")\n                    .trim_start_matches(|c: char| c.is_numeric() || c == '.' || c == ')')\n                    .trim();\n                \n                if !text.is_empty() {\n                    let (title, description) = if text.contains(':') {\n                        let parts: Vec<&str> = text.splitn(2, ':').collect();\n                        (parts[0].trim().to_string(), parts[1].trim().to_string())\n                    } else if text.len() > 100 {\n                        // Long text - use first sentence as title\n                        let first_sentence = text.split('.').next().unwrap_or(&text);\n                        (first_sentence.to_string() + \".\", text.to_string())\n                    } else {\n                        (text.to_string(), String::new())\n                    };\n                    \n                    requirements.push(Requirement {\n                        id: format!(\"REQ-{:03}\", req_id_counter),\n                        title,\n                        description,\n                        priority: Priority::High,\n                        category: RequirementCategory::Functional,\n                        acceptance_criteria: vec![],\n                        related_features: vec![],\n                    });\n                    req_id_counter += 1;\n                }\n            }\n        }\n    }\n    \n    // Parse non-functional requirements section\n    if let Some(non_func_section) = extract_section(content, \"Non-Functional Requirements\", \"UI/UX\") {\n        for line in non_func_section.lines() {\n            let line = line.trim();\n            if line.starts_with('-') || line.starts_with(\"*\") || \n               (line.len() > 3 && line.chars().nth(0).map(|c| c.is_numeric()).unwrap_or(false)) {\n                let text = line.trim_start_matches(|c: char| !c.is_alphabetic())\n                    .trim_start_matches(\"-\")\n                    .trim_start_matches(\"*\")\n                    .trim_start_matches(|c: char| c.is_numeric() || c == '.' || c == ')')\n                    .trim();\n                \n                if !text.is_empty() {\n                    let (title, description) = if text.contains(':') {\n                        let parts: Vec<&str> = text.splitn(2, ':').collect();\n                        (parts[0].trim().to_string(), parts[1].trim().to_string())\n                    } else if text.len() > 100 {\n                        let first_sentence = text.split('.').next().unwrap_or(&text);\n                        (first_sentence.to_string() + \".\", text.to_string())\n                    } else {\n                        (text.to_string(), String::new())\n                    };\n                    \n                    requirements.push(Requirement {\n                        id: format!(\"REQ-{:03}\", req_id_counter),\n                        title,\n                        description,\n                        priority: Priority::Medium,\n                        category: RequirementCategory::NonFunctional,\n                        acceptance_criteria: vec![],\n                        related_features: vec![],\n                    });\n                    req_id_counter += 1;\n                }\n            }\n        }\n    }\n    \n    // If no structured requirements found, extract from user stories section\n    if requirements.is_empty() {\n        if let Some(stories_section) = extract_section(content, \"User Stories\", \"Functional\") {\n            for line in stories_section.lines() {\n                let line = line.trim();\n                if line.to_lowercase().starts_with(\"as a\") || \n                   line.to_lowercase().starts_with(\"- as a\") ||\n                   line.to_lowercase().starts_with(\"* as a\") {\n                    let text = line.trim_start_matches(\"-\").trim_start_matches(\"*\").trim();\n                    if !text.is_empty() {\n                        requirements.push(Requirement {\n                            id: format!(\"REQ-{:03}\", req_id_counter),\n                            title: text.chars().take(80).collect::<String>() + \"...\",\n                            description: text.to_string(),\n                            priority: Priority::High,\n                            category: RequirementCategory::Functional,\n                            acceptance_criteria: vec![],\n                            related_features: vec![],\n                        });\n                        req_id_counter += 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    // If still empty, create a single requirement from PRD summary\n    if requirements.is_empty() {\n        // Extract overview/goals section as a requirement\n        let summary = content.lines()\n            .take(10)\n            .filter(|l| !l.starts_with('#') && !l.trim().is_empty())\n            .take(3)\n            .collect::<Vec<_>>()\n            .join(\" \");\n        \n        if !summary.is_empty() {\n            requirements.push(Requirement {\n                id: \"REQ-001\".to_string(),\n                title: \"PRD Requirements\".to_string(),\n                description: summary,\n                priority: Priority::High,\n                category: RequirementCategory::Functional,\n                acceptance_criteria: vec![],\n                related_features: vec![],\n            });\n        }\n    }\n    \n    requirements\n}\n\n/// Extract a section from markdown content\nfn extract_section(content: &str, section_start: &str, section_end: &str) -> Option<String> {\n    let lines: Vec<&str> = content.lines().collect();\n    let mut in_section = false;\n    let mut section_lines = Vec::new();\n    \n    for line in &lines {\n        let line_lower = line.to_lowercase();\n        \n        // Check for section start\n        if line_lower.contains(&section_start.to_lowercase()) && \n           (line.starts_with(\"#\") || line.starts_with(\"**\")) {\n            in_section = true;\n            continue;\n        }\n        \n        // Check for section end\n        if in_section && \n           (line_lower.contains(&section_end.to_lowercase()) ||\n            line.starts_with(\"# \") || \n            line.starts_with(\"## \")) &&\n           !line_lower.contains(&section_start.to_lowercase()) {\n            break;\n        }\n        \n        if in_section {\n            section_lines.push(*line);\n        }\n    }\n    \n    if section_lines.is_empty() {\n        None\n    } else {\n        Some(section_lines.join(\"\\n\"))\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 127.0,
      "lines_of_code": 1502,
      "number_of_classes": 0,
      "number_of_functions": 35
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "tauri",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "cowork_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "lazy_static",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "dirs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "adk_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component implements GUI-specific command handlers for a Tauri-based application, serving as the bridge between the frontend UI and backend systems. It provides comprehensive functionality for managing project iterations, file operations, preview and execution of projects, memory management, code formatting, and template handling. The component supports both legacy (V1) and modern (V2) API versions, enabling backward compatibility while promoting newer iteration-based workflows. Key responsibilities include reading and writing files in project workspaces, building file trees, detecting project types and start commands, executing external tools (npm, cargo), managing preview servers and project runners, interfacing with memory tools for AI-assisted development, and handling project templates for code generation. The component is structured around Tauri's command system, exposing async Rust functions that can be invoked from the frontend JavaScript layer.",
    "interfaces": [],
    "responsibilities": [
      "Manage iteration and session artifacts (V1/V2 API)",
      "Handle file operations (read, write, tree navigation)",
      "Control project preview and execution environments",
      "Integrate with AI memory tools for context management",
      "Provide template-based project generation and customization"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": null,
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\gui_types.rs",
      "functions": [],
      "importance_score": 0.8,
      "interfaces": [
        "SessionArtifacts",
        "FileInfo",
        "PreviewInfo",
        "PreviewStatus",
        "ProjectType",
        "RunInfo",
        "RunStatus",
        "CommandResult",
        "FileTreeNode",
        "FileReadResult",
        "FormatResult",
        "FormatterAvailability",
        "ProjectTemplate",
        "TemplateFile",
        "TemplateConfig",
        "TemplateVariable",
        "ProjectInfo"
      ],
      "name": "gui_types.rs",
      "source_summary": "// GUI-specific data types for enhanced functionality\nuse serde::{Deserialize, Serialize};\nuse cowork_core::data::{Requirements, FeatureList, DesignSpec, ImplementationPlan};\n\n// ============================================================================\n// Session Artifacts\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionArtifacts {\n    pub session_id: String,\n    pub idea: Option<String>,\n    pub requirements: Option<Requirements>,\n    pub features: Option<FeatureList>,\n    pub design: Option<DesignSpec>,\n    pub plan: Option<ImplementationPlan>,\n    // Raw markdown content for display\n    pub design_raw: Option<String>,\n    pub plan_raw: Option<String>,\n    pub code_files: Vec<FileInfo>,\n    pub delivery_report: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileInfo {\n    pub path: String,\n    pub name: String,\n    pub size: u64,\n    pub is_dir: bool,\n    pub language: Option<String>,\n    pub modified_at: Option<String>,\n}\n\n// ============================================================================\n// Preview\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PreviewInfo {\n    pub url: String,\n    pub port: u16,\n    pub status: PreviewStatus,\n    pub project_type: ProjectType,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PreviewStatus {\n    Running,\n    Stopped,\n    Error(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProjectType {\n    Html,\n    React,\n    Vue,\n    Angular,\n    Static,\n    Unknown,\n}\n\n// ============================================================================\n// Project Runner\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RunInfo {\n    pub status: RunStatus,\n    pub process_id: Option<u32>,\n    pub command: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum RunStatus {\n    Running,\n    Stopped,\n    Failed(String),\n    Success,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommandResult {\n    pub status: String,\n    pub exit_code: Option<i32>,\n    pub stdout: String,\n    pub stderr: String,\n}\n\n// ============================================================================\n// File Tree\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileTreeNode {\n    pub name: String,\n    pub path: String,\n    pub is_dir: bool,\n    pub children: Option<Vec<FileTreeNode>>,\n    pub is_expanded: bool,\n    pub language: Option<String>,\n}\n\n// ============================================================================\n// File Operations\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileReadResult {\n    pub content: String,\n    pub offset: u64,\n    pub total_size: u64,\n    pub is_partial: bool,\n}\n\n// ============================================================================\n// Code Formatting\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FormatResult {\n    pub formatted_files: Vec<String>,\n    pub errors: Vec<String>,\n    pub success: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FormatterAvailability {\n    pub prettier: bool,\n    pub rustfmt: bool,\n}\n\n// ============================================================================\n// Project Templates\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectTemplate {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub category: String,\n    pub technology_stack: Vec<String>,\n    pub created_at: String,\n    pub updated_at: String,\n    pub is_built_in: bool,\n    pub files: Vec<TemplateFile>,\n    pub config: TemplateConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateFile {\n    pub path: String,\n    pub content: String,\n    pub is_template: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateConfig {\n    pub variables: Vec<TemplateVariable>,\n    pub post_creation_commands: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TemplateVariable {\n    pub name: String,\n    pub description: String,\n    pub default_value: String,\n    pub required: bool,\n}\n\n// ============================================================================\n// Project Detection\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectInfo {\n    pub project_type: ProjectType,\n    pub start_command: Option<String>,\n    pub build_command: Option<String>,\n    pub preview_command: Option<String>,\n    pub has_index_html: bool,\n    pub has_package_json: bool,\n    pub has_cargo_toml: bool,\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 3.0,
      "lines_of_code": 188,
      "number_of_classes": 17,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "cowork_core",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component defines a comprehensive set of data models (structs and enums) used for GUI-level representation of application state and operations in a Tauri-based Rust application. It serializes/deserializes data between the frontend and backend, covering session artifacts, project previews, file trees, code formatting results, project templates, and project detection metadata. All types are annotated with Serialize/Deserialize for JSON interoperability and are designed for clarity and type safety.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "struct",
        "name": "SessionArtifacts",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "idea",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "requirements",
            "param_type": "Option<Requirements>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "features",
            "param_type": "Option<FeatureList>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "design",
            "param_type": "Option<DesignSpec>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "plan",
            "param_type": "Option<ImplementationPlan>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "design_raw",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "plan_raw",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "code_files",
            "param_type": "Vec<FileInfo>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "delivery_report",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "size",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_dir",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "language",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "modified_at",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "PreviewInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "url",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "port",
            "param_type": "u16"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "PreviewStatus"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project_type",
            "param_type": "ProjectType"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "PreviewStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "ProjectType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "RunInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "RunStatus"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "process_id",
            "param_type": "Option<u32>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "command",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "RunStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "CommandResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "exit_code",
            "param_type": "Option<i32>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stdout",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stderr",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileTreeNode",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_dir",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "children",
            "param_type": "Option<Vec<FileTreeNode>>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_expanded",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "language",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileReadResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "offset",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_size",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_partial",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FormatResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "formatted_files",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "errors",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "success",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FormatterAvailability",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "prettier",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "rustfmt",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ProjectTemplate",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "category",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "technology_stack",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "updated_at",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_built_in",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "files",
            "param_type": "Vec<TemplateFile>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "config",
            "param_type": "TemplateConfig"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateFile",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_template",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "variables",
            "param_type": "Vec<TemplateVariable>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "post_creation_commands",
            "param_type": "Vec<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateVariable",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "default_value",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "required",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ProjectInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "project_type",
            "param_type": "ProjectType"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "start_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "build_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "preview_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_index_html",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_package_json",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_cargo_toml",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Define serialized data structures for GUI-state synchronization",
      "Model project metadata and configuration for frontend consumption",
      "Represent file system and code structure for UI rendering",
      "Encapsulate execution status and command results for UI feedback",
      "Standardize template and project type definitions across frontend and backend"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "command",
      "description": null,
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\iteration_commands.rs",
      "functions": [
        "gui_init_project",
        "gui_get_project",
        "gui_delete_project",
        "gui_create_iteration",
        "gui_get_iterations",
        "gui_get_iteration",
        "gui_execute_iteration",
        "gui_continue_iteration",
        "gui_delete_iteration",
        "project_to_info",
        "iteration_to_info"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "gui_init_project",
        "gui_get_project",
        "gui_delete_project",
        "gui_create_iteration",
        "gui_get_iterations",
        "gui_get_iteration",
        "gui_execute_iteration",
        "gui_continue_iteration",
        "gui_delete_iteration"
      ],
      "name": "iteration_commands.rs",
      "source_summary": "// Iteration Commands - New iteration-based architecture for GUI\r\n\r\nuse crate::AppState;\r\nuse crate::TauriBackend;\r\nuse cowork_core::domain::{Iteration, InheritanceMode, Project};\r\nuse cowork_core::persistence::{IterationStore, ProjectStore};\r\nuse cowork_core::pipeline::IterationExecutor;\r\nuse tauri::{Emitter, Manager, State, Window};\r\nuse std::sync::Arc;\r\nuse serde::{Serialize, Deserialize};\r\n\r\n// ============================================================================\r\n// Types\r\n// ============================================================================\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct IterationInfo {\r\n    pub id: String,\r\n    pub number: u32,\r\n    pub title: String,\r\n    pub description: String,\r\n    pub status: String,\r\n    pub current_stage: Option<String>,\r\n    pub completed_stages: Vec<String>,\r\n    pub base_iteration_id: Option<String>,\r\n    pub inheritance: String,\r\n    pub created_at: String,\r\n    pub completed_at: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct ProjectInfo {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub created_at: String,\r\n    pub updated_at: String,\r\n    pub current_iteration_id: Option<String>,\r\n    pub iteration_count: usize,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct CreateIterationRequest {\r\n    pub title: String,\r\n    pub description: String,\r\n    pub base_iteration_id: Option<String>,\r\n    pub inheritance: String,\r\n}\r\n\r\n// ============================================================================\r\n// Project Commands\r\n// ============================================================================\r\n\r\n#[tauri::command]\r\npub async fn gui_init_project(\r\n    name: String,\r\n    window: Window,\r\n) -> Result<ProjectInfo, String> {\r\n    let store = ProjectStore::new();\r\n\r\n    if store.exists() {\r\n        let project = store.load().map_err(|e| e.to_string())?.unwrap();\r\n        return Ok(project_to_info(&project));\r\n    }\r\n\r\n    let project = store.create(&name).map_err(|e| e.to_string())?;\r\n\r\n    // Emit event\r\n    let _ = window.emit(\"project_initialized\", ());\r\n\r\n    Ok(project_to_info(&project))\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_get_project() -> Result<Option<ProjectInfo>, String> {\r\n    let store = ProjectStore::new();\r\n\r\n    match store.load().map_err(|e| e.to_string())? {\r\n        Some(project) => Ok(Some(project_to_info(&project))),\r\n        None => Ok(None),\r\n    }\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_delete_project(\r\n    confirm: bool,\r\n) -> Result<(), String> {\r\n    if !confirm {\r\n        return Err(\"Deletion not confirmed\".to_string());\r\n    }\r\n\r\n    use std::fs;\r\n    use cowork_core::persistence::get_cowork_dir;\r\n\r\n    let cow_dir = get_cowork_dir().map_err(|e| e.to_string())?;\r\n    if cow_dir.exists() {\r\n        fs::remove_dir_all(&cow_dir).map_err(|e| e.to_string())?;\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Iteration Commands\r\n// ============================================================================\r\n\r\n#[tauri::command]\r\npub async fn gui_create_iteration(\r\n    request: CreateIterationRequest,\r\n    window: Window,\r\n    _state: State<'_, AppState>,\r\n) -> Result<IterationInfo, String> {\r\n    let project_store = ProjectStore::new();\r\n    let iteration_store = IterationStore::new();\r\n\r\n    let mut project = project_store.load().map_err(|e| e.to_string())?\r\n        .ok_or_else(|| \"Project not initialized\".to_string())?;\r\n\r\n    // Determine inheritance mode\r\n    let inheritance = match request.inheritance.as_str() {\r\n        \"none\" => InheritanceMode::None,\r\n        \"partial\" => InheritanceMode::Partial,\r\n        _ => InheritanceMode::Full,\r\n    };\r\n\r\n    // Create iteration\r\n    let iteration = if let Some(base_id) = request.base_iteration_id {\r\n        Iteration::create_evolution(\r\n            &project,\r\n            request.title,\r\n            request.description,\r\n            base_id,\r\n            inheritance,\r\n        )\r\n    } else {\r\n        Iteration::create_genesis(\r\n            &project,\r\n            request.title,\r\n            request.description,\r\n        )\r\n    };\r\n\r\n    // Save iteration\r\n    iteration_store.save(&iteration).map_err(|e| e.to_string())?;\r\n    project_store.add_iteration(&mut project, iteration.to_summary()).map_err(|e| e.to_string())?;\r\n\r\n    // Emit event\r\n    let _ = window.emit(\"iteration_created\", iteration.id.clone());\r\n\r\n    Ok(iteration_to_info(&iteration))\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_get_iterations() -> Result<Vec<IterationInfo>, String> {\r\n    let store = IterationStore::new();\r\n\r\n    let iterations = store.load_all().map_err(|e| e.to_string())?;\r\n    Ok(iterations.iter().map(iteration_to_info).collect())\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_get_iteration(\r\n    iteration_id: String,\r\n) -> Result<IterationInfo, String> {\r\n    let store = IterationStore::new();\r\n\r\n    let iteration = store.load(&iteration_id).map_err(|e| e.to_string())?;\r\n    Ok(iteration_to_info(&iteration))\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_execute_iteration(\r\n    iteration_id: String,\r\n    window: Window,\r\n    state: State<'_, AppState>,\r\n) -> Result<(), String> {\r\n    let project_store = ProjectStore::new();\r\n\r\n    let mut project = project_store.load().map_err(|e| e.to_string())?\r\n        .ok_or_else(|| \"Project not initialized\".to_string())?;\r\n\r\n    // Create interaction backend\r\n    let interaction = Arc::new(TauriBackend::new(\r\n        window.app_handle().clone(),\r\n        state.event_bus.clone(),\r\n        state.pending_requests.clone(),\r\n    ));\r\n\r\n    let executor = IterationExecutor::new(interaction);\r\n\r\n    // Emit started event\r\n    let _ = window.emit(\"iteration_started\", iteration_id.clone());\r\n\r\n    // Execute in background\r\n    let window_clone = window.app_handle().clone();\r\n    let iteration_id_clone = iteration_id.clone();\r\n\r\n    tokio::spawn(async move {\r\n        match executor.execute(&mut project, &iteration_id_clone).await {\r\n            Ok(_) => {\r\n                let _ = window_clone.emit(\"iteration_completed\", iteration_id_clone);\r\n            }\r\n            Err(e) => {\r\n                let _ = window_clone.emit(\"iteration_failed\", (iteration_id_clone, e.to_string()));\r\n            }\r\n        }\r\n    });\r\n\r\n    Ok(())\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_continue_iteration(\r\n    iteration_id: String,\r\n    window: Window,\r\n    state: State<'_, AppState>,\r\n) -> Result<(), String> {\r\n    let project_store = ProjectStore::new();\r\n\r\n    let mut project = project_store.load().map_err(|e| e.to_string())?\r\n        .ok_or_else(|| \"Project not initialized\".to_string())?;\r\n\r\n    // Create interaction backend\r\n    let interaction = Arc::new(TauriBackend::new(\r\n        window.app_handle().clone(),\r\n        state.event_bus.clone(),\r\n        state.pending_requests.clone(),\r\n    ));\r\n\r\n    let executor = IterationExecutor::new(interaction);\r\n\r\n    // Emit started event\r\n    let _ = window.emit(\"iteration_continued\", iteration_id.clone());\r\n\r\n    // Execute in background\r\n    let window_clone = window.app_handle().clone();\r\n    let iteration_id_clone = iteration_id.clone();\r\n\r\n    tokio::spawn(async move {\r\n        match executor.continue_iteration(&mut project, &iteration_id_clone).await {\r\n            Ok(_) => {\r\n                let _ = window_clone.emit(\"iteration_completed\", iteration_id_clone);\r\n            }\r\n            Err(e) => {\r\n                let _ = window_clone.emit(\"iteration_failed\", (iteration_id_clone, e.to_string()));\r\n            }\r\n        }\r\n    });\r\n\r\n    Ok(())\r\n}\r\n\r\n#[tauri::command]\r\npub async fn gui_delete_iteration(\r\n    iteration_id: String,\r\n    window: Window,\r\n) -> Result<(), String> {\r\n    let iteration_store = IterationStore::new();\r\n    let project_store = ProjectStore::new();\r\n\r\n    // Delete iteration\r\n    iteration_store.delete(&iteration_id).map_err(|e| e.to_string())?;\r\n\r\n    // Update project\r\n    if let Ok(Some(mut project)) = project_store.load() {\r\n        project.iterations.retain(|i| i.id != iteration_id);\r\n        let _ = project_store.save(&project);\r\n    }\r\n\r\n    // Emit event\r\n    let _ = window.emit(\"iteration_deleted\", iteration_id);\r\n\r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\nfn project_to_info(project: &Project) -> ProjectInfo {\r\n    ProjectInfo {\r\n        id: project.id.clone(),\r\n        name: project.name.clone(),\r\n        created_at: project.created_at.to_rfc3339(),\r\n        updated_at: project.updated_at.to_rfc3339(),\r\n        current_iteration_id: project.current_iteration_id.clone(),\r\n        iteration_count: project.iterations.len(),\r\n    }\r\n}\r\n\r\nfn iteration_to_info(iteration: &Iteration) -> IterationInfo {\r\n    IterationInfo {\r\n        id: iteration.id.clone(),\r\n        number: iteration.number,\r\n        title: iteration.title.clone(),\r\n        description: iteration.description.clone(),\r\n        status: format!(\"{:?}\", iteration.status),\r\n        current_stage: iteration.current_stage.clone(),\r\n        completed_stages: iteration.completed_stages.clone(),\r\n        base_iteration_id: iteration.base_iteration_id.clone(),\r\n        inheritance: format!(\"{:?}\", iteration.inheritance),\r\n        created_at: iteration.started_at.to_rfc3339(),\r\n        completed_at: iteration.completed_at.map(|t| t.to_rfc3339()),\r\n    }\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 11.0,
      "lines_of_code": 304,
      "number_of_classes": 3,
      "number_of_functions": 10
    },
    "dependencies": [
      {
        "dependency_type": "Internal",
        "is_external": false,
        "line_number": 4,
        "name": "AppState",
        "path": "crate::AppState",
        "version": null
      },
      {
        "dependency_type": "Internal",
        "is_external": false,
        "line_number": 5,
        "name": "TauriBackend",
        "path": "crate::TauriBackend",
        "version": null
      },
      {
        "dependency_type": "Domain Model",
        "is_external": false,
        "line_number": 6,
        "name": "Iteration",
        "path": "cowork_core::domain",
        "version": null
      },
      {
        "dependency_type": "Domain Enum",
        "is_external": false,
        "line_number": 6,
        "name": "InheritanceMode",
        "path": "cowork_core::domain",
        "version": null
      },
      {
        "dependency_type": "Domain Model",
        "is_external": false,
        "line_number": 6,
        "name": "Project",
        "path": "cowork_core::domain",
        "version": null
      },
      {
        "dependency_type": "Persistence",
        "is_external": false,
        "line_number": 7,
        "name": "IterationStore",
        "path": "cowork_core::persistence",
        "version": null
      },
      {
        "dependency_type": "Persistence",
        "is_external": false,
        "line_number": 7,
        "name": "ProjectStore",
        "path": "cowork_core::persistence",
        "version": null
      },
      {
        "dependency_type": "Business Logic",
        "is_external": false,
        "line_number": 8,
        "name": "IterationExecutor",
        "path": "cowork_core::pipeline",
        "version": null
      },
      {
        "dependency_type": "Framework",
        "is_external": true,
        "line_number": 9,
        "name": "tauri",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "Serialization Library",
        "is_external": true,
        "line_number": 13,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "Async Runtime",
        "is_external": true,
        "line_number": 157,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "Standard Library",
        "is_external": true,
        "line_number": 11,
        "name": "std::sync::Arc",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This is a Tauri command module that serves as the bridge between the GUI frontend and the core business logic for an iteration-based cowork platform. The component implements a command handler layer that exposes async functions callable from the frontend, managing the complete lifecycle of projects and iterations.\n\n**Core Functionality:**\n- Project Management: Initialize new projects, retrieve existing project information, and delete projects with confirmation\n- Iteration Lifecycle: Create iterations with support for inheritance modes (None, Partial, Full), retrieve iteration lists and details, and delete iterations\n- Iteration Execution: Execute iterations asynchronously using IterationExecutor, with support for both fresh execution and continuation of interrupted iterations\n- Event Broadcasting: Emit lifecycle events (project_initialized, iteration_created, iteration_started, iteration_completed, iteration_failed, etc.) to keep the GUI in sync\n- Data Transformation: Convert domain entities (Project, Iteration) into serializable DTOs (ProjectInfo, IterationInfo) for frontend consumption\n\n**Business Logic Details:**\nThe component supports an evolution-based iteration architecture where new iterations can inherit from base iterations through three modes:\n- Genesis iterations: Created from scratch with title and description\n- Evolution iterations: Can inherit configuration, context, or both from a base iteration\n- Inheritance modes: None (no inheritance), Partial (selective inheritance), Full (complete inheritance)\n\nThe execution process uses background tasks (tokio::spawn) to avoid blocking the UI, with proper event emission for progress tracking. The component maintains data consistency by updating both iteration store and project summary when iterations are created or deleted.",
    "interfaces": [
      {
        "description": "Initialize a new project or load existing one, emits project_initialized event",
        "interface_type": "Command",
        "name": "gui_init_project",
        "parameters": [
          {
            "description": "Project name for initialization",
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": "Tauri window handle for event emission",
            "is_optional": false,
            "name": "window",
            "param_type": "Window"
          }
        ],
        "return_type": "Result<ProjectInfo, String>",
        "visibility": "public"
      },
      {
        "description": "Retrieve current project information, returns None if not initialized",
        "interface_type": "Command",
        "name": "gui_get_project",
        "parameters": [],
        "return_type": "Result<Option<ProjectInfo>, String>",
        "visibility": "public"
      },
      {
        "description": "Delete project and all data directories, requires explicit confirmation",
        "interface_type": "Command",
        "name": "gui_delete_project",
        "parameters": [
          {
            "description": "Confirmation flag for safety",
            "is_optional": false,
            "name": "confirm",
            "param_type": "bool"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      },
      {
        "description": "Create a new iteration (genesis or evolution) with specified inheritance mode",
        "interface_type": "Command",
        "name": "gui_create_iteration",
        "parameters": [
          {
            "description": "Iteration creation parameters including title, description, base iteration, and inheritance mode",
            "is_optional": false,
            "name": "request",
            "param_type": "CreateIterationRequest"
          },
          {
            "description": "Window handle for event emission",
            "is_optional": false,
            "name": "window",
            "param_type": "Window"
          },
          {
            "description": "Application state (currently unused)",
            "is_optional": false,
            "name": "_state",
            "param_type": "State<'_, AppState>"
          }
        ],
        "return_type": "Result<IterationInfo, String>",
        "visibility": "public"
      },
      {
        "description": "Retrieve all iterations for the current project",
        "interface_type": "Command",
        "name": "gui_get_iterations",
        "parameters": [],
        "return_type": "Result<Vec<IterationInfo>, String>",
        "visibility": "public"
      },
      {
        "description": "Retrieve detailed information for a specific iteration",
        "interface_type": "Command",
        "name": "gui_get_iteration",
        "parameters": [
          {
            "description": "Unique identifier of the iteration to retrieve",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          }
        ],
        "return_type": "Result<IterationInfo, String>",
        "visibility": "public"
      },
      {
        "description": "Execute iteration asynchronously in background, emits started/completed/failed events",
        "interface_type": "Command",
        "name": "gui_execute_iteration",
        "parameters": [
          {
            "description": "ID of iteration to execute",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": "Window handle for progress events",
            "is_optional": false,
            "name": "window",
            "param_type": "Window"
          },
          {
            "description": "App state with event bus for interaction",
            "is_optional": false,
            "name": "state",
            "param_type": "State<'_, AppState>"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      },
      {
        "description": "Continue an interrupted iteration execution asynchronously, emits lifecycle events",
        "interface_type": "Command",
        "name": "gui_continue_iteration",
        "parameters": [
          {
            "description": "ID of iteration to continue",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": "Window handle for progress events",
            "is_optional": false,
            "name": "window",
            "param_type": "Window"
          },
          {
            "description": "App state with event bus for interaction",
            "is_optional": false,
            "name": "state",
            "param_type": "State<'_, AppState>"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      },
      {
        "description": "Delete an iteration and update project summary, emits iteration_deleted event",
        "interface_type": "Command",
        "name": "gui_delete_iteration",
        "parameters": [
          {
            "description": "ID of iteration to delete",
            "is_optional": false,
            "name": "iteration_id",
            "param_type": "String"
          },
          {
            "description": "Window handle for event emission",
            "is_optional": false,
            "name": "window",
            "param_type": "Window"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "GUI Command Gateway: Exposes Tauri commands as the primary interface for frontend operations, translating GUI requests into domain operations",
      "Project & Iteration Lifecycle Management: Orchestrates creation, retrieval, and deletion of projects and iterations with proper state management and persistence",
      "Asynchronous Execution Orchestration: Manages background execution of iterations using IterationExecutor, with async spawning and event-driven progress notification",
      "Data Transformation Layer: Converts internal domain models (Project, Iteration) into serializable info structures (ProjectInfo, IterationInfo) for frontend communication",
      "Event-Driven State Notification: Broadcasts lifecycle events to the GUI to maintain synchronization between backend state and frontend UI"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\lib.rs",
      "functions": [
        "TauriBackend::new",
        "TauriBackend::show_message",
        "TauriBackend::request_input",
        "TauriBackend::show_progress",
        "TauriBackend::submit_response",
        "TauriBackend::event_bus",
        "determine_agent_name",
        "AppState::new",
        "register_project",
        "get_all_projects",
        "delete_project",
        "update_project",
        "open_project",
        "auto_register_current_project",
        "set_workspace",
        "has_open_project",
        "open_project_in_current_window",
        "get_workspace",
        "send_chat_message",
        "confirm_modify",
        "greet",
        "create_project",
        "revert_project",
        "modify_project",
        "resume_project",
        "get_sessions",
        "submit_input_response",
        "delete_session",
        "get_session_logs",
        "run"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "InteractiveBackend",
        "SessionInfo",
        "SessionLogEntry",
        "FileInfo",
        "PreviewInfo",
        "PreviewStatus",
        "ProjectType",
        "RunInfo",
        "RunStatus",
        "CommandResult",
        "FileTreeNode",
        "FileReadResult",
        "FormatResult",
        "FormatterAvailability",
        "ProjectTemplate",
        "TemplateFile",
        "TemplateConfig",
        "TemplateVariable",
        "ProjectInfo"
      ],
      "name": "lib.rs",
      "source_summary": "// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::sync::{Arc, Mutex};\nuse std::fs;\nuse tauri::{Emitter, Manager, State, Window};\nuse cowork_core::interaction::{InteractiveBackend, InputResponse};\nuse cowork_core::event_bus::EventBus;\nuse std::collections::HashMap;\nuse tokio::sync::oneshot;\nuse anyhow::Context;\nuse serde::{Serialize, Deserialize};\n\n// GUI-specific modules\nmod gui_types;\nmod gui_commands;\nmod preview_server;\nmod project_runner;\nmod project_manager;\nmod iteration_commands;\nuse project_manager::*;\n\n// ============================================================================\n// Iterative Assistant Types\n// ============================================================================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ChatActionResult {\n    pub action_type: String,\n    pub data: Option<serde_json::Value>,\n}\n\n// ============================================================================\n// TauriBackend - GUI implementation of InteractiveBackend\n// ============================================================================\n\npub struct TauriBackend {\n    app_handle: tauri::AppHandle,\n    event_bus: Arc<EventBus>,\n    pending_requests: Arc<Mutex<HashMap<String, oneshot::Sender<InputResponse>>>>,\n}\n\nimpl TauriBackend {\n    pub fn new(\n        app_handle: tauri::AppHandle,\n        event_bus: Arc<EventBus>,\n        pending_requests: Arc<Mutex<HashMap<String, oneshot::Sender<InputResponse>>>>,\n    ) -> Self {\n        Self {\n            app_handle,\n            event_bus,\n            pending_requests,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl InteractiveBackend for TauriBackend {\n    async fn show_message(&self, level: cowork_core::interaction::MessageLevel, content: String) {\n        // Determine agent name from message content\n        let agent_name = determine_agent_name(&content);\n        \n        // Emit agent_event for frontend processing display\n        let _ = self.app_handle.emit(\"agent_event\", serde_json::json!({\n            \"content\": content,\n            \"agent_name\": agent_name,\n            \"is_thinking\": false,\n            \"level\": format!(\"{:?}\", level)\n        }));\n        \n        // Also emit legacy message event for backward compatibility\n        let _ = self.app_handle.emit(\"message\", (level, content));\n    }\n\n    async fn request_input(&self, prompt: &str, options: Vec<cowork_core::interaction::InputOption>, _initial_content: Option<String>) -> anyhow::Result<InputResponse> {\n        use std::time::Duration;\n\n        // Generate a unique request ID\n        let request_id = format!(\"req-{}\", chrono::Utc::now().timestamp_millis());\n\n        println!(\"[HITL] Requesting input: {} (ID: {})\", prompt, request_id);\n        println!(\"[HITL] Options: {:?}\", options.iter().map(|o| &o.id).collect::<Vec<_>>());\n\n        // Create a channel for waiting for response\n        let (tx, rx) = oneshot::channel();\n\n        // Store the sender so it can be used later when user responds\n        {\n            let mut pending = self.pending_requests.lock().map_err(|e| anyhow::anyhow!(\"Lock error: {}\", e))?;\n            pending.insert(request_id.clone(), tx);\n        }\n\n        // Emit request to frontend\n        let _ = self.app_handle.emit(\"input_request\", (request_id.clone(), prompt, options));\n        println!(\"[HITL] Request sent to frontend\");\n\n        // Wait for response with timeout\n        tokio::select! {\n            result = rx => {\n                match result {\n                    Ok(response) => {\n                        println!(\"[HITL] Received response: {:?}\", response);\n                        Ok(response)\n                    },\n                    Err(_) => {\n                        println!(\"[HITL] Request canceled\");\n                        anyhow::bail!(\"Request canceled\")\n                    },\n                }\n            }\n            _ = tokio::time::sleep(Duration::from_secs(300)) => { // 5 minute timeout\n                println!(\"[HITL] Request timeout after 300 seconds\");\n                anyhow::bail!(\"Request timeout\")\n            }\n        }\n    }\n\n    async fn show_progress(&self, task_id: String, progress: cowork_core::interaction::ProgressInfo) {\n        let _ = self.app_handle.emit(\"progress\", (task_id, progress));\n    }\n\n    async fn submit_response(&self, _request_id: String, _response: String) -> anyhow::Result<()> {\n        // CLI doesn't use async HITL, responses are handled synchronously\n        Ok(())\n    }\n\n    fn event_bus(&self) -> Arc<EventBus> {\n        self.event_bus.clone()\n    }\n}\n\n/// Determine agent name from message content based on stage keywords\nfn determine_agent_name(content: &str) -> String {\n    let content_lower = content.to_lowercase();\n    \n    // Check for stage-specific keywords\n    if content_lower.contains(\"delivery\") || content_lower.contains(\"delivering\") {\n        return \"Delivery Agent\".to_string();\n    } else if content_lower.contains(\"coding\") || content_lower.contains(\"generating code\") || content_lower.contains(\"file\") && content_lower.contains(\"generat\") {\n        return \"Coding Agent\".to_string();\n    } else if content_lower.contains(\"plan\") || content_lower.contains(\"implementation plan\") {\n        return \"Planning Agent\".to_string();\n    } else if content_lower.contains(\"design\") || content_lower.contains(\"architecture\") {\n        return \"Design Agent\".to_string();\n    } else if content_lower.contains(\"prd\") || content_lower.contains(\"requirement\") {\n        return \"Requirements Agent\".to_string();\n    } else if content_lower.contains(\"idea\") || content_lower.contains(\"concept\") {\n        return \"Ideation Agent\".to_string();\n    } else if content_lower.contains(\"check\") || content_lower.contains(\"validat\") || content_lower.contains(\"test\") {\n        return \"Validation Agent\".to_string();\n    } else if content_lower.contains(\"stage\") && content_lower.contains(\"complet\") {\n        return \"Pipeline Controller\".to_string();\n    }\n    \n    // Default agent name\n    \"Cowork Agent\".to_string()\n}\n\n// ============================================================================\n// AppState\n// ============================================================================\n\npub struct AppState {\n    pub event_bus: Arc<EventBus>,\n    pub pending_requests: Arc<Mutex<HashMap<String, oneshot::Sender<InputResponse>>>>,\n    pub project_registry_manager: Arc<Mutex<ProjectRegistryManager>>,\n    pub workspace_path: Arc<Mutex<Option<String>>>,\n}\n\nimpl AppState {\n    pub fn new(event_bus: Arc<EventBus>) -> Result<Self, anyhow::Error> {\n        let project_registry_manager = ProjectRegistryManager::new()\n            .context(\"Failed to initialize project registry manager\")?;\n        \n        Ok(Self {\n            event_bus,\n            pending_requests: Arc::new(Mutex::new(HashMap::new())),\n            project_registry_manager: Arc::new(Mutex::new(project_registry_manager)),\n            workspace_path: Arc::new(Mutex::new(None)),\n        })\n    }\n}\n\n// ============================================================================\n// Tauri Commands\n// ============================================================================\n\n// ============================================================================\n// Project Manager Commands\n// ============================================================================\n\n#[tauri::command]\nasync fn register_project(\n    workspace_path: String,\n    name: String,\n    description: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ProjectRecord, String> {\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    registry.register_project(workspace_path, name, description)\n        .map_err(|e| format!(\"Failed to register project: {}\", e))\n}\n\n#[tauri::command]\nasync fn get_all_projects(\n    status: Option<String>,\n    search: Option<String>,\n    limit: Option<usize>,\n    state: State<'_, AppState>,\n) -> Result<Vec<ProjectRecord>, String> {\n    let registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    let options = ProjectQueryOptions {\n        status: status.and_then(|s| serde_json::from_str(&s).ok()),\n        search,\n        limit,\n    };\n    \n    Ok(registry.get_all_projects(Some(options)))\n}\n\n#[tauri::command]\nasync fn delete_project(\n    project_id: String,\n    delete_files: bool,\n    state: State<'_, AppState>,\n) -> Result<(), String> {\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    registry.delete_project(&project_id, delete_files)\n        .map_err(|e| format!(\"Failed to delete project: {}\", e))\n}\n\n#[tauri::command]\nasync fn update_project(\n    project_id: String,\n    name: Option<String>,\n    description: Option<String>,\n    status: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ProjectRecord, String> {\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    let status = status.and_then(|s| serde_json::from_str(&s).ok());\n    \n    registry.update_project(&project_id, name, description, status)\n        .map_err(|e| format!(\"Failed to update project: {}\", e))\n}\n\n#[tauri::command]\nasync fn open_project(\n    project_id: String,\n    state: State<'_, AppState>,\n) -> Result<(), String> {\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    // Get project\n    let project = registry.get_project(&project_id)\n        .ok_or_else(|| \"Project not found\".to_string())?;\n    \n    // Update last opened time\n    registry.update_last_opened(&project_id)\n        .map_err(|e| format!(\"Failed to update last opened time: {}\", e))?;\n    \n    // Drop the lock before spawning new process\n    drop(registry);\n    \n    // Get current executable path\n    let exe_path = std::env::current_exe()\n        .map_err(|e| format!(\"Failed to get executable path: {}\", e))?;\n    \n    // Spawn new process with --workspace parameter\n    std::process::Command::new(&exe_path)\n        .arg(\"--workspace\")\n        .arg(&project.workspace_path)\n        .spawn()\n        .map_err(|e| format!(\"Failed to open project: {}\", e))?;\n    \n    Ok(())\n}\n\n#[tauri::command]\nasync fn auto_register_current_project(\n    state: State<'_, AppState>,\n) -> Result<Option<ProjectRecord>, String> {\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    registry.auto_register_current_project()\n        .map_err(|e| format!(\"Failed to auto-register project: {}\", e))\n}\n\n#[tauri::command]\nasync fn set_workspace(\n    workspace_path: String,\n    state: State<'_, AppState>,\n    window: Window,\n) -> Result<(), String> {\n    use std::path::Path;\n    \n    println!(\"[GUI] Setting workspace to: {}\", workspace_path);\n    \n    let path = Path::new(&workspace_path);\n    if !path.exists() {\n        // Create the directory if it doesn't exist\n        fs::create_dir_all(path)\n            .map_err(|e| format!(\"Failed to create workspace directory: {}\", e))?;\n    }\n    \n    if !path.is_dir() {\n        return Err(format!(\"Path is not a directory: {}\", workspace_path));\n    }\n    \n    // Check if workspace is already set\n    let workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    if workspace.is_some() {\n        drop(workspace);\n        return Err(\"This window already has a project opened. Please open a new window to work on another project.\".to_string());\n    }\n    drop(workspace);\n    \n    // Change current directory\n    std::env::set_current_dir(path)\n        .map_err(|e| format!(\"Failed to set current directory: {}\", e))?;\n    \n    // Initialize project using new V2 API\n    let project_name = path.file_name()\n        .and_then(|n| n.to_str())\n        .unwrap_or(\"cowork_project\")\n        .to_string();\n    \n    // Use new persistence API to check if initialized\n    let cowork_v2_path = path.join(\".cowork-v2\");\n    if !cowork_v2_path.exists() {\n        println!(\"[GUI] Project not initialized, initializing with V2 API...\");\n        \n        // Create .cowork-v2 directory structure\n        std::fs::create_dir_all(&cowork_v2_path)\n            .map_err(|e| format!(\"Failed to create .cowork-v2 directory: {}\", e))?;\n        \n        let project_file = cowork_v2_path.join(\"project.json\");\n        let iterations_dir = cowork_v2_path.join(\"iterations\");\n        std::fs::create_dir_all(&iterations_dir)\n            .map_err(|e| format!(\"Failed to create iterations directory: {}\", e))?;\n        \n        // Create initial project file\n        let project = cowork_core::domain::Project::new(&project_name);\n        let project_json = serde_json::to_string_pretty(&project)\n            .map_err(|e| format!(\"Failed to serialize project: {}\", e))?;\n        std::fs::write(&project_file, project_json)\n            .map_err(|e| format!(\"Failed to write project.json: {}\", e))?;\n        \n        println!(\"[GUI] Project initialized successfully with V2 API\");\n    } else {\n        println!(\"[GUI] Project already initialized with V2\");\n    }\n    \n    // Auto-register project to registry\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    // Check if already registered\n    let workspace_path_str = workspace_path.clone();\n    if !registry.get_all_projects(None).iter().any(|p| p.workspace_path == workspace_path_str) {\n        println!(\"[GUI] Auto-registering project to registry\");\n        if let Err(e) = registry.register_project(\n            workspace_path.clone(),\n            project_name,\n            Some(format!(\"Cowork project at {}\", workspace_path))\n        ) {\n            eprintln!(\"[GUI] Warning: Failed to auto-register project: {}\", e);\n            // Don't fail the whole operation if registration fails\n        } else {\n            println!(\"[GUI] Project registered successfully\");\n        }\n    } else {\n        println!(\"[GUI] Project already registered\");\n    }\n    drop(registry);\n    \n    // Store in app state\n    let mut workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    *workspace = Some(workspace_path.clone());\n    \n    // Emit event to trigger reload\n    let _ = window.emit(\"project_loaded\", ());\n    \n    println!(\"[GUI] Workspace set successfully\");\n    Ok(())\n}\n\n#[tauri::command]\nasync fn has_open_project(\n    state: State<'_, AppState>,\n) -> Result<bool, String> {\n    let workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    Ok(workspace.is_some())\n}\n\n#[tauri::command]\nasync fn open_project_in_current_window(\n    project_id: String,\n    state: State<'_, AppState>,\n    window: Window,\n) -> Result<(), String> {\n    use std::path::Path;\n    \n    // Check if window already has a project\n    let workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    if workspace.is_some() {\n        drop(workspace);\n        return Err(\"This window already has a project opened. Please open a new window to work on another project.\".to_string());\n    }\n    drop(workspace);\n    \n    // Get project from registry\n    let mut registry = state.project_registry_manager.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    let project = registry.get_project(&project_id)\n        .ok_or_else(|| \"Project not found\".to_string())?;\n    \n    // Update last opened time\n    registry.update_last_opened(&project_id)\n        .map_err(|e| format!(\"Failed to update last opened time: {}\", e))?;\n    \n    let workspace_path = project.workspace_path.clone();\n    drop(registry);\n    \n    // Log for debugging\n    println!(\"[GUI] Project opened in current window: {}\", workspace_path);\n    \n    // Set workspace in current window\n    let path = Path::new(&workspace_path);\n    if !path.exists() {\n        return Err(format!(\"Project path does not exist: {}\", workspace_path));\n    }\n    \n    std::env::set_current_dir(path)\n        .map_err(|e| format!(\"Failed to set current directory: {}\", e))?;\n    \n    let mut workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    *workspace = Some(workspace_path);\n    \n    // Emit event to trigger reload\n    let _ = window.emit(\"project_loaded\", ());\n    \n    Ok(())\n}\n\n#[tauri::command]\nasync fn get_workspace(\n    state: State<'_, AppState>,\n) -> Result<Option<String>, String> {\n    let workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    Ok(workspace.clone())\n}\n\n// ============================================================================\n// Legacy Commands (Deprecated - use iteration-based API instead)\n// ============================================================================\n\n#[tauri::command]\nasync fn send_chat_message(\n    _session_id: String,\n    _message: String,\n) -> Result<ChatActionResult, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API\".to_string())\n}\n\n#[tauri::command]\nasync fn confirm_modify(\n    _session_id: String,\n    _suggestion_str: String,\n) -> Result<String, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API (gui_create_iteration, gui_execute_iteration)\".to_string())\n}\n\n// ============================================================================\n// Core Commands\n// ============================================================================\n\n#[tauri::command]\nfn greet(name: &str) -> String {\n    format!(\"Hello, {}! Welcome to Cowork Forge GUI!\", name)\n}\n\n#[tauri::command]\nasync fn create_project(\n    _idea: String,\n) -> Result<String, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API (gui_init_project, gui_create_iteration)\".to_string())\n}\n\n#[tauri::command]\nasync fn revert_project(\n    _base_session_id: String,\n    _from_stage: String,\n) -> Result<String, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API\".to_string())\n}\n\n#[tauri::command]\nasync fn modify_project(\n    _base_session_id: String,\n    _idea: String,\n) -> Result<String, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API (gui_create_iteration)\".to_string())\n}\n\n#[tauri::command]\nasync fn resume_project(\n    _base_session_id: String,\n) -> Result<String, String> {\n    // Legacy command - functionality moved to iteration-based architecture\n    Err(\"This command is deprecated. Please use the new Iteration-based API (gui_continue_iteration)\".to_string())\n}\n\n// ============================================================================\n// Legacy Session Commands (use iteration-based API instead)\n// ============================================================================\n\n#[tauri::command]\nfn get_sessions(state: State<'_, AppState>) -> Result<Vec<SessionInfo>, String> {\n    use std::path::Path;\n    \n    // Get the current workspace from app state\n    let workspace = state.workspace_path.lock()\n        .map_err(|e| format!(\"Failed to acquire lock: {}\", e))?;\n    \n    // Check for V2 project structure\n    if let Some(ref workspace_path) = *workspace {\n        let project_file = Path::new(workspace_path).join(\".cowork-v2\").join(\"project.json\");\n        if project_file.exists() {\n            // V2 project - return empty list (iterations are separate)\n            return Ok(vec![]);\n        }\n        \n        // Check for old V1 structure\n        let v1_index = Path::new(workspace_path).join(\".cowork\").join(\"index.json\");\n        if v1_index.exists() {\n            // Try to load old sessions\n            match std::fs::read_to_string(&v1_index) {\n                Ok(content) => {\n                    if let Ok(index) = serde_json::from_str::<cowork_core::data::ProjectIndex>(&content) {\n                        return Ok(index.sessions.into_iter().map(|s| SessionInfo {\n                            id: s.session_id,\n                            status: format!(\"{:?}\", s.status),\n                            created_at: s.created_at.to_rfc3339(),\n                            description: s.input_description,\n                        }).collect());\n                    }\n                }\n                Err(_) => {}\n            }\n        }\n    }\n    \n    Ok(vec![])\n}\n\n#[tauri::command]\nasync fn submit_input_response(\n    request_id: String,\n    response: String,\n    response_type: String,\n    state: State<'_, AppState>,\n) -> Result<(), String> {\n    let input_response = match response_type.as_str() {\n        \"text\" => InputResponse::Text(response),\n        \"selection\" => InputResponse::Selection(response),\n        _ => InputResponse::Cancel,\n    };\n\n    let mut pending = state.pending_requests.lock()\n        .map_err(|e| format!(\"Lock error: {}\", e))?;\n\n    if let Some(tx) = pending.remove(&request_id) {\n        let _ = tx.send(input_response);\n        Ok(())\n    } else {\n        Err(format!(\"Request {} not found\", request_id))\n    }\n}\n\n#[tauri::command]\nasync fn delete_session(\n    _session_id: String,\n    _window: tauri::Window,\n) -> Result<(), String> {\n    // Legacy command - use gui_delete_iteration for V2 API\n    Err(\"This command is deprecated for V2 projects. Use gui_delete_iteration instead.\".to_string())\n}\n\n#[tauri::command]\nasync fn get_session_logs(\n    _session_id: String,\n) -> Result<Vec<SessionLogEntry>, String> {\n    // Legacy command - logs are now per-iteration in V2\n    Ok(vec![])\n}\n\n// ============================================================================\n// Session Info Types\n// ============================================================================\n\n#[derive(serde::Serialize, serde::Deserialize)]\nstruct SessionInfo {\n    id: String,\n    status: String,\n    created_at: String,\n    description: String,\n}\n\n#[derive(serde::Serialize)]\nstruct SessionLogEntry {\n    file: String,\n    content: String,\n}\n\n// ============================================================================\n// Run Application\n// ============================================================================\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\npub fn run() {\n    let event_bus = Arc::new(EventBus::new());\n    \n    let app_state = AppState::new(event_bus)\n        .expect(\"Failed to initialize application state\");\n    \n    // Check for --workspace argument\n    let args: Vec<String> = std::env::args().collect();\n    let workspace_path = args.iter()\n        .position(|arg| arg == \"--workspace\")\n        .and_then(|pos| args.get(pos + 1))\n        .cloned();\n    \n    let workspace_path_clone = workspace_path.clone();\n    \n    tauri::Builder::default()\n        .plugin(tauri_plugin_opener::init())\n        .plugin(tauri_plugin_dialog::init())\n        .manage(app_state)\n        .invoke_handler(tauri::generate_handler![\n            greet,\n            // Legacy commands (for backward compatibility during transition)\n            create_project,\n            revert_project,\n            modify_project,\n            resume_project,\n            get_sessions,\n            submit_input_response,\n            delete_session,\n            get_session_logs,\n            // New Iteration-based commands\n            iteration_commands::gui_init_project,\n            iteration_commands::gui_get_project,\n            iteration_commands::gui_delete_project,\n            iteration_commands::gui_create_iteration,\n            iteration_commands::gui_get_iterations,\n            iteration_commands::gui_get_iteration,\n            iteration_commands::gui_execute_iteration,\n            iteration_commands::gui_continue_iteration,\n            iteration_commands::gui_delete_iteration,\n            // GUI-specific commands (Legacy)\n            gui_commands::get_session_artifacts,\n            gui_commands::read_file_content,\n            gui_commands::save_file_content,\n            gui_commands::get_file_tree,\n            gui_commands::start_preview,\n            gui_commands::stop_preview,\n            gui_commands::start_project,\n            gui_commands::stop_project,\n            gui_commands::execute_project_command,\n            // GUI-specific commands (V2 API - Iteration based)\n            gui_commands::get_iteration_artifacts,\n            gui_commands::read_iteration_file,\n            gui_commands::save_iteration_file,\n            gui_commands::get_iteration_file_tree,\n            gui_commands::start_iteration_preview,\n            gui_commands::stop_iteration_preview,\n            gui_commands::start_iteration_project,\n            gui_commands::stop_iteration_project,\n            // Memory commands\n            gui_commands::query_memory_index,\n            gui_commands::load_memory_detail,\n            gui_commands::save_session_memory,\n            gui_commands::promote_to_project_memory,\n            gui_commands::get_memory_context,\n            // Code formatting commands\n            gui_commands::format_code,\n            gui_commands::check_formatter_available,\n            // Template commands\n            gui_commands::get_templates,\n            gui_commands::export_template,\n            gui_commands::import_template,\n            gui_commands::delete_template,\n            gui_commands::apply_template,\n            // Project manager commands\n            register_project,\n            get_all_projects,\n            delete_project,\n            update_project,\n            open_project,\n            open_project_in_current_window,\n            auto_register_current_project,\n            set_workspace,\n            get_workspace,\n            has_open_project,\n            // Iterative assistant commands\n            send_chat_message,\n            confirm_modify,\n        ])\n        .setup(move |app| {\n            // Initialize app handle for project runner\n            gui_commands::init_app_handle(app.handle().clone());\n            \n            // Set workspace if provided via command line\n            if let Some(workspace) = workspace_path_clone {\n                println!(\"[GUI] Workspace path from command line: {}\", workspace);\n                use std::path::Path;\n                let path = Path::new(&workspace);\n                if path.exists() && path.is_dir() {\n                    if let Err(e) = std::env::set_current_dir(path) {\n                        eprintln!(\"[GUI] Failed to set workspace directory: {}\", e);\n                    } else {\n                        println!(\"[GUI] Working directory set to: {}\", workspace);\n                        // Store in app state\n                        if let Some(state) = app.try_state::<AppState>() {\n                            if let Ok(mut ws) = state.workspace_path.lock() {\n                                *ws = Some(workspace);\n                            }\n                        }\n                    }\n                } else {\n                    eprintln!(\"[GUI] Invalid workspace path: {}\", workspace);\n                }\n            }\n            \n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 53.0,
      "lines_of_code": 762,
      "number_of_classes": 2,
      "number_of_functions": 41
    },
    "dependencies": [
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "tauri",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "cowork_core",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": true,
        "line_number": null,
        "name": "async_trait",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "gui_types",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "gui_commands",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "preview_server",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "project_runner",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "project_manager",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "iteration_commands",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "plugin",
        "is_external": true,
        "line_number": null,
        "name": "tauri_plugin_opener",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "plugin",
        "is_external": true,
        "line_number": null,
        "name": "tauri_plugin_dialog",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::interaction::InteractiveBackend",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::event_bus::EventBus",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::data::Requirements",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::data::FeatureList",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::data::DesignSpec",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::data::ImplementationPlan",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "interface",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core::domain::Project",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This component is the entry point for the Cowork Forge GUI application built with Tauri. It serves as the core bridge between the Rust backend and the frontend UI, implementing the InteractiveBackend trait to handle human-in-the-loop (HITL) interactions, managing project lifecycle operations, and exposing a comprehensive set of Tauri commands for frontend communication. The component initializes the application state with event bus, pending request tracking, and project registry, then registers over 40 Tauri commands for project management, file operations, preview servers, iterations, memory, templates, and code formatting. It also handles command-line workspace initialization and provides agent name detection logic based on message content. The system supports both legacy V1 session-based workflows and modern V2 iteration-based architecture, with careful backward compatibility measures.",
    "interfaces": [
      {
        "description": null,
        "interface_type": "trait",
        "name": "InteractiveBackend",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "level",
            "param_type": "cowork_core::interaction::MessageLevel"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "prompt",
            "param_type": "&str"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "options",
            "param_type": "Vec<cowork_core::interaction::InputOption>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "_initial_content",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "task_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "progress",
            "param_type": "cowork_core::interaction::ProgressInfo"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "_request_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "_response",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "SessionInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "SessionLogEntry",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "file",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "size",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_dir",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "language",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "modified_at",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "PreviewInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "url",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "port",
            "param_type": "u16"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "PreviewStatus"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "project_type",
            "param_type": "ProjectType"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "PreviewStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "ProjectType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "RunInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "RunStatus"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "process_id",
            "param_type": "Option<u32>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "command",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "enum",
        "name": "RunStatus",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "CommandResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "status",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "exit_code",
            "param_type": "Option<i32>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stdout",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stderr",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileTreeNode",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_dir",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "children",
            "param_type": "Option<Vec<FileTreeNode>>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_expanded",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "language",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FileReadResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "offset",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_size",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_partial",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FormatResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "formatted_files",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "errors",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "success",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "FormatterAvailability",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "prettier",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "rustfmt",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ProjectTemplate",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "category",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "technology_stack",
            "param_type": "Vec<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "created_at",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "updated_at",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_built_in",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "files",
            "param_type": "Vec<TemplateFile>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "config",
            "param_type": "TemplateConfig"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateFile",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_template",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "variables",
            "param_type": "Vec<TemplateVariable>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "post_creation_commands",
            "param_type": "Vec<String>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "TemplateVariable",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "description",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "default_value",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "required",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "ProjectInfo",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "project_type",
            "param_type": "ProjectType"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "start_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "build_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "preview_command",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_index_html",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_package_json",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "has_cargo_toml",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manage the Tauri application lifecycle and state initialization",
      "Implement the InteractiveBackend interface to bridge GUI interactions with backend AI agents",
      "Provide comprehensive project management commands for creation, registration, opening, and deletion",
      "Handle HITL input/output through request/response channels and event emission",
      "Support dual architecture (legacy V1 and modern V2) with backward compatibility"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": "Entry point file for the cowork-gui Tauri desktop application, handling application startup and platform-specific configuration.",
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\main.rs",
      "functions": [
        "main"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "main.rs",
      "source_summary": "// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n    cowork_gui_lib::run()\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 6,
      "number_of_classes": 0,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "local_library",
        "is_external": false,
        "line_number": 4,
        "name": "cowork_gui_lib",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "## Functional Description\n\nThe main.rs component serves as the application entry point for a Tauri-based desktop GUI application named 'cowork-gui'. This component has two primary responsibilities:\n\n1. **Platform-Specific Configuration**: Contains a conditional compilation attribute (`#[cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]`) that prevents the appearance of an additional console window on Windows when running in release mode. This is a common best practice for GUI applications to provide a clean user experience.\n\n2. **Application Initialization and Runtime**: The `main()` function acts as the minimal bootstrap code that delegates the actual application execution to the `cowork_gui_lib::run()` function. This pattern separates the concerns between the binary entry point and the core application logic, allowing the main binary to remain lightweight while the library crate handles the complex application lifecycle, window management, and business logic.\n\n## Architectural Role\n\nIn the system architecture, this component plays the role of **Application Bootstrap / Entry Layer**. It is the first code executed when the application launches and serves as a thin wrapper that:\n- Configures the runtime environment\n- Transfers control to the application's core logic layer\n- Follows the Tauri framework's recommended structure where main.rs is kept minimal\n\nThe component demonstrates a clean separation between the binary crate (which contains only the entry point) and the library crate (`cowork_gui_lib`), which contains the actual application implementation.\n\n## Code Quality Assessment\n\n**Strengths:**\n- **Simplicity**: With only 6 lines of code and cyclomatic complexity of 1.0, this is an excellent example of a clean entry point\n- **Platform Optimization**: Properly handles Windows-specific behavior for release builds\n- **Separation of Concerns**: Effectively delegates to the library module rather than implementing logic directly\n- **Idiomatic Rust**: Follows Rust conventions for entry point structure and attribute usage\n\n**Areas for Improvement:**\n1. **Documentation**: While the code is self-explanatory, adding a module-level documentation comment explaining the application's purpose would improve maintainability\n2. **Error Handling**: Currently has no error handling around the `cowork_gui_lib::run()` call; while this may be intentional if the library handles all errors, consider adding proper propagation or logging\n3. **Configuration Management**: If the application requires startup parameters or configuration loading, this would be an appropriate place to add that logic\n\n## Dependency Analysis\n\nThe component has a single dependency on `cowork_gui_lib`, which is a **local internal dependency**. This dependency is highly appropriate because:\n\n- **Logical Separation**: It represents the core application logic that should be separate from the entry point\n- **Modularity**: Allows the library crate to be tested and potentially reused independently\n- **Maintainability**: Keeps the binary crate minimal and focused only on bootstrap responsibilities\n- **Architectural Pattern**: Follows Tauri's standard project structure where the main crate serves as a thin wrapper\n\nThere are no external dependencies (crates.io dependencies) in this component, which is appropriate for an entry point that delegates all complex functionality to the library.\n\n## Core Responsibilities\n\n1. **Application Bootstrap**: Providing the program entry point and initializing the application runtime\n2. **Platform Configuration**: Managing platform-specific behavior (Windows console suppression in release builds)\n3. **Runtime Delegation**: Transferring execution control to the core application library\n4. **Environment Setup**: Configuring the execution environment through compiler attributes and conditional compilation",
    "interfaces": [
      {
        "description": "Application entry point that delegates runtime execution to cowork_gui_lib::run()",
        "interface_type": "runtime_function",
        "name": "main",
        "parameters": [],
        "return_type": "null",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Provide the program entry point for the Tauri desktop application",
      "Configure platform-specific behavior (Windows console suppression in release builds)",
      "Delegate application runtime execution to the cowork_gui_lib module",
      "Bootstrap and initialize the application execution environment",
      "Maintain separation between binary entry point and core application logic"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "service",
      "description": "Preview server management service for GUI application that manages multiple HTTP preview servers serving static files from specified directories.",
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\preview_server.rs",
      "functions": [
        "new",
        "start",
        "stop",
        "find_available_port",
        "is_port_available",
        "detect_project_type",
        "handle_request",
        "get_mime_type"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "PreviewServerManager::new()",
        "PreviewServerManager::start(session_id: String, base_dir: PathBuf) -> Result<PreviewInfo, String>",
        "PreviewServerManager::stop(session_id: String) -> Result<(), String>",
        "PreviewServerManager::find_available_port() -> Result<u16, String>",
        "PreviewServerManager::is_port_available(port: u16) -> bool",
        "PreviewServerManager::detect_project_type(base_dir: &Path) -> ProjectType",
        "PreviewServerManager::handle_request(request: &Request, base_dir: &Path, session_id: &str) -> Response<Cursor<Vec<u8>>>",
        "PreviewServerManager::get_mime_type(path: &Path) -> String"
      ],
      "name": "preview_server.rs",
      "source_summary": "// Preview server management for GUI\nuse super::gui_types::*;\nuse std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nuse std::fs;\n\nuse tiny_http::{Server, Response, Request, Header, StatusCode};\n\npub struct PreviewServerManager {\n    servers: Arc<Mutex<HashMap<String, PreviewServer>>>,\n}\n\nstruct PreviewServer {\n    port: u16,\n    base_dir: PathBuf,\n    handle: Option<thread::JoinHandle<()>>,\n    running: Arc<Mutex<bool>>,\n}\n\nimpl PreviewServerManager {\n    pub fn new() -> Self {\n        Self {\n            servers: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    pub async fn start(&self, session_id: String, base_dir: PathBuf) -> Result<PreviewInfo, String> {\n        // Stop existing server if any\n        if let Ok(()) = self.stop(session_id.clone()).await {\n            println!(\"[Preview] Stopped existing server for session: {}\", session_id);\n        }\n\n        let port = self.find_available_port()?;\n        let base_dir_clone = base_dir.clone();\n        let session_id_clone = session_id.clone();\n\n        // Create running flag\n        let running = Arc::new(Mutex::new(true));\n\n        let running_clone = running.clone();\n\n        let handle = thread::spawn(move || {\n            println!(\"[Preview] Starting server on port {} for session: {}\", port, session_id_clone);\n            \n            match Server::http(format!(\"0.0.0.0:{}\", port)) {\n                Ok(server) => {\n                    println!(\"[Preview] Server started successfully\");\n                    \n                    for request in server.incoming_requests() {\n                        // Check if still running\n                        if !*running_clone.lock().unwrap() {\n                            break;\n                        }\n\n                        let response = Self::handle_request(&request, &base_dir_clone, &session_id_clone);\n                        let _ = request.respond(response);\n                    }\n                }\n                Err(e) => {\n                    eprintln!(\"[Preview] Failed to create server: {}\", e);\n                }\n            }\n            \n            println!(\"[Preview] Server stopped for session: {}\", session_id_clone);\n        });\n\n        let base_dir_clone2 = base_dir.clone();\n        let mut servers = self.servers.lock().unwrap();\n        servers.insert(session_id.clone(), PreviewServer {\n            port,\n            base_dir,\n            handle: Some(handle),\n            running,\n        });\n\n        let project_type = Self::detect_project_type(&base_dir_clone2);\n\n        Ok(PreviewInfo {\n            url: format!(\"http://localhost:{}\", port),\n            port,\n            status: PreviewStatus::Running,\n            project_type,\n        })\n    }\n\n    pub async fn stop(&self, session_id: String) -> Result<(), String> {\n        let mut servers = self.servers.lock().unwrap();\n        \n        if let Some(mut server) = servers.remove(&session_id) {\n            println!(\"[Preview] Stopping server for session: {}\", session_id);\n            \n            // Signal the server to stop\n            *server.running.lock().unwrap() = false;\n            \n            // Make a request to unblock the server\n            if let Err(e) = attohttpc::get(&format!(\"http://localhost:{}\", server.port)).send() {\n                println!(\"[Preview] Unblock request failed: {}\", e);\n            }\n            \n            if let Some(handle) = server.handle.take() {\n                // Wait for thread to finish with timeout\n                let _ = handle.join();\n            }\n            \n            Ok(())\n        } else {\n            Err(format!(\"No running server for session: {}\", session_id))\n        }\n    }\n\n    fn find_available_port(&self) -> Result<u16, String> {\n        for port in 5000..6000 {\n            if Self::is_port_available(port) {\n                return Ok(port);\n            }\n        }\n        Err(\"No available port\".to_string())\n    }\n\n    fn is_port_available(port: u16) -> bool {\n        // Try to bind to the port to check if it's available\n        std::net::TcpListener::bind(format!(\"0.0.0.0:{}\", port)).is_ok()\n    }\n\n    fn detect_project_type(base_dir: &Path) -> ProjectType {\n        let index_html = base_dir.join(\"index.html\");\n        let package_json = base_dir.join(\"package.json\");\n        let cargo_toml = base_dir.join(\"Cargo.toml\");\n\n        if index_html.exists() {\n            if package_json.exists() {\n                return ProjectType::React;\n            } else if cargo_toml.exists() {\n                return ProjectType::Html;\n            }\n            return ProjectType::Static;\n        }\n\n        if cargo_toml.exists() {\n            return ProjectType::Unknown;\n        }\n\n        ProjectType::Unknown\n    }\n\n    fn handle_request(request: &Request, base_dir: &Path, _session_id: &str) -> Response<std::io::Cursor<Vec<u8>>> {\n        let url = request.url();\n        let path_str = url.trim_start_matches('/');\n        let path = if path_str.is_empty() || path_str == \"/\" {\n            base_dir.join(\"index.html\")\n        } else {\n            // URL decode the path\n            let decoded = urlencoding::decode(path_str)\n                .unwrap_or_else(|_| std::borrow::Cow::Borrowed(path_str))\n                .to_string();\n            \n            // Security: prevent path traversal\n            let safe_path = decoded.replace(\"..\", \"\");\n            base_dir.join(&safe_path)\n        };\n\n        println!(\"[Preview] Request: {} -> {:?}\", url, path);\n\n        if !path.exists() || !path.starts_with(base_dir) {\n            let response = Response::from_data(Vec::from(\"404 Not Found\"));\n            return response.with_status_code(StatusCode(404));\n        }\n\n        match fs::read(&path) {\n            Ok(content) => {\n                let mime_type = Self::get_mime_type(&path);\n                let header = Header::from_bytes(&b\"Content-Type\"[..], mime_type.as_bytes()).unwrap();\n                Response::from_data(content).with_header(header)\n            }\n            Err(e) => {\n                eprintln!(\"[Preview] Error reading file: {}\", e);\n                Response::from_data(Vec::from(format!(\"500 Internal Server Error: {}\", e)))\n                    .with_status_code(StatusCode(500))\n            }\n        }\n    }\n\n    fn get_mime_type(path: &Path) -> String {\n        match path.extension().and_then(|e| e.to_str()) {\n            Some(\"html\") => \"text/html\".to_string(),\n            Some(\"htm\") => \"text/html\".to_string(),\n            Some(\"css\") => \"text/css\".to_string(),\n            Some(\"js\") => \"application/javascript\".to_string(),\n            Some(\"json\") => \"application/json\".to_string(),\n            Some(\"png\") => \"image/png\".to_string(),\n            Some(\"jpg\") | Some(\"jpeg\") => \"image/jpeg\".to_string(),\n            Some(\"gif\") => \"image/gif\".to_string(),\n            Some(\"svg\") => \"image/svg+xml\".to_string(),\n            Some(\"ico\") => \"image/x-icon\".to_string(),\n            Some(\"woff\") | Some(\"woff2\") => \"font/woff2\".to_string(),\n            Some(\"ttf\") => \"font/ttf\".to_string(),\n            Some(\"txt\") => \"text/plain\".to_string(),\n            Some(\"md\") => \"text/markdown\".to_string(),\n            _ => \"application/octet-stream\".to_string(),\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 28.0,
      "lines_of_code": 204,
      "number_of_classes": 2,
      "number_of_functions": 8
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 2,
        "name": "std::sync::{Arc, Mutex}",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 3,
        "name": "std::collections::HashMap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 4,
        "name": "std::path::{Path, PathBuf}",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 5,
        "name": "std::thread",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 6,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 8,
        "name": "tiny_http::{Server, Response, Request, Header, StatusCode}",
        "path": "tiny_http",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 80,
        "name": "attohttpc",
        "path": "attohttpc",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 102,
        "name": "urlencoding",
        "path": "urlencoding",
        "version": null
      }
    ],
    "detailed_description": "The `preview_server.rs` component is a service-level module that implements a preview server management system for a Tauri-based GUI application. It enables users to preview web projects by running local HTTP servers that serve static files from specified base directories.\n\nThe component provides two main structs: `PreviewServerManager` (public interface) and `PreviewServer` (private internal structure). The manager maintains a HashMap of active servers keyed by session_id, allowing concurrent preview sessions for different projects.\n\nCore functionality includes:\n1. **Server Lifecycle Management**: The `start` method creates new HTTP servers on available ports (5000-6000 range) in separate threads, each with its own running flag. It automatically stops any existing server for the same session before starting a new one. The `stop` method gracefully shuts down servers by setting the running flag to false and making a request to unblock the server thread.\n\n2. **HTTP Request Handling**: The `handle_request` method processes incoming requests, maps URL paths to file system paths with URL decoding, implements security checks to prevent path traversal attacks, and serves files with appropriate MIME types. It supports common web file formats (HTML, CSS, JavaScript, images, fonts).\n\n3. **Port Management**: The `find_available_port` method scans ports 5000-6000 to find an available port by attempting TCP binding, while `is_port_available` performs the actual port availability check.\n\n4. **Project Type Detection**: The `detect_project_type` method analyzes the base directory for common configuration files (index.html, package.json, Cargo.toml) to identify React, HTML, Static, or Unknown project types.\n\n5. **MIME Type Handling**: The `get_mime_type` method determines appropriate content-type headers based on file extensions, supporting 15+ different file types.\n\nThe component uses Rust's concurrency primitives (Arc<Mutex<T>>, thread::spawn) for thread-safe state management and employs the tiny_http library for lightweight HTTP server functionality. It includes basic error handling and logging throughout the request lifecycle.",
    "interfaces": [
      {
        "description": "Creates a new PreviewServerManager instance with an empty server HashMap",
        "interface_type": "constructor",
        "name": "PreviewServerManager::new",
        "parameters": [],
        "return_type": "PreviewServerManager",
        "visibility": "public"
      },
      {
        "description": "Starts a new HTTP preview server on an available port, serving files from base_dir. Returns preview information including URL, port, status, and project type. Stops any existing server for the session first.",
        "interface_type": "method",
        "name": "PreviewServerManager::start",
        "parameters": [
          {
            "description": "Unique identifier for the preview session",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": "Base directory path containing files to serve",
            "is_optional": false,
            "name": "base_dir",
            "param_type": "PathBuf"
          }
        ],
        "return_type": "Result<PreviewInfo, String>",
        "visibility": "public"
      },
      {
        "description": "Stops and removes the preview server for the specified session. Sets running flag to false, makes a request to unblock the server thread, and waits for thread termination.",
        "interface_type": "method",
        "name": "PreviewServerManager::stop",
        "parameters": [
          {
            "description": "Session identifier of the server to stop",
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      },
      {
        "description": "Scans ports 5000-6000 to find an available port by attempting TCP binding",
        "interface_type": "method",
        "name": "PreviewServerManager::find_available_port",
        "parameters": [],
        "return_type": "Result<u16, String>",
        "visibility": "private"
      },
      {
        "description": "Checks if a port is available by attempting to bind a TCP listener to it",
        "interface_type": "method",
        "name": "PreviewServerManager::is_port_available",
        "parameters": [
          {
            "description": "Port number to check for availability",
            "is_optional": false,
            "name": "port",
            "param_type": "u16"
          }
        ],
        "return_type": "bool",
        "visibility": "private"
      },
      {
        "description": "Detects project type by checking for index.html, package.json, and Cargo.toml files. Returns React, Html, Static, or Unknown",
        "interface_type": "method",
        "name": "PreviewServerManager::detect_project_type",
        "parameters": [
          {
            "description": "Base directory path to analyze",
            "is_optional": false,
            "name": "base_dir",
            "param_type": "&Path"
          }
        ],
        "return_type": "ProjectType",
        "visibility": "private"
      },
      {
        "description": "Processes HTTP request, maps URL to file path with URL decoding and security checks, reads file content, and returns response with appropriate MIME type and status code",
        "interface_type": "method",
        "name": "PreviewServerManager::handle_request",
        "parameters": [
          {
            "description": "Incoming HTTP request to process",
            "is_optional": false,
            "name": "request",
            "param_type": "&Request"
          },
          {
            "description": "Base directory containing files to serve",
            "is_optional": false,
            "name": "base_dir",
            "param_type": "&Path"
          },
          {
            "description": "Session identifier (currently unused)",
            "is_optional": false,
            "name": "session_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Response<std::io::Cursor<Vec<u8>>>",
        "visibility": "private"
      },
      {
        "description": "Returns appropriate MIME type string based on file extension, supporting HTML, CSS, JavaScript, JSON, images (PNG, JPG, GIF, SVG, ICO), fonts (WOFF, WOFF2, TTF), text files, and markdown",
        "interface_type": "method",
        "name": "PreviewServerManager::get_mime_type",
        "parameters": [
          {
            "description": "File path to determine MIME type for",
            "is_optional": false,
            "name": "path",
            "param_type": "&Path"
          }
        ],
        "return_type": "String",
        "visibility": "private"
      }
    ],
    "responsibilities": [
      "Manage lifecycle of multiple concurrent HTTP preview servers, including starting, stopping, and tracking server instances by session_id",
      "Handle HTTP requests by mapping URLs to file system paths, implementing security controls (path traversal prevention), and serving static files with proper MIME types",
      "Automatically detect project types (React, HTML, Static, Unknown) based on directory structure and configuration files",
      "Dynamically allocate available ports (5000-6000 range) for server instances using TCP binding checks",
      "Provide thread-safe state management for concurrent server operations using Arc<Mutex<T>> synchronization primitives"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "service",
      "description": "Top-level project management system for Cowork application that manages all Cowork projects across different directories. Provides centralized project registry functionality with persistent storage using JSON files.",
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\project_manager.rs",
      "functions": [
        "ProjectRegistry::default",
        "ProjectMetadata::default",
        "ProjectRegistryManager::new",
        "ProjectRegistryManager::load_registry_from_file",
        "ProjectRegistryManager::save_registry_to_file",
        "ProjectRegistryManager::register_project",
        "ProjectRegistryManager::get_all_projects",
        "ProjectRegistryManager::get_project",
        "ProjectRegistryManager::delete_project",
        "ProjectRegistryManager::update_project",
        "ProjectRegistryManager::update_last_opened",
        "ProjectRegistryManager::auto_register_current_project",
        "get_registry_path",
        "is_cowork_project",
        "detect_project_metadata",
        "detect_project_type",
        "detect_technology_stack"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "ProjectRegistryManager::new",
        "ProjectRegistryManager::register_project",
        "ProjectRegistryManager::get_all_projects",
        "ProjectRegistryManager::get_project",
        "ProjectRegistryManager::delete_project",
        "ProjectRegistryManager::update_project",
        "ProjectRegistryManager::update_last_opened",
        "ProjectRegistryManager::auto_register_current_project"
      ],
      "name": "project_manager.rs",
      "source_summary": "// Project Manager - Top-level project management system\n// Manages all Cowork projects across different directories\n\nuse anyhow::{Context, Result};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nconst SCHEMA_VERSION: &str = \"1.0\";\nconst REGISTRY_FILENAME: &str = \"project_registry.json\";\n\n// ============================================================================\n// Data Structures\n// ============================================================================\n\n/// Project Registry - stores all Cowork projects\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectRegistry {\n    pub schema_version: String,\n    pub projects: Vec<ProjectRecord>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl Default for ProjectRegistry {\n    fn default() -> Self {\n        Self {\n            schema_version: SCHEMA_VERSION.to_string(),\n            projects: Vec::new(),\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        }\n    }\n}\n\n/// Project Record - represents a single Cowork project\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectRecord {\n    pub project_id: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub workspace_path: String,\n    pub created_at: DateTime<Utc>,\n    pub last_opened_at: Option<DateTime<Utc>>,\n    pub status: ProjectStatus,\n    pub metadata: ProjectMetadata,\n}\n\n/// Project Status\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProjectStatus {\n    Active,\n    Archived,\n    Deleted,\n}\n\n/// Project Metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectMetadata {\n    pub session_count: usize,\n    pub last_session_id: Option<String>,\n    pub technology_stack: Vec<String>,\n    pub project_type: String,\n}\n\nimpl Default for ProjectMetadata {\n    fn default() -> Self {\n        Self {\n            session_count: 0,\n            last_session_id: None,\n            technology_stack: Vec::new(),\n            project_type: \"unknown\".to_string(),\n        }\n    }\n}\n\n/// Project Query Options\n#[derive(Debug, Clone, Default)]\npub struct ProjectQueryOptions {\n    pub status: Option<ProjectStatus>,\n    pub search: Option<String>,\n    pub limit: Option<usize>,\n}\n\n// ============================================================================\n// Project Registry Manager\n// ============================================================================\n\npub struct ProjectRegistryManager {\n    registry_path: PathBuf,\n    registry: ProjectRegistry,\n}\n\nimpl ProjectRegistryManager {\n    /// Create a new ProjectRegistryManager\n    pub fn new() -> Result<Self> {\n        let registry_path = get_registry_path()?;\n        \n        // Ensure the directory exists\n        if let Some(parent) = registry_path.parent() {\n            fs::create_dir_all(parent)\n                .context(\"Failed to create registry directory\")?;\n        }\n        \n        // Load or create registry\n        let registry = if registry_path.exists() {\n            Self::load_registry_from_file(&registry_path)?\n        } else {\n            ProjectRegistry::default()\n        };\n        \n        Ok(Self {\n            registry_path,\n            registry,\n        })\n    }\n    \n    /// Load registry from file\n    fn load_registry_from_file(path: &Path) -> Result<ProjectRegistry> {\n        let content = fs::read_to_string(path)\n            .context(\"Failed to read registry file\")?;\n        \n        let registry: ProjectRegistry = serde_json::from_str(&content)\n            .context(\"Failed to parse registry file\")?;\n        \n        // Validate schema version\n        if registry.schema_version != SCHEMA_VERSION {\n            tracing::warn!(\n                \"Registry schema version mismatch: expected {}, got {}\",\n                SCHEMA_VERSION,\n                registry.schema_version\n            );\n        }\n        \n        Ok(registry)\n    }\n    \n    /// Save registry to file\n    fn save_registry_to_file(&self) -> Result<()> {\n        let mut registry = self.registry.clone();\n        registry.updated_at = Utc::now();\n        \n        let content = serde_json::to_string_pretty(&registry)\n            .context(\"Failed to serialize registry\")?;\n        \n        fs::write(&self.registry_path, content)\n            .context(\"Failed to write registry file\")?;\n        \n        Ok(())\n    }\n    \n    /// Register a new project\n    pub fn register_project(\n        &mut self,\n        workspace_path: String,\n        name: String,\n        description: Option<String>,\n    ) -> Result<ProjectRecord> {\n        // Check if project already exists\n        if self.registry.projects.iter().any(|p| p.workspace_path == workspace_path) {\n            anyhow::bail!(\"Project already registered: {}\", workspace_path);\n        }\n        \n        // Validate and create workspace path if it doesn't exist\n        let workspace = Path::new(&workspace_path);\n        if !workspace.exists() {\n            // Create the directory if it doesn't exist\n            fs::create_dir_all(workspace)\n                .context(format!(\"Failed to create workspace directory: {}\", workspace_path))?;\n        }\n        \n        if !workspace.is_dir() {\n            anyhow::bail!(\"Workspace path is not a directory: {}\", workspace_path);\n        }\n        \n        // Detect project metadata\n        let metadata = detect_project_metadata(workspace)?;\n        \n        // Create project record\n        let project = ProjectRecord {\n            project_id: format!(\"proj-{}\", Utc::now().timestamp_millis()),\n            name,\n            description,\n            workspace_path,\n            created_at: Utc::now(),\n            last_opened_at: None,\n            status: ProjectStatus::Active,\n            metadata,\n        };\n        \n        // Add to registry\n        self.registry.projects.push(project.clone());\n        self.save_registry_to_file()?;\n        \n        Ok(project)\n    }\n    \n    /// Get all projects\n    pub fn get_all_projects(&self, options: Option<ProjectQueryOptions>) -> Vec<ProjectRecord> {\n        let mut projects = self.registry.projects.clone();\n        \n        // Apply filters\n        if let Some(opts) = options {\n            if let Some(status) = opts.status {\n                projects.retain(|p| p.status == status);\n            }\n            \n            if let Some(search) = opts.search {\n                let search_lower = search.to_lowercase();\n                projects.retain(|p| {\n                    p.name.to_lowercase().contains(&search_lower)\n                        || p.description\n                            .as_ref()\n                            .map(|d| d.to_lowercase().contains(&search_lower))\n                            .unwrap_or(false)\n                        || p.workspace_path.to_lowercase().contains(&search_lower)\n                });\n            }\n            \n            if let Some(limit) = opts.limit {\n                projects.truncate(limit);\n            }\n        }\n        \n        // Sort by last opened (most recent first)\n        projects.sort_by(|a, b| {\n            match (&a.last_opened_at, &b.last_opened_at) {\n                (Some(at_a), Some(at_b)) => at_b.cmp(at_a),\n                (Some(_), None) => std::cmp::Ordering::Less,\n                (None, Some(_)) => std::cmp::Ordering::Greater,\n                (None, None) => b.created_at.cmp(&a.created_at),\n            }\n        });\n        \n        projects\n    }\n    \n    /// Get project by ID\n    pub fn get_project(&self, project_id: &str) -> Option<ProjectRecord> {\n        self.registry.projects\n            .iter()\n            .find(|p| p.project_id == project_id)\n            .cloned()\n    }\n    \n    /// Delete a project\n    pub fn delete_project(&mut self, project_id: &str, delete_files: bool) -> Result<()> {\n        let index = self.registry.projects\n            .iter()\n            .position(|p| p.project_id == project_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Project not found: {}\", project_id))?;\n        \n        let project = &self.registry.projects[index];\n        \n        // Delete files if requested\n        if delete_files {\n            let workspace = Path::new(&project.workspace_path);\n            if workspace.exists() {\n                fs::remove_dir_all(workspace)\n                    .context(\"Failed to delete project files\")?;\n            }\n        }\n        \n        // Remove from registry\n        self.registry.projects.remove(index);\n        self.save_registry_to_file()?;\n        \n        Ok(())\n    }\n    \n    /// Update project information\n    pub fn update_project(\n        &mut self,\n        project_id: &str,\n        name: Option<String>,\n        description: Option<String>,\n        status: Option<ProjectStatus>,\n    ) -> Result<ProjectRecord> {\n        let index = self.registry.projects\n            .iter()\n            .position(|p| p.project_id == project_id)\n            .ok_or_else(|| anyhow::anyhow!(\"Project not found: {}\", project_id))?;\n        \n        let project = &mut self.registry.projects[index];\n        \n        if let Some(name) = name {\n            project.name = name;\n        }\n        \n        if let Some(description) = description {\n            project.description = Some(description);\n        }\n        \n        if let Some(status) = status {\n            project.status = status;\n        }\n        \n        // Clone before saving to avoid borrow issues\n        let result = project.clone();\n        \n        self.save_registry_to_file()?;\n        \n        Ok(result)\n    }\n    \n    /// Update last opened time\n    pub fn update_last_opened(&mut self, project_id: &str) -> Result<()> {\n        if let Some(project) = self.registry.projects\n            .iter_mut()\n            .find(|p| p.project_id == project_id)\n        {\n            project.last_opened_at = Some(Utc::now());\n            self.save_registry_to_file()?;\n        }\n        \n        Ok(())\n    }\n    \n    /// Auto-register current project if it's a Cowork project\n    pub fn auto_register_current_project(&mut self) -> Result<Option<ProjectRecord>> {\n        let current_dir = std::env::current_dir()\n            .context(\"Failed to get current directory\")?;\n        \n        // Check if it's a Cowork project\n        if !is_cowork_project(&current_dir)? {\n            return Ok(None);\n        }\n        \n        let workspace_path = current_dir.to_string_lossy().to_string();\n        \n        // Check if already registered\n        if self.registry.projects.iter().any(|p| p.workspace_path == workspace_path) {\n            return Ok(None);\n        }\n        \n        // Extract project name from directory\n        let project_name = current_dir\n            .file_name()\n            .and_then(|n| n.to_str())\n            .unwrap_or(\"Untitled Project\")\n            .to_string();\n        \n        // Register the project\n        let project = self.register_project(\n            workspace_path,\n            project_name,\n            None,\n        )?;\n        \n        Ok(Some(project))\n    }\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/// Get the registry file path (cross-platform)\nfn get_registry_path() -> Result<PathBuf> {\n    let base_dir = if cfg!(target_os = \"windows\") {\n        // Windows: %APPDATA%\\CoworkCreative\\\n        let appdata = std::env::var(\"APPDATA\")\n            .context(\"Failed to get APPDATA environment variable\")?;\n        PathBuf::from(appdata).join(\"CoworkCreative\")\n    } else if cfg!(target_os = \"macos\") {\n        // macOS: ~/Library/Application Support/CoworkCreative/\n        let home = std::env::var(\"HOME\")\n            .context(\"Failed to get HOME environment variable\")?;\n        PathBuf::from(home)\n            .join(\"Library\")\n            .join(\"Application Support\")\n            .join(\"CoworkCreative\")\n    } else {\n        // Linux: ~/.config/cowork-creative/\n        let home = std::env::var(\"HOME\")\n            .context(\"Failed to get HOME environment variable\")?;\n        PathBuf::from(home).join(\".config\").join(\"cowork-creative\")\n    };\n    \n    Ok(base_dir.join(REGISTRY_FILENAME))\n}\n\n/// Check if a directory is a Cowork project\nfn is_cowork_project(path: &Path) -> Result<bool> {\n    let cowork_dir = path.join(\".cowork\");\n    Ok(cowork_dir.exists() && cowork_dir.is_dir())\n}\n\n/// Detect project metadata from workspace\nfn detect_project_metadata(workspace: &Path) -> Result<ProjectMetadata> {\n    let mut metadata = ProjectMetadata::default();\n    \n    // Detect project type\n    metadata.project_type = detect_project_type(workspace);\n    \n    // Detect technology stack\n    metadata.technology_stack = detect_technology_stack(workspace);\n    \n    // Count sessions\n    let sessions_dir = workspace.join(\".cowork\").join(\"sessions\");\n    if sessions_dir.exists() {\n        metadata.session_count = fs::read_dir(sessions_dir)\n            .map(|entries| entries.filter_map(Result::ok).count())\n            .unwrap_or(0);\n        \n        // Find last session ID\n        if let Ok(entries) = fs::read_dir(&workspace.join(\".cowork\").join(\"sessions\")) {\n            if let Some(Ok(last_entry)) = entries.last() {\n                if let Some(name) = last_entry.file_name().to_str() {\n                    metadata.last_session_id = Some(name.to_string());\n                }\n            }\n        }\n    }\n    \n    Ok(metadata)\n}\n\n/// Detect project type\nfn detect_project_type(workspace: &Path) -> String {\n    // Check for common project indicators\n    if workspace.join(\"package.json\").exists() {\n        return \"nodejs\".to_string();\n    }\n    \n    if workspace.join(\"Cargo.toml\").exists() {\n        return \"rust\".to_string();\n    }\n    \n    if workspace.join(\"requirements.txt\").exists()\n        || workspace.join(\"pyproject.toml\").exists()\n        || workspace.join(\"setup.py\").exists()\n    {\n        return \"python\".to_string();\n    }\n    \n    if workspace.join(\"pom.xml\").exists() {\n        return \"java\".to_string();\n    }\n    \n    if workspace.join(\"go.mod\").exists() {\n        return \"go\".to_string();\n    }\n    \n    \"unknown\".to_string()\n}\n\n/// Detect technology stack\nfn detect_technology_stack(workspace: &Path) -> Vec<String> {\n    let mut stack = Vec::new();\n    \n    // Frontend frameworks\n    if workspace.join(\"package.json\").exists() {\n        stack.push(\"JavaScript\".to_string());\n        \n        if let Ok(content) = fs::read_to_string(workspace.join(\"package.json\")) {\n            if content.contains(\"\\\"react\\\"\") {\n                stack.push(\"React\".to_string());\n            }\n            if content.contains(\"\\\"vue\\\"\") {\n                stack.push(\"Vue\".to_string());\n            }\n            if content.contains(\"\\\"@angular\\\"\") {\n                stack.push(\"Angular\".to_string());\n            }\n            if content.contains(\"\\\"svelte\\\"\") {\n                stack.push(\"Svelte\".to_string());\n            }\n        }\n    }\n    \n    // Backend frameworks\n    if workspace.join(\"Cargo.toml\").exists() {\n        stack.push(\"Rust\".to_string());\n    }\n    \n    if workspace.join(\"requirements.txt\").exists()\n        || workspace.join(\"pyproject.toml\").exists()\n    {\n        stack.push(\"Python\".to_string());\n        \n        if let Ok(content) = fs::read_to_string(workspace.join(\"requirements.txt\")) {\n            if content.contains(\"django\") {\n                stack.push(\"Django\".to_string());\n            }\n            if content.contains(\"flask\") {\n                stack.push(\"Flask\".to_string());\n            }\n            if content.contains(\"fastapi\") {\n                stack.push(\"FastAPI\".to_string());\n            }\n        }\n    }\n    \n    stack\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_registry_default() {\n        let registry = ProjectRegistry::default();\n        assert_eq!(registry.schema_version, SCHEMA_VERSION);\n        assert!(registry.projects.is_empty());\n    }\n    \n    #[test]\n    fn test_project_metadata_default() {\n        let metadata = ProjectMetadata::default();\n        assert_eq!(metadata.session_count, 0);\n        assert!(metadata.last_session_id.is_none());\n        assert!(metadata.technology_stack.is_empty());\n    }\n}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 54.0,
      "lines_of_code": 518,
      "number_of_classes": 5,
      "number_of_functions": 19
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "chrono",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "implicit",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "implicit",
        "is_external": true,
        "line_number": null,
        "name": "tracing",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "std::fs",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The project_manager.rs component is a core service module that implements a comprehensive project management system for the Cowork application. It serves as the central authority for managing all Cowork projects across different directories through a centralized registry system.\n\nThe component is built around the ProjectRegistryManager struct, which maintains a persistent registry of projects stored in a JSON file (project_registry.json) located in platform-specific application data directories (Windows: %APPDATA%\\\\CoworkCreative, macOS: ~/Library/Application Support/CoworkCreative, Linux: ~/.config/cowork-creative). The registry includes comprehensive project metadata such as project ID, name, description, workspace path, creation/open timestamps, status (Active/Archived/Deleted), and additional metadata including session counts, technology stack, and project type.\n\nKey functionality includes:\n- Project Registration: Ability to register new projects with automatic workspace directory creation, duplicate detection, and automatic metadata detection including technology stack and project type identification\n- Project Query: Flexible querying with support for status filtering, text-based search across name/description/path, limit constraints, and intelligent sorting by last opened time\n- Project Management: Full CRUD operations including update capabilities for name, description, and status, along with deletion options that can optionally delete project files\n- Auto-registration: Intelligent detection and registration of Cowork projects when the application is run from within a project directory\n- Metadata Detection: Automatic detection of project types (Node.js, Rust, Python, Java, Go) and technology stacks (React, Vue, Angular, Django, Flask, etc.) by analyzing project configuration files\n- Session Tracking: Automatic tracking of session counts and last session IDs from .cowork/sessions directories\n\nThe component implements robust error handling using the anyhow crate, provides schema versioning for future compatibility, uses chrono for timestamp management, and implements serialization/deserialization via serde_json. All operations are persisted to disk automatically, ensuring data consistency across application restarts.",
    "interfaces": [
      {
        "description": "Creates a new ProjectRegistryManager instance, ensures registry directory exists, and loads existing registry or creates default",
        "interface_type": "constructor",
        "name": "ProjectRegistryManager::new",
        "parameters": [],
        "return_type": "Result<ProjectRegistryManager>",
        "visibility": "public"
      },
      {
        "description": "Registers a new project with workspace path validation, automatic directory creation, metadata detection, and duplicate prevention",
        "interface_type": "method",
        "name": "ProjectRegistryManager::register_project",
        "parameters": [
          {
            "description": "Path to the project workspace directory",
            "is_optional": false,
            "name": "workspace_path",
            "param_type": "String"
          },
          {
            "description": "Display name for the project",
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": "Optional project description",
            "is_optional": true,
            "name": "description",
            "param_type": "Option<String>"
          }
        ],
        "return_type": "Result<ProjectRecord>",
        "visibility": "public"
      },
      {
        "description": "Retrieves all projects with optional filtering by status, text search, and limit, sorted by last opened time descending",
        "interface_type": "method",
        "name": "ProjectRegistryManager::get_all_projects",
        "parameters": [
          {
            "description": "Optional query parameters including status filter, search term, and result limit",
            "is_optional": true,
            "name": "options",
            "param_type": "Option<ProjectQueryOptions>"
          }
        ],
        "return_type": "Vec<ProjectRecord>",
        "visibility": "public"
      },
      {
        "description": "Retrieves a specific project by its unique project ID",
        "interface_type": "method",
        "name": "ProjectRegistryManager::get_project",
        "parameters": [
          {
            "description": "Unique identifier of the project",
            "is_optional": false,
            "name": "project_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Option<ProjectRecord>",
        "visibility": "public"
      },
      {
        "description": "Deletes a project from registry with optional deletion of workspace files and directories",
        "interface_type": "method",
        "name": "ProjectRegistryManager::delete_project",
        "parameters": [
          {
            "description": "Unique identifier of the project to delete",
            "is_optional": false,
            "name": "project_id",
            "param_type": "&str"
          },
          {
            "description": "Whether to delete project files from disk",
            "is_optional": false,
            "name": "delete_files",
            "param_type": "bool"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Updates project information including name, description, and status with automatic persistence",
        "interface_type": "method",
        "name": "ProjectRegistryManager::update_project",
        "parameters": [
          {
            "description": "Unique identifier of the project",
            "is_optional": false,
            "name": "project_id",
            "param_type": "&str"
          },
          {
            "description": "Optional new name for the project",
            "is_optional": true,
            "name": "name",
            "param_type": "Option<String>"
          },
          {
            "description": "Optional new description for the project",
            "is_optional": true,
            "name": "description",
            "param_type": "Option<String>"
          },
          {
            "description": "Optional new status (Active/Archived/Deleted)",
            "is_optional": true,
            "name": "status",
            "param_type": "Option<ProjectStatus>"
          }
        ],
        "return_type": "Result<ProjectRecord>",
        "visibility": "public"
      },
      {
        "description": "Updates the last opened timestamp for a project to track usage patterns",
        "interface_type": "method",
        "name": "ProjectRegistryManager::update_last_opened",
        "parameters": [
          {
            "description": "Unique identifier of the project",
            "is_optional": false,
            "name": "project_id",
            "param_type": "&str"
          }
        ],
        "return_type": "Result<()>",
        "visibility": "public"
      },
      {
        "description": "Automatically detects and registers the current directory as a Cowork project if not already registered",
        "interface_type": "method",
        "name": "ProjectRegistryManager::auto_register_current_project",
        "parameters": [],
        "return_type": "Result<Option<ProjectRecord>>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manage centralized project registry with persistent JSON storage across cross-platform directories",
      "Provide comprehensive CRUD operations for project lifecycle management including registration, query, update, and deletion with optional file cleanup",
      "Automatically detect and analyze project metadata including technology stack, project type, and session information from workspace directories",
      "Handle cross-platform file system operations for registry storage with platform-specific path resolution (Windows, macOS, Linux)",
      "Implement intelligent project discovery and auto-registration capabilities with duplicate detection and workspace validation"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "service",
      "description": "A service component responsible for managing external process execution in a Tauri-based GUI application. It handles process lifecycle, output streaming, and event communication between backend processes and the frontend UI.",
      "file_path": "crates\\cowork-gui\\src-tauri\\src\\project_runner.rs",
      "functions": [
        "new",
        "set_app_handle",
        "start",
        "stop",
        "execute_command"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "project_runner.rs",
      "source_summary": "// Project runner for GUI\nuse std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse tokio::process::{Command, Child};\nuse tokio::sync::mpsc;\nuse tauri::Emitter;\n\npub struct ProjectRunner {\n    processes: Arc<Mutex<HashMap<String, ProjectProcess>>>,\n    app_handle: Arc<Mutex<Option<tauri::AppHandle>>>,\n}\n\nstruct ProjectProcess {\n    child: Child,\n    output_tx: mpsc::UnboundedSender<String>,\n}\n\nimpl ProjectRunner {\n    pub fn new() -> Self {\n        Self {\n            processes: Arc::new(Mutex::new(HashMap::new())),\n            app_handle: Arc::new(Mutex::new(None)),\n        }\n    }\n\n    pub fn set_app_handle(&self, handle: tauri::AppHandle) {\n        let mut app_handle_guard = self.app_handle.lock().unwrap();\n        *app_handle_guard = Some(handle);\n    }\n\n    pub async fn start(&self, session_id: String, command: String) -> Result<u32, String> {\n        // Stop existing process if any\n        if let Ok(()) = self.stop(session_id.clone()).await {\n            println!(\"[Runner] Stopped existing process for session: {}\", session_id);\n        }\n\n        // Get session directory\n        let code_dir = format!(\".cowork/sessions/{}/code\", session_id);\n        let code_path = std::path::Path::new(&code_dir);\n\n        if !code_path.exists() {\n            return Err(format!(\"Code directory not found: {}\", code_dir));\n        }\n\n        println!(\"[Runner] Starting command: {}\", command);\n\n        let mut child = Command::new(\"cmd\")\n            .args([\"/C\", &command])\n            .current_dir(&code_path)\n            .stdout(std::process::Stdio::piped())\n            .stderr(std::process::Stdio::piped())\n            .creation_flags(0x08000000) // CREATE_NO_WINDOW\n            .spawn()\n            .map_err(|e| format!(\"Failed to start: {}\", e))?;\n\n        let pid = child.id().unwrap();\n\n        // Get app handle for event emission\n        let app_handle_opt = self.app_handle.lock().unwrap().clone();\n        let session_id_clone = session_id.clone();\n\n        // Create channels for output\n        let (stdout_tx, _stdout_rx) = mpsc::unbounded_channel();\n        let (stderr_tx, _stderr_rx) = mpsc::unbounded_channel();\n\n        // Clone child for stdout reading\n        let stdout = child.stdout.take().unwrap();\n        let stderr = child.stderr.take().unwrap();\n\n        // Clone senders for spawn tasks\n        let stdout_tx_spawn = stdout_tx.clone();\n        let stderr_tx_spawn = stderr_tx.clone();\n        \n        // Clone app_handle and session_id for stdout task\n        let app_handle_stdout = app_handle_opt.clone();\n        let session_id_stdout = session_id_clone.clone();\n\n        // Spawn task to read stdout and emit events\n        tokio::spawn(async move {\n            use tokio::io::{AsyncBufReadExt, BufReader};\n            let mut reader = BufReader::new(stdout);\n            let mut line = String::new();\n            \n            loop {\n                match reader.read_line(&mut line).await {\n                    Ok(0) => break,\n                    Ok(_) => {\n                        let _ = stdout_tx_spawn.send(line.clone());\n                        \n                        // Emit event to frontend\n                        if let Some(ref handle) = app_handle_stdout {\n                            if let Err(e) = handle.emit(\"process_output\", serde_json::json!({\n                                \"session_id\": session_id_stdout,\n                                \"output_type\": \"stdout\",\n                                \"content\": line.clone()\n                            })) {\n                                eprintln!(\"[Runner] Failed to emit process_output event: {}\", e);\n                            }\n                        }\n                        \n                        line.clear();\n                    }\n                    Err(e) => {\n                        eprintln!(\"[Runner] Error reading stdout: {}\", e);\n                        \n                        // Emit error event\n                        if let Some(ref handle) = app_handle_stdout {\n                            if let Err(e) = handle.emit(\"process_error\", serde_json::json!({\n                                \"session_id\": session_id_stdout,\n                                \"error\": e.to_string()\n                            })) {\n                                eprintln!(\"[Runner] Failed to emit process_error event: {}\", e);\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n\n        // Spawn task to read stderr and emit events\n        tokio::spawn(async move {\n            use tokio::io::{AsyncBufReadExt, BufReader};\n            let mut reader = BufReader::new(stderr);\n            let mut line = String::new();\n            \n            loop {\n                match reader.read_line(&mut line).await {\n                    Ok(0) => break,\n                    Ok(_) => {\n                        let _ = stderr_tx_spawn.send(line.clone());\n                        \n                        // Emit event to frontend\n                        if let Some(ref handle) = app_handle_opt {\n                            if let Err(e) = handle.emit(\"process_output\", serde_json::json!({\n                                \"session_id\": session_id_clone,\n                                \"output_type\": \"stderr\",\n                                \"content\": line.clone()\n                            })) {\n                                eprintln!(\"[Runner] Failed to emit process_output event: {}\", e);\n                            }\n                        }\n                        \n                        line.clear();\n                    }\n                    Err(e) => {\n                        eprintln!(\"[Runner] Error reading stderr: {}\", e);\n                        \n                        // Emit error event\n                        if let Some(ref handle) = app_handle_opt {\n                            if let Err(e) = handle.emit(\"process_error\", serde_json::json!({\n                                \"session_id\": session_id_clone,\n                                \"error\": e.to_string()\n                            })) {\n                                eprintln!(\"[Runner] Failed to emit process_error event: {}\", e);\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n\n        let mut processes = self.processes.lock().unwrap();\n        processes.insert(session_id, ProjectProcess {\n            child,\n            output_tx: stdout_tx,\n        });\n\n        println!(\"[Runner] Process started with PID: {}\", pid);\n        Ok(pid)\n    }\n\n    pub async fn stop(&self, session_id: String) -> Result<(), String> {\n        // Remove process from map and release lock before await\n        let process = {\n            let mut processes = self.processes.lock().unwrap();\n            processes.remove(&session_id)\n        };\n        \n        if let Some(mut process) = process {\n            println!(\"[Runner] Stopping process for session: {}\", session_id);\n            \n            process.child.kill()\n                .await\n                .map_err(|e| format!(\"Failed to stop: {}\", e))?;\n            \n            // Emit stopped event\n            if let Some(ref handle) = *self.app_handle.lock().unwrap() {\n                let _ = handle.emit(\"process_stopped\", serde_json::json!({\n                    \"session_id\": session_id\n                }));\n            }\n            \n            println!(\"[Runner] Process stopped\");\n            Ok(())\n        } else {\n            Err(format!(\"No running process for session: {}\", session_id))\n        }\n    }\n\n    pub async fn execute_command(&self, _session_id: String, command: String) -> Result<String, String> {\n        println!(\"[Runner] Executing command: {}\", command);\n\n        let project_root = cowork_core::storage::get_project_root()\n            .map_err(|e| format!(\"Failed to get project root: {}\", e))?;\n\n        if !project_root.exists() {\n            return Err(format!(\"Project directory not found: {}\", project_root.display()));\n        }\n\n        let output = Command::new(\"cmd\")\n            .args([\"/C\", &command])\n            .current_dir(&project_root)\n            .stdout(std::process::Stdio::piped())\n            .stderr(std::process::Stdio::piped())\n            .creation_flags(0x08000000) // CREATE_NO_WINDOW\n            .output()\n            .await;\n\n        match output {\n            Ok(output) => {\n                let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n                let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n                \n                let result = format!(\"Exit code: {:?}\\n\\nSTDOUT:\\n{}\\n\\nSTDERR:\\n{}\", \n                    output.status.code(), stdout, stderr);\n                \n                Ok(result)\n            }\n            Err(e) => {\n                Err(format!(\"Failed to execute command: {}\", e))\n            }\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 27.0,
      "lines_of_code": 236,
      "number_of_classes": 2,
      "number_of_functions": 5
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "std",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "tauri",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "cowork_core",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "The ProjectRunner is a critical service component in the cowork-gui application that manages external process execution and communication with the frontend. The component provides a session-based process management system where each session can have its own running process. It asynchronously spawns processes using tokio, captures their stdout and stderr streams in real-time, and forwards output events to the Tauri frontend through the event system. The component supports both long-running background processes (start/stop) and one-off command execution. Process management is isolated by session ID, allowing multiple concurrent processes. The implementation uses Windows-specific command execution (cmd /C) with CREATE_NO_WINDOW flag for headless process spawning. Output streaming is handled through separate tokio tasks that read from BufReader and emit process_output events. Error handling includes emitting process_error events when reading fails. The component maintains thread-safe state using Arc<Mutex<>> patterns for both the process registry and app handle storage.",
    "interfaces": [
      {
        "description": "Creates a new ProjectRunner instance with empty process registry and uninitialized app handle",
        "interface_type": "constructor",
        "name": "new",
        "parameters": [],
        "return_type": "Self",
        "visibility": "public"
      },
      {
        "description": "Sets the Tauri AppHandle reference required for event emission to frontend",
        "interface_type": "method",
        "name": "set_app_handle",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "handle",
            "param_type": "tauri::AppHandle"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Starts a new process for the given session, stops any existing process, spawns output streaming tasks, and returns the process ID",
        "interface_type": "method",
        "name": "start",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "command",
            "param_type": "String"
          }
        ],
        "return_type": "Result<u32, String>",
        "visibility": "public"
      },
      {
        "description": "Stops and removes the process associated with the given session ID by killing the child process and emitting a stopped event",
        "interface_type": "method",
        "name": "stop",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "session_id",
            "param_type": "String"
          }
        ],
        "return_type": "Result<(), String>",
        "visibility": "public"
      },
      {
        "description": "Executes a one-off command synchronously and returns the combined stdout, stderr, and exit code",
        "interface_type": "method",
        "name": "execute_command",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "_session_id",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "command",
            "param_type": "String"
          }
        ],
        "return_type": "Result<String, String>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Process lifecycle management - starting, stopping, and tracking external processes with session-based isolation",
      "Real-time output streaming - capturing stdout/stderr from child processes and forwarding to frontend via Tauri events",
      "Event communication - emitting process status, output, and error events to the frontend UI",
      "One-off command execution - running standalone commands and returning their complete output",
      "Session-based process registry - maintaining a thread-safe mapping of session IDs to running processes"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "util",
      "description": "Placeholder module intended for data schema validation utilities",
      "file_path": "crates\\cowork-core\\src\\data\\schemas\\validation.rs",
      "functions": [],
      "importance_score": 0.75,
      "interfaces": [],
      "name": "validation.rs",
      "source_summary": "// Validation utilities for data schemas\r\n// This module provides validation logic for structured data\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 2,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "The validation.rs component is currently a stub module located within the data schemas package of the cowork-core crate. As indicated by the inline comments, this module is intended to provide validation utilities for structured data and data schemas. However, at present, the component contains only documentation comments (2 lines) and has no actual implementation. The module serves as a placeholder that defines the intent and purpose of future validation logic but does not currently provide any functional capabilities. The positioning within the data/schemas subdirectory suggests it is designed to support data validation requirements across the cowork-core system, likely to be consumed by other components that need to verify the integrity and correctness of structured data before processing.",
    "interfaces": [],
    "responsibilities": [
      "Serve as a placeholder module for future data schema validation implementation",
      "Document the intended purpose of providing validation logic for structured data",
      "Define the architectural contract for validation utilities within the data schemas package",
      "Prepare the namespace for future validation functions and utilities to be added",
      "Provide code organization and structural support for data validation concerns"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Module declaration file that exposes a validation submodule for JSON Schema definitions used in data validation throughout the application.",
      "file_path": "crates\\cowork-core\\src\\data\\schemas.rs",
      "functions": [],
      "importance_score": 0.75,
      "interfaces": [],
      "name": "schemas.rs",
      "source_summary": "// JSON Schema definitions (for validation)\r\npub mod validation;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 2,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "The schemas.rs file is a minimal module declaration component located in the data layer of the cowork-core crate. It serves as a structural organizer that exposes a public 'validation' submodule containing JSON Schema definitions for data validation purposes. The file itself contains only two lines: a descriptive comment and a module declaration. Its primary role is to provide a clean namespace and access point for validation-related functionality, supporting separation of concerns within the data module. The component delegates all actual validation logic and schema definitions to the validation submodule, following Rust's module organization patterns for maintaining clean, hierarchical code structure.",
    "interfaces": [],
    "responsibilities": [
      "Module organization and namespace provision for schema-related functionality",
      "Exposing validation submodule containing JSON Schema definitions",
      "Supporting data integrity through organized validation schema access",
      "Providing structural separation between general data components and validation-specific functionality",
      "Acting as a gateway to validation-related data structures"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Data module re-export aggregator that serves as the entry point for data-related submodules. It organizes and exposes public interfaces from the models and schemas submodules, creating a unified namespace for data layer components.",
      "file_path": "crates\\cowork-core\\src\\data\\mod.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Data models module\r\npub mod models;\r\npub mod schemas;\r\n\r\n#[cfg(test)]\r\nmod models_test;\r\n\r\npub use models::*;\r\npub use schemas::*;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 9,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 2,
        "name": "models",
        "path": "models",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 3,
        "name": "schemas",
        "path": "schemas",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 6,
        "name": "models_test",
        "path": "models_test",
        "version": null
      }
    ],
    "detailed_description": "This module acts as a facade and organizational hub for the cowork-core data layer. It declares two primary submodules (models and schemas) and conditionally includes test code. The module uses Rust's re-export pattern (pub use) to flatten the internal module hierarchy, exposing all items from models and schemas through a single unified interface. This pattern simplifies external consumption by allowing callers to use `use crate::data::{Model, Schema}` instead of navigating the internal structure. The #[cfg(test)] attribute ensures test code is only compiled during test runs, keeping production binaries lean. The dependent test file shows this module provides types like Requirements, FeatureList, DesignSpec, ImplementationPlan, and utility functions like generate_id for the cowork system.",
    "interfaces": [],
    "responsibilities": [
      "Organize and manage data-related submodules by declaring models and schemas as public submodules",
      "Export public interfaces from internal submodules to create a unified data layer API using pub use statements",
      "Integrate test code conditionally through #[cfg(test)] attribute to separate test concerns from production code",
      "Provide namespace management and abstraction by flattening internal module hierarchy for external consumers",
      "Act as the single entry point for all data layer functionality in the cowork-core crate"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Agent instructions module - Central registry for prompt templates used by different agents in the workflow. Declares and re-exports submodules for each workflow stage (idea, prd, design, plan, coding, check, delivery) and modification operations (modify, code_patch, modify_delivery).",
      "file_path": "crates\\cowork-core\\src\\instructions\\mod.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Agent instructions - Prompt templates for each agent\r\n\r\npub mod idea;\r\npub mod prd;\r\npub mod design;\r\npub mod plan;\r\npub mod coding;\r\npub mod check;\r\npub mod delivery;\r\npub mod modify;\r\npub mod code_patch;\r\npub mod modify_delivery;\r\n\r\npub use idea::*;\r\npub use prd::*;\r\npub use design::*;\r\npub use plan::*;\r\npub use coding::*;\r\npub use check::*;\r\npub use delivery::*;\r\npub use modify::*;\r\npub use code_patch::*;\r\npub use modify_delivery::*;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 23,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This module serves as a central aggregation hub for agent instruction templates in the cowork-core crate. Its primary function is to organize and expose prompt templates that guide AI agents through different stages of a software development workflow.\n\nThe module declares 10 submodules, each representing a specific workflow stage or operation: `idea` for ideation phase, `prd` for product requirement document generation, `design` for design phase, `plan` for project planning, `coding` for implementation, `check` for quality verification, `delivery` for deployment/release, `modify` for general modifications, `code_patch` for specific code patching operations, and `modify_delivery` for delivery-time modifications.\n\nAll submodules are re-exported with `pub use *` statements, making this module the single entry point for accessing all instruction templates. The comment \"Agent instructions - Prompt templates for each agent\" clarifies its purpose as a prompt management system for multi-agent workflows.",
    "interfaces": [],
    "responsibilities": [
      "Module aggregation and organization: Declares 10 submodules representing different workflow stages and operations, establishing a clear structural hierarchy for instruction templates",
      "Public API surface definition: Re-exports all public items from submodules using `pub use *` statements, consolidating the instruction template interface into a single access point",
      "Workflow phase categorization: Organizes instructions into logical groups following the software development lifecycle (idea → prd → design → plan → coding → check → delivery)",
      "Instruction distribution hub: Acts as the central provider of prompt templates for agent implementations throughout the cowork-core system",
      "Namespace management: Creates a clean module boundary for all instruction-related functionality within the core crate"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Main library entry point and module orchestrator for the cowork-core crate, managing the public API structure and coordinating architectural migration from legacy to domain-driven design.",
      "file_path": "crates\\cowork-core\\src\\lib.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "lib.rs",
      "source_summary": "// Cowork Forge - Core Library (Iteration Architecture)\n\n// New domain-driven modules\npub mod domain;\npub mod persistence;\n\n// Existing modules (to be gradually refactored)\npub mod llm;\npub mod tools;\npub mod agents;\npub mod pipeline;\npub mod instructions;\npub mod interaction;\npub mod event_bus;\n\n// Legacy modules (will be removed)\npub mod data;\npub mod storage;\npub mod memory;\n\n// Re-exports for convenience\npub use domain::*;\npub use persistence::*;\npub use llm::*;\n\n// Version info\npub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 27,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "The lib.rs file serves as the primary library entry point and module orchestrator for the cowork-core crate within the Cowork Forge project. This component acts as a central facade that defines and exposes the public API structure of the core library. It manages the organization of 11 sub-modules across three categories: new domain-driven modules (domain, persistence), existing modules being refactored (llm, tools, agents, pipeline, instructions, interaction, event_bus), and legacy modules slated for removal (data, storage, memory). The component provides convenience re-exports of key modules (domain, persistence, llm) to simplify external API usage, and exposes the crate version information as a public constant. This file has minimal business logic itself, operating primarily as a coordinator and API boundary enforcer. The code reveals an active architectural evolution from legacy design to clean domain-driven architecture, with the component serving as the migration coordinator during this transition period.",
    "interfaces": [],
    "responsibilities": [
      "Module coordination and organization - centralizing and structuring all sub-modules to define the library's internal architecture and module hierarchy",
      "Public API facade management - controlling the external interface through selective re-exports and determining what constitutes the stable public API",
      "Architectural migration coordination - managing the coexistence of new domain-driven, existing in-refactor, and legacy modules during the architectural transition",
      "Library metadata provision - exposing version information for programmatic access and tracking"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "LLM module organizational file that serves as the entry point and facade for configuring and rate limiting components",
      "file_path": "crates\\cowork-core\\src\\llm\\mod.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [
        "config",
        "rate_limiter"
      ],
      "name": "mod.rs",
      "source_summary": "// LLM module - Using adk-rust's built-in OpenAI client with custom base URL\r\npub mod config;\r\npub mod rate_limiter;\r\n\r\npub use config::*;\r\npub use rate_limiter::*;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 6,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "config",
        "path": "config.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 5,
        "name": "rate_limiter",
        "path": "rate_limiter.rs",
        "version": null
      }
    ],
    "detailed_description": "This is a Rust module declaration file (`mod.rs`) that functions as the organizational entry point for the LLM (Large Language Model) subsystem within the cowork-core crate. The file implements a facade pattern by declaring two sub-modules (`config` and `rate_limiter`) and re-exporting all their public items using wildcard imports (`pub use *`). This design provides a unified public API surface for LLM-related functionality, allowing consumers to access configuration management and rate limiting capabilities through a single module entry point. The module is designed to work with adk-rust's built-in OpenAI client with custom base URL configuration, indicating it's part of a system that integrates with LLM services while providing local abstractions for configuration control and request throttling. The file's simplicity reflects the standard Rust convention of using mod.rs as a module coordinator rather than implementing logic directly.",
    "interfaces": [
      {
        "description": "Configuration management interface for LLM settings including custom base URLs and client parameters",
        "interface_type": "module",
        "name": "config",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "Rate limiting interface for controlling LLM request frequency and managing API quotas",
        "interface_type": "module",
        "name": "rate_limiter",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Module organization: Acts as the root module coordinator for LLM-related components, structuring the codebase into logical sub-modules",
      "Public API exposure: Re-exports all public items from sub-modules to provide a unified interface for LLM configuration and rate limiting",
      "Facade pattern implementation: Simplifies client usage by aggregating related functionality behind a single module boundary",
      "Subsystem boundary definition: Establishes clear separation between LLM functionality and other system components within the cowork-core crate",
      "Integration preparation: Sets up the module structure for integrating with adk-rust's OpenAI client with custom base URL support"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Persistence module that provides file system storage functionality for the cowork project. It serves as the entry point for all persistence-related operations, managing directory structures and re-exporting storage modules for iteration, memory, and project data.",
      "file_path": "crates\\cowork-core\\src\\persistence\\mod.rs",
      "functions": [
        "get_cowork_dir",
        "init_project_structure"
      ],
      "importance_score": 0.6,
      "interfaces": [
        "iteration_store",
        "memory_store",
        "project_store"
      ],
      "name": "mod.rs",
      "source_summary": "// Persistence module - File system storage\r\nuse std::path::PathBuf;\r\n\r\npub mod iteration_store;\r\npub mod memory_store;\r\npub mod project_store;\r\n\r\npub use iteration_store::*;\r\npub use memory_store::*;\r\npub use project_store::*;\r\n\r\nconst COWORK_DIR: &str = \".cowork-v2\";\r\n\r\n/// Get the .cowork directory path\r\npub fn get_cowork_dir() -> anyhow::Result<PathBuf> {\r\n    let path = PathBuf::from(COWORK_DIR);\r\n    std::fs::create_dir_all(&path)?;\r\n    Ok(path)\r\n}\r\n\r\n/// Initialize project structure\r\npub fn init_project_structure(_project_name: &str) -> anyhow::Result<PathBuf> {\r\n    let cow_dir = get_cowork_dir()?;\r\n\r\n    // Create subdirectories\r\n    std::fs::create_dir_all(cow_dir.join(\"iterations\"))?;\r\n    std::fs::create_dir_all(cow_dir.join(\"memory/project\"))?;\r\n    std::fs::create_dir_all(cow_dir.join(\"memory/iterations\"))?;\r\n    std::fs::create_dir_all(cow_dir.join(\"workspace\"))?;\r\n\r\n    Ok(cow_dir)\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 32,
      "number_of_classes": 0,
      "number_of_functions": 2
    },
    "dependencies": [
      {
        "dependency_type": "use",
        "is_external": true,
        "line_number": 2,
        "name": "std::path::PathBuf",
        "path": "std::path",
        "version": null
      },
      {
        "dependency_type": "external_library",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 4,
        "name": "iteration_store",
        "path": "iteration_store",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 5,
        "name": "memory_store",
        "path": "memory_store",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": 6,
        "name": "project_store",
        "path": "project_store",
        "version": null
      }
    ],
    "detailed_description": "This module is the core persistence layer of the cowork project, responsible for managing file system storage operations. It serves as an organizational hub that aggregates three key storage sub-modules: iteration_store, memory_store, and project_store, providing a unified interface for data persistence operations.\n\nThe module defines the fundamental directory structure for the cowork workspace, using a fixed directory name \\\".cowork-v2\\\" to store all project-related data. The primary functionality includes:\n\n1. Directory Structure Management: The get_cowork_dir() function ensures the existence of the base cowork directory and returns its path as a PathBuf, providing a centralized entry point for all file system operations.\n\n2. Project Initialization: The init_project_structure() function creates the complete directory hierarchy required by the cowork system, including:\n   - iterations/ - for storing iteration-related data\n   - memory/project/ - for project-specific memory storage\n   - memory/iterations/ - for iteration-specific memory storage\n   - workspace/ - for general workspace files\n\nBoth functions return anyhow::Result types to handle potential I/O errors gracefully, following Rust's error handling best practices. The module also re-exports all public items from its sub-modules using the `pub use` pattern, providing a clean, unified API for consumers of the persistence layer.\n\nThis design follows a modular architecture where the parent module (this file) handles cross-cutting concerns like directory structure and initialization, while delegating specific storage implementations to specialized sub-modules.",
    "interfaces": [
      {
        "description": "Creates and returns the .cowork-v2 directory path. Ensures the base directory exists before returning the path.",
        "interface_type": "function",
        "name": "get_cowork_dir",
        "parameters": [
          {
            "description": "Static function, no parameters",
            "is_optional": false,
            "name": "self",
            "param_type": "None"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "public"
      },
      {
        "description": "Initializes the complete project directory structure including all required subdirectories (iterations, memory/project, memory/iterations, workspace). Returns the path to the cowork directory.",
        "interface_type": "function",
        "name": "init_project_structure",
        "parameters": [
          {
            "description": "Project name parameter (currently unused, prefixed with _ to indicate intentional non-use)",
            "is_optional": false,
            "name": "_project_name",
            "param_type": "&str"
          }
        ],
        "return_type": "anyhow::Result<PathBuf>",
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Manage and initialize the cowork project directory structure (.cowork-v2)",
      "Coordinate and re-export persistence functionality from sub-modules (iteration_store, memory_store, project_store)",
      "Provide utility functions for file system path resolution and directory creation",
      "Ensure proper error handling for all file system operations using anyhow",
      "Define and maintain the standardized workspace directory layout for the cowork system"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Module organizer for pipeline stages in a software development workflow system",
      "file_path": "crates\\cowork-core\\src\\pipeline\\stages\\mod.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Pipeline stages\r\n\r\n\r\npub mod idea;\r\npub mod prd;\r\npub mod design;\r\npub mod plan;\r\npub mod coding;\r\npub mod check;\r\npub mod delivery;\r\n\r\npub use coding::CodingStage;\r\npub use check::CheckStage;\r\npub use delivery::DeliveryStage;\r\npub use design::DesignStage;\r\npub use idea::IdeaStage;\r\npub use plan::PlanStage;\r\npub use prd::PrdStage;\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 18,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This module (`mod.rs`) serves as a central organizational hub for the pipeline stages subsystem within the cowork-core system. It implements a Software Development Lifecycle (SDLC) pattern by organizing seven distinct development stages: Idea, PRD (Product Requirements Document), Design, Plan, Coding, Check (testing/quality assurance), and Delivery. The module follows Rust's module system conventions where mod.rs acts as the entry point for the stages directory, aggregating all stage-specific submodules and providing a unified export interface. Each stage module (idea, prd, design, plan, coding, check, delivery) encapsulates the logic and data structures for a particular phase of the development pipeline. The module uses pub use declarations to re-export the main stage structs (IdeaStage, PrdStage, DesignStage, PlanStage, CodingStage, CheckStage, DeliveryStage), enabling external components to import these types directly from the stages module without needing to know the internal file structure. This creates a clean abstraction layer and simplifies the import API for consumers of the pipeline stages.",
    "interfaces": [],
    "responsibilities": [
      "Module Organization and Aggregation - Centralizes all pipeline stage modules (idea, prd, design, plan, coding, check, delivery) under a unified namespace",
      "Export Interface Management - Provides clean public API by re-exporting all stage types (IdeaStage, PrdStage, DesignStage, PlanStage, CodingStage, CheckStage, DeliveryStage) for external access",
      "SDLC Pipeline Structure - Defines and enforces the logical sequence of software development stages in the coworking system",
      "Namespace Facade - Acts as a structural facade that hides the internal organization of stage implementations while exposing necessary types",
      "Dependency Coordination - Ensures all pipeline stage modules are properly loaded and accessible throughout the application"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "module",
      "description": "Central module for organizing and exporting various tool implementations in the adk-rust system",
      "file_path": "crates\\cowork-core\\src\\tools\\mod.rs",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "mod.rs",
      "source_summary": "// Tools module - adk-rust Tool implementations\npub mod data_tools;\npub mod validation_tools;\npub mod control_tools;\npub mod file_tools;\npub mod artifact_tools;\npub mod goto_stage_tool;\npub mod test_lint_tools;\npub mod hitl_tools;\npub mod hitl_content_tools;\npub mod modify_tools;\npub mod idea_tools;\npub mod memory_tools;\n\npub use data_tools::*;\npub use validation_tools::*;\npub use control_tools::*;\npub use file_tools::*;\npub use artifact_tools::*;\npub use goto_stage_tool::*;\npub use test_lint_tools::*;\npub use hitl_tools::*;\npub use hitl_content_tools::{ReviewAndEditContentTool, ReviewWithFeedbackContentTool, set_interaction_backend};\npub use modify_tools::*;\npub use idea_tools::*;\npub use memory_tools::*;\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 26,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This module serves as the central organizational hub for all tool implementations within the cowork-core crate. It functions as a module aggregator that defines and exports twelve distinct tool categories, each encapsulating specific functionality for the ADK (Agent Development Kit) system. The module provides a unified access point through re-exports, enabling external consumers to import tool functionalities directly from the tools module without needing to know the internal submodule structure. The tools cover a comprehensive range of capabilities including data processing, validation, control flow, file operations, artifact management, stage navigation, testing, human-in-the-loop interactions, content modification, idea generation, and memory management. Notably, it includes specific selective re-exports for HITL (Human-in-the-Loop) content tools, explicitly exposing ReviewAndEditContentTool, ReviewWithFeedbackContentTool, and set_interaction_backend function, while using wildcard exports for most other tool categories to simplify the public API surface.",
    "interfaces": [],
    "responsibilities": [
      "Aggregate and organize tool implementations into logical submodules based on functionality categories",
      "Provide a unified public API by re-exporting interfaces from all tool submodules for external access",
      "Establish the namespace structure and module hierarchy for the tools subsystem",
      "Control API visibility and surface through selective re-exports (e.g., explicit HITL tool exports vs wildcard exports)",
      "Serve as the architectural gateway for accessing all tool-related functionality in the cowork-core system"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": "The main HTML entry point for the Cowork Forge GUI web application, serving as the mounting container for a JavaScript-based Single Page Application (SPA).",
      "file_path": "crates\\cowork-gui\\src\\index.html",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "index.html",
      "source_summary": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Cowork Forge GUI</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/main.jsx\"></script>\n  </body>\n</html>\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 13,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [
      {
        "dependency_type": "static_asset",
        "is_external": false,
        "line_number": 4,
        "name": "/vite.svg",
        "path": "/vite.svg",
        "version": null
      },
      {
        "dependency_type": "module_import",
        "is_external": false,
        "line_number": 8,
        "name": "/main.jsx",
        "path": "/main.jsx",
        "version": null
      }
    ],
    "detailed_description": "This file is the foundational HTML document that serves as the entry point for the Cowork Forge GUI web application. It is a minimal, standard HTML5 template designed for modern Single Page Application (SPA) frameworks, specifically built for use with a bundler like Vite (evidenced by the /vite.svg favicon reference and /main.jsx module loading). The file contains no business logic but provides the essential structure for the browser to load and initialize the JavaScript application. It includes proper HTML5 boilerplate with language declaration, character encoding (UTF-8), responsive viewport configuration, and a root DOM element with id 'root' where the React/JavaScript application will be mounted. The application is loaded as an ES module through the script tag pointing to /main.jsx, which is typical for modern build tool chains that handle module bundling and transpilation.",
    "interfaces": [],
    "responsibilities": [
      "Provide the HTML5 document structure and bootstrap the web application environment",
      "Serve as the mounting container (div#root) for the JavaScript/React application to render into",
      "Configure essential application metadata including charset, viewport for responsive design, page title, and favicon",
      "Initiate the application by loading the main JavaScript module (/main.jsx) as an ES module",
      "Establish the initial browser context and DOM structure for the SPA to operate within"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "Global CSS stylesheet defining the visual theme, Ant Design component overrides, and custom UI component styles for the cowork-gui application.",
      "file_path": "crates\\cowork-gui\\src\\styles.css",
      "functions": [],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "styles.css",
      "source_summary": "* {\r\n  margin: 0;\r\n  padding: 0;\r\n  box-sizing: border-box;\r\n}\r\n\r\n/* ==========================================\r\n   清新浅色主题 - Fresh Light Theme\r\n   ========================================== */\r\n:root {\r\n  /* 主色调 - 清新的蓝色系 */\r\n  --primary: #2563eb;\r\n  --primary-hover: #1d4ed8;\r\n  --primary-light: #dbeafe;\r\n  --primary-lighter: #eff6ff;\r\n  \r\n  /* 背景色 - 纯净白色系 */\r\n  --bg-base: #ffffff;\r\n  --bg-container: #f8fafc;\r\n  --bg-elevated: #f1f5f9;\r\n  --bg-elevated-hover: #e2e8f0;\r\n  --bg-sidebar: #f8fafc;\r\n  \r\n  /* 边框颜色 - 柔和的灰色 */\r\n  --border-color: #e2e8f0;\r\n  --border-light: #f1f5f9;\r\n  \r\n  /* 文字颜色 - 清晰的层次 */\r\n  --text-primary: #1e293b;\r\n  --text-secondary: #64748b;\r\n  --text-tertiary: #94a3b8;\r\n  --text-muted: #cbd5e1;\r\n  \r\n  /* 状态颜色 */\r\n  --success: #10b981;\r\n  --success-light: #d1fae5;\r\n  --warning: #f59e0b;\r\n  --warning-light: #fef3c7;\r\n  --error: #ef4444;\r\n  --error-light: #fee2e2;\r\n  --info: #3b82f6;\r\n  --info-light: #dbeafe;\r\n}\r\n\r\nbody {\r\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\r\n  background: var(--bg-base);\r\n  color: var(--text-primary);\r\n  height: 100vh;\r\n  overflow: hidden;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n}\r\n\r\n/* ==========================================\r\n   Ant Design 浅色主题覆盖\r\n   ========================================== */\r\n\r\n/* Layout */\r\n.ant-layout {\r\n  background: var(--bg-base) !important;\r\n}\r\n\r\n.ant-layout-header {\r\n  background: var(--bg-base) !important;\r\n  border-bottom: 1px solid var(--border-color);\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\r\n}\r\n\r\n.ant-layout-sider {\r\n  background: var(--bg-sidebar) !important;\r\n  border-right: 1px solid var(--border-color);\r\n}\r\n\r\n/* Menu */\r\n.ant-menu {\r\n  background: transparent !important;\r\n  border-right: none !important;\r\n}\r\n\r\n.ant-menu-item {\r\n  color: var(--text-secondary) !important;\r\n  border-radius: 8px !important;\r\n  margin: 4px 12px !important;\r\n  padding-left: 16px !important;\r\n  transition: all 0.2s ease !important;\r\n}\r\n\r\n.ant-menu-item:hover {\r\n  background: var(--bg-elevated) !important;\r\n  color: var(--text-primary) !important;\r\n}\r\n\r\n.ant-menu-item-selected {\r\n  background: var(--primary-light) !important;\r\n  color: var(--primary) !important;\r\n  font-weight: 500;\r\n}\r\n\r\n.ant-menu-item-selected::after {\r\n  display: none !important;\r\n}\r\n\r\n/* Tabs */\r\n.ant-tabs {\r\n  background: var(--bg-base);\r\n}\r\n\r\n.ant-tabs-nav {\r\n  margin-bottom: 0 !important;\r\n}\r\n\r\n.ant-tabs-tab {\r\n  color: var(--text-secondary) !important;\r\n  border-radius: 6px 6px 0 0 !important;\r\n  transition: all 0.2s ease !important;\r\n}\r\n\r\n.ant-tabs-tab:hover {\r\n  color: var(--text-primary) !important;\r\n}\r\n\r\n.ant-tabs-tab-active {\r\n  color: var(--primary) !important;\r\n  background: var(--bg-base) !important;\r\n  font-weight: 500;\r\n}\r\n\r\n.ant-tabs-card > .ant-tabs-nav .ant-tabs-tab {\r\n  background: var(--bg-container) !important;\r\n  border-color: var(--border-color) !important;\r\n}\r\n\r\n.ant-tabs-card > .ant-tabs-nav .ant-tabs-tab-active {\r\n  background: var(--bg-base) !important;\r\n  border-bottom-color: var(--bg-base) !important;\r\n}\r\n\r\n.ant-tabs-content-holder {\r\n  background: var(--bg-base);\r\n}\r\n\r\n/* Button */\r\n.ant-btn {\r\n  background: var(--bg-base);\r\n  border-color: var(--border-color);\r\n  color: var(--text-primary);\r\n  border-radius: 8px;\r\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.ant-btn:hover {\r\n  background: var(--bg-elevated);\r\n  border-color: var(--primary);\r\n  color: var(--primary);\r\n}\r\n\r\n.ant-btn-primary {\r\n  background: var(--primary) !important;\r\n  border-color: var(--primary) !important;\r\n  color: white !important;\r\n  box-shadow: 0 1px 3px rgba(37, 99, 235, 0.3);\r\n}\r\n\r\n.ant-btn-primary:hover {\r\n  background: var(--primary-hover) !important;\r\n  border-color: var(--primary-hover) !important;\r\n  box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);\r\n}\r\n\r\n/* Input */\r\n.ant-input,\r\n.ant-input-affix-wrapper {\r\n  background: var(--bg-container) !important;\r\n  border-color: var(--border-color) !important;\r\n  color: var(--text-primary) !important;\r\n  border-radius: 10px !important;\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.ant-input:hover,\r\n.ant-input-affix-wrapper:hover {\r\n  border-color: var(--primary) !important;\r\n}\r\n\r\n.ant-input:focus,\r\n.ant-input-affix-wrapper:focus,\r\n.ant-input-affix-wrapper-focused {\r\n  background: var(--bg-base) !important;\r\n  border-color: var(--primary) !important;\r\n  box-shadow: 0 0 0 3px var(--primary-light) !important;\r\n}\r\n\r\n/* Select */\r\n.ant-select:not(.ant-select-customize-input) .ant-select-selector {\r\n  background: var(--bg-container) !important;\r\n  border-color: var(--border-color) !important;\r\n  color: var(--text-primary) !important;\r\n  border-radius: 8px !important;\r\n}\r\n\r\n.ant-select:not(.ant-select-customize-input) .ant-select-selector:hover {\r\n  border-color: var(--primary) !important;\r\n}\r\n\r\n.ant-select-focused .ant-select-selector {\r\n  border-color: var(--primary) !important;\r\n  box-shadow: 0 0 0 3px var(--primary-light) !important;\r\n}\r\n\r\n/* Dropdown */\r\n.ant-dropdown-menu {\r\n  background: var(--bg-base) !important;\r\n  border: 1px solid var(--border-color);\r\n  border-radius: 12px !important;\r\n  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1) !important;\r\n  padding: 8px !important;\r\n}\r\n\r\n.ant-dropdown-menu-item {\r\n  border-radius: 8px !important;\r\n  color: var(--text-primary) !important;\r\n}\r\n\r\n.ant-dropdown-menu-item:hover {\r\n  background: var(--bg-elevated) !important;\r\n}\r\n\r\n/* Card */\r\n.ant-card {\r\n  background: var(--bg-base);\r\n  border-color: var(--border-color);\r\n  border-radius: 12px;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\r\n}\r\n\r\n/* Modal */\r\n.ant-modal-content {\r\n  background: var(--bg-base) !important;\r\n  border-radius: 16px !important;\r\n  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15) !important;\r\n}\r\n\r\n.ant-modal-header {\r\n  background: var(--bg-base) !important;\r\n  border-bottom-color: var(--border-color) !important;\r\n  border-radius: 16px 16px 0 0 !important;\r\n}\r\n\r\n/* Tag */\r\n.ant-tag {\r\n  border-radius: 6px;\r\n  border: none;\r\n  padding: 4px 10px;\r\n}\r\n\r\n/* Alert */\r\n.ant-alert {\r\n  border-radius: 10px;\r\n  border: none;\r\n}\r\n\r\n.ant-alert-success {\r\n  background: var(--success-light);\r\n}\r\n\r\n.ant-alert-warning {\r\n  background: var(--warning-light);\r\n}\r\n\r\n.ant-alert-error {\r\n  background: var(--error-light);\r\n}\r\n\r\n.ant-alert-info {\r\n  background: var(--info-light);\r\n}\r\n\r\n/* Spin */\r\n.ant-spin {\r\n  color: var(--primary);\r\n}\r\n\r\n.ant-spin-dot-item {\r\n  background-color: var(--primary);\r\n}\r\n\r\n/* Empty */\r\n.ant-empty-description {\r\n  color: var(--text-secondary);\r\n}\r\n\r\n/* ==========================================\r\n   滚动条样式\r\n   ========================================== */\r\n::-webkit-scrollbar {\r\n  width: 8px;\r\n  height: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  background: var(--text-muted);\r\n  border-radius: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n  background: var(--text-tertiary);\r\n}\r\n\r\n/* ==========================================\r\n   Chat 消息样式\r\n   ========================================== */\r\n.messages-container {\r\n  overflow-y: auto;\r\n  padding: 24px;\r\n  background: var(--bg-base);\r\n  flex: 1;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 20px;\r\n}\r\n\r\n.message {\r\n  animation: fadeIn 0.3s ease-in;\r\n  max-width: 85%;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from {\r\n    opacity: 0;\r\n    transform: translateY(10px);\r\n  }\r\n  to {\r\n    opacity: 1;\r\n    transform: translateY(0);\r\n  }\r\n}\r\n\r\n.message-agent {\r\n  align-self: flex-start;\r\n}\r\n\r\n.message-user {\r\n  align-self: flex-end;\r\n}\r\n\r\n.agent-name {\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n  color: var(--text-tertiary);\r\n  margin-bottom: 6px;\r\n  margin-left: 12px;\r\n}\r\n\r\n.message-content {\r\n  background: var(--bg-container);\r\n  border-radius: 18px;\r\n  padding: 16px 20px;\r\n  color: var(--text-primary);\r\n  font-size: 15px;\r\n  line-height: 1.6;\r\n  white-space: pre-wrap;\r\n  border: 1px solid var(--border-color);\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);\r\n}\r\n\r\n.message-agent .message-content {\r\n  border-bottom-left-radius: 4px;\r\n}\r\n\r\n.message-user .message-content {\r\n  background: linear-gradient(135deg, var(--primary), #1d4ed8);\r\n  color: white;\r\n  border: none;\r\n  border-bottom-right-radius: 4px;\r\n  box-shadow: 0 4px 16px rgba(37, 99, 235, 0.3);\r\n}\r\n\r\n/* ==========================================\r\n   Markdown 内容样式\r\n   ========================================== */\r\n.markdown-content {\r\n  color: var(--text-primary);\r\n  line-height: 1.8;\r\n  padding: 24px;\r\n  background: var(--bg-container);\r\n  border-radius: 12px;\r\n  overflow-y: auto;\r\n  max-height: calc(100vh - 200px);\r\n}\r\n\r\n.markdown-content h1,\r\n.markdown-content h2,\r\n.markdown-content h3,\r\n.markdown-content h4,\r\n.markdown-content h5,\r\n.markdown-content h6 {\r\n  color: var(--text-primary);\r\n  margin-top: 32px;\r\n  margin-bottom: 16px;\r\n  font-weight: 600;\r\n  line-height: 1.3;\r\n}\r\n\r\n.markdown-content h1 {\r\n  font-size: 28px;\r\n  border-bottom: 2px solid var(--border-color);\r\n  padding-bottom: 12px;\r\n}\r\n\r\n.markdown-content h2 {\r\n  font-size: 24px;\r\n  border-bottom: 1px solid var(--border-color);\r\n  padding-bottom: 8px;\r\n}\r\n\r\n.markdown-content h3 {\r\n  font-size: 20px;\r\n}\r\n\r\n.markdown-content h4 {\r\n  font-size: 18px;\r\n}\r\n\r\n.markdown-content h5 {\r\n  font-size: 16px;\r\n}\r\n\r\n.markdown-content h6 {\r\n  font-size: 14px;\r\n  color: var(--text-secondary);\r\n}\r\n\r\n.markdown-content p {\r\n  margin-bottom: 16px;\r\n  color: var(--text-primary);\r\n}\r\n\r\n.markdown-content strong {\r\n  color: var(--text-primary);\r\n  font-weight: 600;\r\n}\r\n\r\n.markdown-content em {\r\n  color: var(--text-secondary);\r\n  font-style: italic;\r\n}\r\n\r\n.markdown-content code {\r\n  background: var(--bg-elevated);\r\n  color: var(--primary);\r\n  padding: 3px 8px;\r\n  border-radius: 6px;\r\n  font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;\r\n  font-size: 0.9em;\r\n  border: 1px solid var(--border-color);\r\n}\r\n\r\n.markdown-content pre {\r\n  background: #1e293b;\r\n  border: none;\r\n  border-radius: 12px;\r\n  padding: 20px;\r\n  margin: 20px 0;\r\n  overflow-x: auto;\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.markdown-content pre code {\r\n  background: transparent;\r\n  border: none;\r\n  padding: 0;\r\n  color: #e2e8f0;\r\n  font-size: 0.9em;\r\n}\r\n\r\n.markdown-content ul,\r\n.markdown-content ol {\r\n  margin: 16px 0;\r\n  padding-left: 28px;\r\n}\r\n\r\n.markdown-content li {\r\n  margin-bottom: 8px;\r\n  color: var(--text-primary);\r\n}\r\n\r\n.markdown-content ul li::marker {\r\n  color: var(--primary);\r\n}\r\n\r\n.markdown-content ol li::marker {\r\n  color: var(--primary);\r\n  font-weight: 600;\r\n}\r\n\r\n.markdown-content blockquote {\r\n  border-left: 4px solid var(--primary);\r\n  padding: 16px 24px;\r\n  margin: 20px 0;\r\n  background: var(--primary-lighter);\r\n  border-radius: 0 12px 12px 0;\r\n  color: var(--text-secondary);\r\n}\r\n\r\n.markdown-content blockquote p {\r\n  margin: 0;\r\n}\r\n\r\n.markdown-content a {\r\n  color: var(--primary);\r\n  text-decoration: none;\r\n  border-bottom: 1px solid transparent;\r\n  transition: all 0.2s;\r\n}\r\n\r\n.markdown-content a:hover {\r\n  color: var(--primary-hover);\r\n  border-bottom-color: var(--primary);\r\n}\r\n\r\n.markdown-content table {\r\n  width: 100%;\r\n  border-collapse: collapse;\r\n  margin: 20px 0;\r\n  background: var(--bg-base);\r\n  border-radius: 12px;\r\n  overflow: hidden;\r\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);\r\n}\r\n\r\n.markdown-content th,\r\n.markdown-content td {\r\n  padding: 14px 18px;\r\n  text-align: left;\r\n  border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.markdown-content th {\r\n  background: var(--bg-elevated);\r\n  color: var(--text-primary);\r\n  font-weight: 600;\r\n  font-size: 13px;\r\n  text-transform: uppercase;\r\n  letter-spacing: 0.5px;\r\n}\r\n\r\n.markdown-content tr:hover {\r\n  background: var(--bg-elevated-hover);\r\n}\r\n\r\n.markdown-content hr {\r\n  border: none;\r\n  border-top: 1px solid var(--border-color);\r\n  margin: 32px 0;\r\n}\r\n\r\n.markdown-content img {\r\n  max-width: 100%;\r\n  border-radius: 12px;\r\n  margin: 20px 0;\r\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n/* ==========================================\r\n   Artifacts 样式\r\n   ========================================== */\r\n.artifact-content {\r\n  padding: 24px;\r\n  background: var(--bg-container);\r\n  border-radius: 12px;\r\n  color: var(--text-primary);\r\n  height: 100%;\r\n  overflow-y: auto;\r\n}\r\n\r\n.artifact-content h3 {\r\n  color: var(--text-primary);\r\n  margin-bottom: 16px;\r\n  font-size: 18px;\r\n}\r\n\r\n.artifacts-tabs {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.artifacts-tabs .ant-tabs-content-holder {\r\n  flex: 1;\r\n  overflow: hidden;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.artifacts-tabs .ant-tabs-content {\r\n  flex: 1;\r\n  overflow: auto;\r\n}\r\n\r\n.artifacts-tabs .ant-tabs-tabpane {\r\n  height: 100%;\r\n  overflow: auto;\r\n}\r\n\r\n/* ==========================================\r\n   Code Editor Tabs 样式\r\n   ========================================== */\r\n.code-editor-tabs {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-content {\r\n  flex: 1;\r\n  overflow: hidden;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-content-holder {\r\n  flex: 1;\r\n  overflow: hidden;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-tabpane {\r\n  height: 100% !important;\r\n  overflow: hidden !important;\r\n  display: none !important;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-tabpane-active {\r\n  display: flex !important;\r\n  flex-direction: column !important;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-tabpane > div {\r\n  height: 100% !important;\r\n  display: flex !important;\r\n  flex-direction: column !important;\r\n  position: relative;\r\n}\r\n\r\n.code-editor-tabs .ant-tabs-tabpane > div > div {\r\n  flex: 1;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.code-editor-tabs .monaco-editor {\r\n  height: 100% !important;\r\n}\r\n\r\n/* ==========================================\r\n   输入区域\r\n   ========================================== */\r\n.chat-input-wrapper {\r\n  padding: 20px 24px;\r\n  background: var(--bg-base);\r\n  border-top: 1px solid var(--border-color);\r\n}\r\n\r\n.chat-input-wrapper input[type=\"text\"] {\r\n  flex: 1;\r\n  padding: 14px 20px;\r\n  background: var(--bg-container);\r\n  border: 1px solid var(--border-color);\r\n  border-radius: 12px;\r\n  color: var(--text-primary);\r\n  font-size: 15px;\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n.chat-input-wrapper input[type=\"text\"]:focus {\r\n  outline: none;\r\n  border-color: var(--primary);\r\n  background: var(--bg-base);\r\n  box-shadow: 0 0 0 4px var(--primary-light);\r\n}\r\n\r\n.chat-input-wrapper input[type=\"text\"]:hover {\r\n  border-color: var(--text-tertiary);\r\n}\r\n\r\n/* ==========================================\r\n   会话列表\r\n   ========================================== */\r\n.session-item {\r\n  padding: 12px 16px;\r\n  margin-bottom: 6px;\r\n  border-radius: 10px;\r\n  cursor: pointer;\r\n  transition: all 0.2s ease;\r\n  border: 1px solid transparent;\r\n}\r\n\r\n.session-item:hover {\r\n  background: var(--bg-elevated);\r\n  border-color: var(--border-color);\r\n}\r\n\r\n.session-item.active {\r\n  background: var(--primary-light);\r\n  border-color: var(--primary);\r\n}\r\n\r\n.session-item-title {\r\n  color: var(--text-primary);\r\n  font-size: 14px;\r\n  font-weight: 500;\r\n}\r\n\r\n.session-item-time {\r\n  color: var(--text-tertiary);\r\n  font-size: 12px;\r\n  margin-top: 4px;\r\n}\r\n\r\n/* ==========================================\r\n   欢迎界面\r\n   ========================================== */\r\n.welcome-screen {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  height: 100%;\r\n  color: var(--text-secondary);\r\n  text-align: center;\r\n  padding: 40px;\r\n}\r\n\r\n.welcome-screen h2 {\r\n  color: var(--text-primary);\r\n  font-size: 32px;\r\n  margin-bottom: 16px;\r\n  font-weight: 600;\r\n}\r\n\r\n.welcome-screen p {\r\n  font-size: 16px;\r\n  line-height: 1.6;\r\n  max-width: 500px;\r\n  margin: 0 auto;\r\n}\r\n\r\n/* ==========================================\r\n   Agent Loading Indicator\r\n   ========================================== */\r\n@keyframes pulse {\r\n  0%, 100% {\r\n    opacity: 0.3;\r\n    transform: scale(0.8);\r\n  }\r\n  50% {\r\n    opacity: 1;\r\n    transform: scale(1);\r\n  }\r\n}\r\n\r\n.agent-loading-indicator {\r\n  margin-left: 4px;\r\n}\r\n\r\n/* ==========================================\r\n   代码高亮\r\n   ========================================== */\r\n.hljs {\r\n  background: #1e293b !important;\r\n  color: #e2e8f0 !important;\r\n  border-radius: 12px;\r\n  padding: 20px !important;\r\n}\r\n\r\n/* ==========================================\r\n   JSON View\r\n   ========================================== */\r\n.react-json-view {\r\n  background: var(--bg-container) !important;\r\n  padding: 20px;\r\n  border-radius: 12px;\r\n  border: 1px solid var(--border-color);\r\n  font-size: 14px;\r\n  line-height: 1.8;\r\n}\r\n\r\n.react-json-view .string-key {\r\n  color: var(--primary) !important;\r\n  font-weight: 600;\r\n}\r\n\r\n.react-json-view .object-key {\r\n  color: var(--primary) !important;\r\n  font-weight: 600;\r\n}\r\n\r\n.react-json-view .string-value {\r\n  color: #059669 !important;\r\n}\r\n\r\n.react-json-view .variable-value {\r\n  color: #059669 !important;\r\n}\r\n\r\n.react-json-view .number-value {\r\n  color: #2563eb !important;\r\n}\r\n\r\n.react-json-view .boolean-value {\r\n  color: #d97706 !important;\r\n  font-weight: 500;\r\n}\r\n\r\n.react-json-view .null-value {\r\n  color: #dc2626 !important;\r\n  font-weight: 500;\r\n}\r\n\r\n.react-json-view .array-key {\r\n  color: var(--primary) !important;\r\n  font-weight: 600;\r\n}\r\n\r\n.react-json-view .string-literal {\r\n  color: #059669 !important;\r\n}\r\n\r\n.react-json-view .object-name {\r\n  color: var(--primary) !important;\r\n  font-weight: 600;\r\n}\r\n\r\n.react-json-view .array-name {\r\n  color: var(--primary) !important;\r\n  font-weight: 600;\r\n}\r\n\r\n.react-json-view .br-row,\r\n.react-json-view .bracket {\r\n  color: var(--text-tertiary) !important;\r\n}\r\n\r\n.react-json-view .colon {\r\n  color: var(--text-tertiary) !important;\r\n}\r\n\r\n.react-json-view .arrow-icon,\r\n.react-json-view .expanded-icon,\r\n.react-json-view .collapsed-icon {\r\n  fill: var(--primary) !important;\r\n}\r\n\r\n/* ==========================================\r\n   面板和布局\r\n   ========================================== */\r\n.runner-panel,\r\n.preview-panel,\r\n.code-editor-container {\r\n  background: var(--bg-base);\r\n}\r\n\r\n/* 侧边栏图标 */\r\n.ant-menu-item .anticon {\r\n  font-size: 18px;\r\n  margin-right: 12px;\r\n}\r\n\r\n/* 头部样式 */\r\n.app-header {\r\n  background: var(--bg-base);\r\n  border-bottom: 1px solid var(--border-color);\r\n  padding: 0 24px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n}\r\n\r\n.app-title {\r\n  font-size: 18px;\r\n  font-weight: 600;\r\n  color: var(--text-primary);\r\n}\r\n\r\n/* 迭代面板 */\r\n.iterations-panel {\r\n  background: var(--bg-sidebar);\r\n}\r\n\r\n/* 状态指示器 */\r\n.status-indicator {\r\n  width: 8px;\r\n  height: 8px;\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n}\r\n\r\n.status-indicator.success {\r\n  background: var(--success);\r\n  box-shadow: 0 0 0 3px var(--success-light);\r\n}\r\n\r\n.status-indicator.processing {\r\n  background: var(--primary);\r\n  box-shadow: 0 0 0 3px var(--primary-light);\r\n  animation: pulse 2s infinite;\r\n}\r\n\r\n.status-indicator.error {\r\n  background: var(--error);\r\n  box-shadow: 0 0 0 3px var(--error-light);\r\n}\r\n\r\n/* 分割线 */\r\n.divider {\r\n  height: 1px;\r\n  background: var(--border-color);\r\n  margin: 16px 0;\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 926,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "styles.css is a comprehensive global stylesheet that serves as the central styling authority for the cowork-gui frontend application. The file establishes a complete design system including:\n\n1. **Theme Definition**: Defines a \"Fresh Light Theme\" using CSS custom properties (variables) for a consistent color palette including primary colors (#2563eb blue), background colors, text colors with clear hierarchy, and semantic state colors (success, warning, error, info).\n\n2. **Third-Party Integration**: Extensively customizes Ant Design components to match the application's design language, covering layout (header, sidebar), navigation (menu, tabs), form controls (buttons, inputs, selects), modals, cards, alerts, and other UI elements.\n\n3. **Custom UI Components**: Implements bespoke styling for chat interface (message bubbles, animations, agent/user differentiation), markdown content rendering (typography, code blocks, tables, blockquotes), artifacts display panels, code editor tabs, input areas, session lists, and welcome screens.\n\n4. **Utility Patterns**: Provides styling for cross-cutting concerns including custom scrollbars, loading indicators with animations, syntax highlighting (hljs), JSON viewer (react-json-view), status indicators, and layout dividers.\n\n5. **Visual Polish**: Incorporates modern CSS features including gradients, box shadows, transitions (0.2s ease), animations (fadeIn, pulse), and responsive layout techniques using flexbox to create a polished, professional user experience.",
    "interfaces": [],
    "responsibilities": [
      "Define and maintain the application's visual design system through CSS custom properties (color palette, typography, spacing, shadows)",
      "Customize and override Ant Design component library styles to align with the application's design language",
      "Implement styling for custom UI components including chat interface, markdown viewer, artifacts panel, and code editor",
      "Provide utility styles for common UI patterns (scrollbars, status indicators, loading states, dividers)",
      "Ensure consistent visual presentation and user experience across all application screens"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "Tauri build configuration script for the cowork-gui application",
      "file_path": "crates\\cowork-gui\\src-tauri\\build.rs",
      "functions": [
        "main"
      ],
      "importance_score": 0.6,
      "interfaces": [],
      "name": "build.rs",
      "source_summary": "fn main() {\r\n    tauri_build::build()\r\n}\r\n"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 1.0,
      "lines_of_code": 3,
      "number_of_classes": 0,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": 2,
        "name": "tauri_build",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "This is a standard Rust build script (build.rs) for a Tauri-based GUI application. The component serves as the entry point for the custom build process of the Tauri application, invoking the Tauri build system's build() function. The script is extremely minimal, consisting of only a main() function that delegates to tauri_build::build(). The tauri_build crate's build() function is responsible for configuring the compilation environment for Tauri applications, handling tasks such as setting up build flags, managing asset embedding, and applying platform-specific build configurations. This is a standard boilerplate build script that follows Tauri's recommended best practices for setting up the build infrastructure for cross-platform desktop applications using web technologies.",
    "interfaces": [
      {
        "description": "Entry point for the Rust build script, invokes tauri_build::build() to configure the Tauri application build process",
        "interface_type": "function",
        "name": "main",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "Initialize and configure Tauri application build process",
      "Delegate build configuration to tauri_build crate for standard Tauri setup",
      "Ensure proper compilation flags and environment variables are set for the Tauri GUI application",
      "Handle platform-specific build requirements automatically through tauri_build",
      "Facilitate the integration of web frontend with Rust backend through proper build configuration"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": "A Tauri capability configuration file that defines security permissions and access controls for the application's main window.",
      "file_path": "crates\\cowork-gui\\src-tauri\\gen\\schemas\\capabilities.json",
      "functions": [],
      "importance_score": 0.55,
      "interfaces": [],
      "name": "capabilities.json",
      "source_summary": "{\"default\":{\"identifier\":\"default\",\"description\":\"Capability for the main window\",\"local\":true,\"windows\":[\"main\"],\"permissions\":[\"core:default\",\"opener:default\",\"dialog:allow-open\"]}}"
    },
    "complexity_metrics": {
      "cyclomatic_complexity": 2.0,
      "lines_of_code": 1,
      "number_of_classes": 0,
      "number_of_functions": 0
    },
    "dependencies": [],
    "detailed_description": "This component is a Tauri capability configuration file that serves as a critical security boundary between the frontend JavaScript code and backend system-level operations. The configuration defines a single capability named 'default' that applies to the application's main window. It specifies three key permissions: 'core:default' (providing fundamental Tauri core functionality), 'opener:default' (enabling URI/external content opening capabilities), and 'dialog:allow-open' (granting permission to display dialog windows). The capability is marked as local, indicating it's defined within the application rather than being an external capability. This configuration follows Tauri's capability-based security model, which implements the principle of least privilege by explicitly declaring which windows have access to which backend APIs. The file is auto-generated during the Tauri build process as indicated by its location in the 'gen/schemas' directory.",
    "interfaces": [],
    "responsibilities": [
      "Security access control and permission definition for the Tauri application",
      "Window-specific capability mapping - associating permissions with the 'main' window",
      "API authorization management - controlling which Tauri backend APIs can be invoked by frontend code",
      "Application security boundary enforcement - implementing least privilege principle for system-level operations",
      "Build-time configuration generation support - serving as auto-generated schema for Tauri's capability system"
    ]
  }
]
```

## Memory Storage Statistics

**Total Storage Size**: 1678268 bytes

- **preprocess**: 1323457 bytes (78.9%)
- **studies_research**: 121612 bytes (7.2%)
- **timing**: 33 bytes (0.0%)
- **documentation**: 233166 bytes (13.9%)

## Generated Documents Statistics

Number of Generated Documents: 12

- Key Modules and Components Research Report_Interaction Domain
- Boundary Interfaces
- Key Modules and Components Research Report_Pipeline Domain
- Key Modules and Components Research Report_Project Management Domain
- Key Modules and Components Research Report_Storage Domain
- Key Modules and Components Research Report_Memory Domain
- Architecture Description
- Project Overview
- Core Workflows
- Key Modules and Components Research Report_Iteration Management Domain
- Key Modules and Components Research Report_Tool Support Domain
- Key Modules and Components Research Report_LLM Infrastructure Domain
