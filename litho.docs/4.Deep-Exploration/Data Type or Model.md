# Data Type and Model Documentation

## Overview

The **Data Type or Model** domain defines the structured data contracts that form the backbone of Cowork Forge's artifact management system. This domain provides a comprehensive set of Rust data structures that represent artifacts across the entire software development lifecycle, from initial ideation to final delivery. These models ensure consistent data representation, serialization/deserialization capabilities, and maintain strong type safety throughout the system.

## Core Architecture

### Artifact Envelope Pattern

The foundation of the data modeling system is the `ArtifactEnvelope<T>` pattern, which provides a consistent wrapper for all artifacts:

```rust
pub struct ArtifactEnvelope<T> {
    pub meta: ArtifactMeta,
    pub summary: Vec<String>,
    pub links: ArtifactLinks,
    pub data: T,
}
```

This generic wrapper encapsulates:
- **Metadata**: Session context, timestamps, and versioning
- **Summary**: Human-readable context information
- **Links**: Lineage tracking through previous artifact references
- **Data**: Domain-specific artifact content

### Development Lifecycle Stages

The system models eight distinct stages of the software development lifecycle:

```rust
pub enum Stage {
    IdeaIntake,
    Requirements,
    Design,
    Plan,
    Coding,
    Check,
    Feedback,
    Delivery,
}
```

Each stage corresponds to specific artifact types and has well-defined transitions and dependencies.

## Domain Models

### Idea Specification (`IdeaSpec`)

**Purpose**: Captures the initial user input and project vision.

**Structure**:
```rust
pub struct IdeaSpec {
    pub bg: String,      // Background/context
    pub g: Vec<String>,  // Goals
    pub ng: Vec<String>, // Non-goals
    pub c: Vec<String>,  // Constraints
    pub sc: Vec<String>, // Success criteria
    pub r: Vec<String>,  // Risks
    pub q: Vec<String>,  // Questions
}
```

**Usage**: Generated by the IdeaIntake agent and serves as the foundation for subsequent stages.

### Product Requirements Document (`PRD`)

**Purpose**: Formalizes requirements with structured prioritization and acceptance criteria.

**Key Components**:
- **Scope**: Defines project boundaries (goals vs. non-goals)
- **Requirements**: Detailed functional and non-functional requirements
- **Constraints**: Technical and business limitations
- **HITL Questions**: Points requiring human review

```rust
pub struct Requirement {
    pub id: String,
    pub pri: Priority,           // P0, P1, P2
    pub req_type: RequirementType, // Func, Nfr, Constraint
    pub desc: String,
    pub deps: Vec<String>,       // Dependency requirements
    pub ac: Vec<String>,         // Acceptance criteria
}
```

### Design Documentation (`DesignDoc`)

**Purpose**: Specifies the architectural approach and system design.

**Structure**:
```rust
pub struct DesignDoc {
    pub cli: CliDesign,      // CLI interface design
    pub wf: Workflow,        // Development workflow
    pub arch: Architecture,  // System architecture
    pub io: IoConfig,        // Input/output configuration
}
```

**Architecture Details**:
- **Layers**: Architectural layers (presentation, business logic, data)
- **Components**: Key system components and their responsibilities
- **Technology Stack**: Programming languages, frameworks, and tools

### Implementation Plan (`Plan`)

**Purpose**: Breaks down development work into executable tasks.

**Key Features**:
- **C4 Design**: Context, containers, components, and code-level design
- **Tasks**: Development activities with dependencies and outputs
- **Milestones**: Major project checkpoints
- **TodoList**: Detailed task breakdown with status tracking

```rust
pub struct TodoItem {
    pub id: String,
    pub description: String,
    pub status: TodoStatus,
    pub related_requirements: Vec<String>,
    pub related_files: Vec<String>,
    pub verification_method: String,
}
```

### Code Change Specification (`CodeChange`)

**Purpose**: Defines code modifications and project structure changes.

**Components**:
```rust
pub struct CodeChange {
    pub target: TargetProject,      // Project characteristics
    pub project: ProjectStructure,  // File organization
    pub changes: Vec<Change>,       // Specific modifications
    pub cmds: Vec<Command>,         // Build/test commands
    pub requirement_mapping: Vec<RequirementMapping>,
}
```

**Innovation**: The `RequirementMapping` establishes traceability between requirements and implementation files.

### Quality Assurance (`CheckReport`)

**Purpose**: Comprehensive validation report covering code quality and requirement coverage.

**Validation Areas**:
- **Automated Checks**: Build, test, and lint results
- **Acceptance Criteria**: Requirement validation status
- **Todo Completion**: Task progress tracking
- **Requirement Coverage**: Implementation completeness metrics

```rust
pub struct RequirementCoverage {
    pub total_requirements: usize,
    pub verified: usize,
    pub partially_verified: usize,
    pub not_verified: usize,
    pub coverage_percentage: f64,
}
```

### V2 Architecture Enhancements

The Cowork Core V2 introduces refined data models with improved structure and validation:

#### Enhanced Requirements Model
```rust
pub struct Requirements {
    pub schema_version: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub requirements: Vec<Requirement>,
}
```

#### Feature-Based Development
```rust
pub struct Feature {
    pub id: String,
    pub name: String,
    pub description: String,
    pub requirement_ids: Vec<String>,
    pub status: FeatureStatus,
    pub assigned_to_tasks: Vec<String>,
    pub completion_criteria: Vec<String>,
}
```

#### Comprehensive Code Metadata
```rust
pub struct CodeMetadata {
    pub files: Vec<FileMetadata>,
    pub build_status: BuildStatus,
    pub test_status: TestStatus,
}
```

## Serialization and Storage

### JSON-Based Persistence

All models implement `Serialize` and `Deserialize` traits using Serde, enabling seamless JSON serialization:

```rust[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArtifactMeta {
    pub session_id: String,
    pub artifact_id: String,
    pub stage: Stage,
    pub v: u32,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub ts: DateTime<Utc>,
}
```

### File Organization

Artifacts are stored in a structured directory hierarchy:
```
.cowork/
├── artifacts/
│   ├── idea_intake.json
│   ├── requirements.json
│   ├── design.json
│   └── ...
└── session/
    └── meta.json
```

## Type Safety and Validation

### Enum-Based Constraints

The system uses Rust enums extensively to enforce valid states:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Priority {
    P0, P1, P2
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum TaskStatus {
    Pending, InProgress, Completed, Blocked
}
```

### Builder Pattern Implementation

The `ArtifactEnvelope` provides a fluent interface for construction:

```rust
impl<T> ArtifactEnvelope<T> {
    pub fn new(session_id: String, stage: Stage, data: T) -> Self {
        // Implementation
    }

    pub fn with_summary(mut self, summary: Vec<String>) -> Self {
        self.summary = summary;
        self
    }

    pub fn with_prev(mut self, prev: Vec<String>) -> Self {
        self.links.prev = prev;
        self
    }
}
```

## Integration with System Components

### Agent Integration

All AI agents operate on these data models:
- **Input**: Receive previous stage artifacts as typed data structures
- **Output**: Generate new artifacts wrapped in `ArtifactEnvelope`
- **Validation**: Use model constraints to ensure data integrity

### Storage Layer Integration

The `ArtifactStore` uses these models for:
- **Serialization**: Convert models to JSON for file storage
- **Deserialization**: Load artifacts back into typed structures
- **Querying**: Filter and retrieve artifacts by stage and metadata

### Tool Integration

Functional tools leverage model information for:
- **File Operations**: Understand project structure from `CodeChange`
- **Validation**: Check data formats against model schemas
- **HITL Interactions**: Present structured data for human review

## Data Flow and Lineage

### Artifact Lineage Tracking

The system maintains traceability through the `ArtifactLinks` structure:

```rust
pub struct ArtifactLinks {
    pub prev: Vec<String>,  // Previous artifact IDs
}
```

This enables:
- **Audit Trails**: Track how artifacts evolve through stages
- **Impact Analysis**: Understand dependencies between changes
- **Resumption**: Restart workflows from any completed stage

### Cross-Stage Data Consistency

Models are designed to maintain consistency across stages:
- **Requirement IDs**: Consistent identification throughout lifecycle
- **Feature Mapping**: Trace features from requirements to implementation
- **File References**: Maintain consistent paths across code changes

## Evolution and Versioning

### Schema Evolution

The V2 architecture introduces schema versioning:

```rust
pub struct Requirements {
    pub schema_version: String,  // "1.0", "1.1", etc.
    // ... other fields
}
```

### Backward Compatibility

Models are designed with backward compatibility:
- Optional fields using `Option<T>`
- Default values for new fields
- Careful use of `skip_serializing_if` for optional data

## Best Practices and Conventions

### Naming Conventions

- **Field Names**: Use descriptive, full words (not abbreviations)
- **Enum Variants**: Follow Rust conventions with PascalCase
- **JSON Serialization**: Use snake_case for field names

### Documentation Standards

All public types include:
- Comprehensive doc comments
- Usage examples where applicable
- Clear descriptions of field purposes

### Error Handling

Models are designed to be resilient:
- Optional fields for incomplete data
- Default implementations for empty states
- Validation methods for data integrity checks

The Data Type and Model domain provides a robust foundation for Cowork Forge's AI-driven development workflow, ensuring type safety, data consistency, and seamless integration across all system components.