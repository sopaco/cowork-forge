# 智能体指令域技术文档

## 概述

智能体指令域是Cowork Forge系统的核心业务模块，负责定义和执行AI智能体的行为逻辑，实现从需求捕获到代码交付的完整软件开发生命周期管理。该域采用Actor-Critic双智能体交互模式，通过人工介入循环(HITL)机制确保质量控制。

## 架构设计

### 模块结构

智能体指令域包含12个核心子模块，每个模块对应软件开发流程中的一个特定阶段：

```
智能体指令域
├── 需求捕获模块 (idea.rs)
├── 需求分析模块 (prd.rs) 
├── 架构设计模块 (design.rs)
├── 任务规划模块 (plan.rs)
├── 代码实现模块 (coding.rs, code_patch.rs)
├── 质量检查模块 (check.rs)
├── 项目交付模块 (delivery.rs)
├── 变更分析模块 (modify.rs)
└── 变更交付模块 (modify_delivery.rs)
```

### 核心设计模式

#### 1. Actor-Critic循环模式
每个主要阶段采用Actor-Critic双智能体协作：
- **Actor智能体**：负责生成内容（需求、设计、代码等）
- **Critic智能体**：负责质量验证和反馈
- **循环机制**：通过LoopAgent实现最多3-5次的迭代优化

#### 2. 人工介入循环(HITL)
在关键决策点引入用户反馈：
- 需求分析阶段：用户审核PRD草案
- 架构设计阶段：用户评审架构方案  
- 任务规划阶段：用户确认实施计划

#### 3. 增量修改流程
支持对现有项目的局部修改：
- 变更分析 → 代码修补 → 变更交付
- 分离的修改指令集，避免影响主流程

## 核心模块详解

### 1. 需求捕获模块 (idea.rs)

**功能职责**：
- 理解用户的初始项目想法
- 结构化保存为idea.md文档
- 提供用户审核和编辑界面

**技术实现**：
```rust
pub const IDEA_AGENT_INSTRUCTION: &str = r#"
You are the Idea Agent, the first step in the Cowork Forge system.
Your job is to understand the user's initial idea, save it to `idea.md`, and let the user review/refine it.
"#;
```

**工作流程**：
1. 解析用户输入的项目想法
2. 生成结构化idea.md文档
3. 调用review_and_edit_content让用户审核
4. 确认后传递给PRD阶段

### 2. 需求分析模块 (prd.rs)

**核心原则**：简单性和核心功能聚焦
- 仅关注核心业务需求，排除性能优化、测试基础设施等非核心需求
- 需求数量控制在3-6个，功能数量控制在2-4个

**Actor-Critic交互**：
```rust
pub fn create_prd_loop(model: Arc<dyn Llm>, session_id: &str) -> Result<Arc<dyn adk_core::Agent>> {
    let prd_actor = LlmAgentBuilder::new("prd_actor")...;
    let prd_critic = LlmAgentBuilder::new("prd_critic")...;
    let mut loop_agent = LoopAgent::new("prd_loop",[Arc::new(prd_actor), Arc::new(prd_critic)]);
    loop_agent = loop_agent.with_max_iterations(3);
}
```

**关键约束**：
- 禁止包含性能优化需求
- 禁止包含测试/CI/CD基础设施需求  
- 禁止包含部署/运维需求（除非明确要求）

### 3. 架构设计模块 (design.rs)

**设计哲学**：最小化架构复杂度
- 组件数量：2-4个最优，最多6个
- 技术栈：选择最简单的可行方案
- 架构风格：优先单体架构，避免微服务过度拆分

**技术栈选择原则**：
```rust
// GOOD: "Node.js + Express + SQLite" 
// BAD: "Node.js + Express + Redis + RabbitMQ + Elasticsearch + Prometheus"
```

**验证机制**：
- 组件覆盖率检查：确保所有功能都有对应的实现组件
- 技术栈合理性验证：避免过度工程化

### 4. 任务规划模块 (plan.rs)

**任务筛选原则**：
- 仅包含核心功能实现任务
- 排除单元测试、集成测试任务（除非明确要求）
- 排除性能优化任务
- 排除部署/运维任务

**动态任务管理**：
```rust
// Actor具备任务创建、更新、删除能力
.tool(Arc::new(CreateTaskTool::new(session.clone())))
.tool(Arc::new(UpdateTaskTool::new(session.clone())))
.tool(Arc::new(DeleteTaskTool::new(session.clone())))
```

**Critic审核重点**：
- 任务是否聚焦核心功能
- 是否存在非必要的测试/优化任务
- 依赖关系是否合理

### 5. 代码实现模块 (coding.rs)

**编码原则**：简单清晰的实现
- 避免复杂的设计模式和抽象
- 使用内置功能，最小化依赖
- 不编写测试文件（除非任务明确要求）

**自适应任务管理**：
```rust
// 支持在实现过程中动态调整任务计划
pub const CODING_ACTOR_INSTRUCTION: &str = r#"
During implementation, you may discover that the plan needs adjustments.
You now have tools to handle this:
- create_task: 发现缺失的依赖或先决条件时
- update_task: 任务依赖关系发生变化时  
- delete_task: 任务不再需要或无法实现时
"#;
```

**Critic质量检查**：
- 代码复杂度评估：检测过度工程化
- 文件存在性验证：确保任务实际完成
- 重大问题识别：触发重新规划机制

### 6. 质量检查模块 (check.rs)

**最小化验证策略**：
```rust
pub const CHECK_AGENT_INSTRUCTION: &str = r#"
# Core Principle: MINIMAL VALIDATION
- Don't over-test: No need for 100% coverage
- Skip test checks: Unless project explicitly has tests
- Basic validation only: Files exist, data format valid
- Be lenient: If it works, approve it
"#;
```

**检查项目**：
- 功能覆盖率检查：`check_feature_coverage()`
- 任务依赖关系检查：`check_task_dependencies()`
- 文件存在性验证：`list_files(path)`

### 7. 项目交付模块 (delivery.rs)

**交付前提验证**：
```rust
// 关键预检查：确保代码文件实际存在
pub const DELIVERY_AGENT_INSTRUCTION: &str = r#"
# CRITICAL Pre-Check (DO THIS FIRST!)
Before generating the report, you MUST verify the project is complete:
1. Call get_plan() to check task status  
2. Use list_files(".") to verify actual code files exist
3. If NO code files exist: DO NOT generate delivery report
"#;
```

**报告内容**：
- 项目总结和需求/功能完成状态
- 架构组件和技术栈说明
- 任务完成情况和生成文件列表
- 质量检查结果和启动指南

## 增量修改流程

### 8. 变更分析模块 (modify.rs)

**变更范围分析**：
```rust
pub const CHANGE_TRIAGE_INSTRUCTION: &str = r#"
# Role: Change Triage Agent
Analyze user's change requests and determine the scope of modifications needed.
"#;
```

**影响评估维度**：
- PRD更新需求：是否需要新增/修改需求
- 设计更新需求：是否需要调整架构
- 计划更新需求：是否需要新增任务
- 代码变更范围：受影响的文件和组件

### 9. 代码修补模块 (code_patch.rs)

**增量修改策略**：
```rust
pub const CODE_PATCH_INSTRUCTION: &str = r#"
# Implementation Strategy
- Prefer modifying existing files over creating new ones
- Keep changes minimal and focused  
- Follow existing code style and patterns
"#;
```

**修改原则**：
- 优先修改现有文件，避免大量重写
- 遵循现有代码风格和架构模式
- 最小化变更范围，专注需求实现

### 10. 变更交付模块 (modify_delivery.rs)

**变更报告格式**：
- 类似Pull Request描述的结构化报告
- 详细记录新增/修改/删除的文件
- 变更影响分析和测试结果

## 技术实现细节

### 智能体构建模式

每个智能体采用统一的构建模式：
```rust
pub fn create_xxx_agent(model: Arc<dyn Llm>, session_id: &str) -> Result<Arc<dyn adk_core::Agent>> {
    LlmAgentBuilder::new("agent_name")
        .instruction(XXX_AGENT_INSTRUCTION)
        .model(model)
        .tool(Arc::new(RelevantTool::new(session_id.to_string())))
        .include_contents(IncludeContents::None)
        .build()
}
```

### 循环智能体配置

Actor-Critic循环采用ResilientAgent包装：
```rust
let mut loop_agent = LoopAgent::new("loop_name", vec![actor, critic]);
loop_agent = loop_agent.with_max_iterations(3); // 最多3次迭代
Ok(Arc::new(ResilientAgent::new(Arc::new(loop_agent))))
```

### 错误恢复机制

通过HITL模块实现智能体错误恢复：
```rust
pub struct ResilientAgent {
    inner: Arc<dyn Agent>,
    subs: Vec<Arc<dyn Agent>>,
}
```

提供三种恢复选项：
- 重试（重置计数器）
- 提供指导后重试
- 中止流程

## 质量保证机制

### 1. 阶段性验证
每个阶段都有明确的完成标准：
- 需求阶段：需求文档保存验证
- 设计阶段：组件创建验证  
- 计划阶段：任务创建验证
- 实现阶段：文件存在性验证

### 2. 人工介入点
关键决策点强制用户审核：
- PRD草案审查
- 架构设计评审
- 任务计划确认

### 3. 重新规划机制
当实现发现根本性问题时：
```rust
// Coding Critic可以请求重新规划
.tool(Arc::new(RequestReplanningTool::new(session.clone())))
```

## 总结

智能体指令域通过模块化的指令集和严格的流程控制，实现了AI驱动的自动化软件开发。其核心价值在于：

1. **标准化流程**：将软件开发过程分解为可管理的阶段
2. **质量可控**：通过Actor-Critic循环和HITL机制确保输出质量
3. **灵活性**：支持完整项目和增量修改两种工作流
4. **可扩展性**：模块化设计便于新增智能体指令

该域的成功实施为Cowork Forge系统提供了可靠的核心业务逻辑支撑，是实现AI辅助软件开发的关键技术基础。