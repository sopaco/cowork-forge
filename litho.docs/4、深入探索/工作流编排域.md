# Cowork AI 工作流编排域技术文档

## 1. 概述

工作流编排域是 Cowork AI 多智能体软件开发系统的核心业务组件，负责协调和管理完整的 AI 驱动软件开发流程。该域实现了从创意输入到最终交付的 8 阶段工作流，通过智能化的状态管理和错误恢复机制，确保开发过程的可靠性和可恢复性。

## 2. 架构设计

### 2.1 核心组件结构

工作流编排域采用模块化设计，主要包含以下核心组件：

```rust
// 主要数据结构定义
pub enum StageStatus {
    NotStarted,
    InProgress { started_at: chrono::DateTime<chrono::Utc> },
    Completed { artifact_id: String, completed_at: chrono::DateTime<chrono::Utc>, verified: bool },
    Failed { error: String, failed_at: chrono::DateTime<chrono::Utc>, can_retry: bool }
}

pub struct SessionMeta {
    pub session_id: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub current_stage: Option<Stage>,
    pub stage_status: HashMap<Stage, StageStatus>,
    pub completed_stages: Vec<Stage>
}

pub struct Orchestrator {
    store: Arc<ArtifactStore>
}
```

### 2.2 工作流阶段定义

系统实现了标准化的 8 阶段软件开发流程：

1. **IdeaIntake** - 创意输入阶段
2. **Requirements** - 需求文档生成阶段  
3. **Design** - 技术设计阶段
4. **Plan** - 实施计划阶段
5. **Coding** - 代码生成阶段
6. **Check** - 质量检查阶段
7. **Feedback** - 反馈处理阶段
8. **Delivery** - 交付报告阶段

## 3. 核心功能实现

### 3.1 会话管理机制

```rust
impl Orchestrator {
    /// 创建新会话
    pub fn create_session(&self) -> Result<String> {
        let session_id = uuid::Uuid::new_v4().to_string();
        let meta = SessionMeta {
            session_id: session_id.clone(),
            created_at: chrono::Utc::now(),
            current_stage: None,
            stage_status: HashMap::new(),
            completed_stages: Vec::new(),
        };
        self.save_session_meta(&meta)?;
        Ok(session_id)
    }
    
    /// 恢复会话从中断点继续
    pub async fn resume_session(&self, session_id: &str, model_config: &ModelConfig) -> Result<()> {
        let meta = self.load_session_meta(session_id)?;
        let next_stage = Stage::all()
            .iter()
            .find(|s| !meta.completed_stages.contains(s))
            .cloned();
        self.run_workflow_from_stage(session_id, model_config, next_stage).await
    }
}
```

### 3.2 阶段状态管理

编排器实现了精细化的阶段状态管理：

```rust
/// 标记阶段为进行中
fn mark_stage_in_progress(&self, meta: &mut SessionMeta, stage: Stage) -> Result<()> {
    meta.stage_status.insert(
        stage,
        StageStatus::InProgress { started_at: chrono::Utc::now() }
    );
    meta.current_stage = Some(stage);
    self.save_session_meta(meta)
}

/// 标记阶段为完成（支持验证状态）
fn mark_stage_completed(&self, meta: &mut SessionMeta, stage: Stage, 
                       artifact_id: String, verified: bool) -> Result<()> {
    meta.stage_status.insert(
        stage,
        StageStatus::Completed {
            artifact_id,
            completed_at: chrono::Utc::now(),
            verified,
        }
    );
    if !meta.completed_stages.contains(&stage) {
        meta.completed_stages.push(stage);
    }
    self.save_session_meta(meta)
}
```

### 3.3 智能重试机制

系统实现了智能化的错误恢复机制，特别是在代码检查阶段：

```rust
// Stage 6: Check（支持智能重试）
const MAX_RETRY: usize = 3;
let mut retry_count = 0;
let check_artifact = loop {
    // 错误分析和针对性修复
    let error_analysis = crate::agents::ErrorAnalyzer::analyze(&check_artifact.data);
    
    if error_analysis.has_critical_errors && retry_count < MAX_RETRY {
        // 创建只包含受影响文件的修复计划
        let fix_changes: Vec<crate::artifacts::Change> = code_artifact.data.changes.iter()
            .filter(|c| error_analysis.affected_files.contains(&c.path))
            .cloned()
            .collect();
            
        // 执行针对性修复
        let executor = crate::agents::CodeExecutor::new(&model_config.llm)?;
        match executor.execute_with_todo(&fix_artifact, &hitl, Some(&prd_summary), todo_list.as_mut()).await {
            Ok(report) => {
                if report.failed == 0 && report.successful > 0 {
                    retry_count += 1;
                    continue;  // 重新运行 Check
                }
            }
            Err(e) => { /* 错误处理 */ }
        }
    }
    break check_artifact;
};
```

## 4. 交互模式

### 4.1 与智能体执行域的协作

编排器通过标准接口调用各阶段智能体：

```rust
// 调用 PRD 生成智能体
let prd_agent = PrdAgent::new(&model_config.llm, self.store.clone())?;
let mut prd_artifact = prd_agent.execute(session_id, &idea_artifact).await?;

// 调用设计智能体  
let design_agent = DesignAgent::new(&model_config.llm, self.store.clone())?;
let design_artifact = design_agent.execute(session_id, &prd_artifact).await?;
```

### 4.2 人工介入控制

在关键决策点通过 HITL 控制器获取用户确认：

```rust
// HITL 审查和修改
if let Some(modified_json) = hitl.review_and_edit_json("PRD", &prd_artifact.data)? {
    let modified_data: crate::artifacts::PRD = serde_json::from_str(&modified_json)?;
    prd_artifact.data = modified_data;
    self.store.put(session_id, Stage::Requirements, &prd_artifact)?;
    println!("✅ PRD 已更新");
}
```

### 4.3 工件数据管理

与数据模型域紧密集成，实现工件数据的持久化管理：

```rust
/// 从文件系统加载指定阶段的 artifact
fn load_artifact<T>(&self, session_id: &str, stage: Stage) -> Result<T>
where
    T: serde::de::DeserializeOwned,
{
    let artifacts = self.store.list(session_id)?;
    let artifact_meta = artifacts
        .iter()
        .filter(|a| a.stage == stage)
        .max_by_key(|a| &a.path_json)
        .ok_or_else(|| anyhow::anyhow!("No artifact found for stage {:?}", stage))?;
    
    let content = fs::read_to_string(&artifact_meta.path_json)?;
    serde_json::from_str(&content)
}
```

## 5. 关键技术特性

### 5.1 状态持久化与恢复

- **会话级别隔离**：每个会话独立存储状态数据
- **双格式存储**：JSON 用于程序读取，Markdown 用于人工阅读
- **版本控制**：支持工件版本管理
- **断点续传**：支持从任意阶段恢复工作流

### 5.2 错误处理与容错

- **阶段隔离**：单个阶段失败不影响其他阶段执行
- **智能重试**：基于错误分析的针对性修复机制
- **最大重试限制**：防止无限循环，设置最大重试次数
- **详细错误报告**：提供清晰的错误信息和修复建议

### 5.3 用户交互优化

- **渐进式反馈**：每个阶段都有明确的状态反馈
- **人工确认点**：关键决策点支持用户审核和修改
- **友好界面**：清晰的阶段标识和进度展示

## 6. 性能与扩展性

### 6.1 异步执行支持

采用 Rust 异步编程模型，支持高效的并发处理：

```rust
pub async fn run_workflow_from_stage(
    &self,
    session_id: &str,
    model_config: &ModelConfig,
    resume_from: Option<Stage>,
) -> Result<()> {
    // 异步执行各阶段任务
}
```

### 6.2 模块化扩展

- **标准接口设计**：新增智能体只需实现标准 Agent trait
- **配置驱动**：通过 ModelConfig 灵活配置 LLM 服务
- **插件化架构**：支持功能模块的动态加载和替换

## 7. 总结

工作流编排域作为 Cowork AI 系统的核心引擎，通过精心的架构设计和实现，提供了可靠、灵活且用户友好的 AI 驱动软件开发体验。其模块化设计、智能错误恢复机制和强大的状态管理能力，为系统的长期演进和功能扩展奠定了坚实基础。

该域的成功实现体现了现代软件架构的最佳实践，包括关注点分离、依赖注入、异步编程等，为类似的多智能体协同系统提供了有价值的参考实现。